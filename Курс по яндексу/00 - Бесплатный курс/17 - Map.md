# Введение

Вектор позволяет обратиться к значению по индексу, чтобы прочитать или изменить его:



`vector<int> my_vector;
// ...
int value = my_vector[10];
++my_vector[11];` 

Но искать в векторе конкретное значение слишком долго. Вектор сопоставляет целому числу — то есть индексу — определённый элемент. Если в качестве индексов-ключей нужны не числа, а строки, например, применяют тип данных `map`.

Контейнер `map` реализует так называемый ассоциативный массив, то есть хранит данные парами «ключ — значение». В русском языке для `map` принято название «словарь».

Словари — это способ сопоставить ключ и значение. Ключи уникальны и отсортированы, как в уже знакомом вам контейнере `set`.

# Как работают словари

В отличие от других контейнеров, словарь может хранить сразу два значения.

Создание словаря аналогично созданию множества или вектора. Для работы со словарями в С++ нужно подключить заголовок `<map>` стандартной библиотеки. Сначала в угловых скобках пишется тип ключа, а затем — тип значения, например `map<string, int>`. После в фигурных скобках перечисляется содержимое: пара «ключ-значение». В коде ниже ключ — это имя животного (строка), а значение — число его ног (целое число):



`#include <iostream>
#include <string>
#include <map>

using namespace std;

int main() {
    map<string, int> legs_count = {{"dog"s, 4}, {"ostrich"s, 2}};
}` 

Код функции для распечатки такого словаря:

- 

`void PrintMap(const map<string, int>& m) {
    cout << "Size = "s << m.size() << endl;
    for (const auto& [key, value]: m) {
        cout << key << " : "s << value << endl;
    }
}` 

`auto` — ключевое слово, которое просит компилятор самостоятельно определить тип переменной. Об `auto` расскажем подробно дальше в теме. `size()` возвращает количество пар «ключ-значение», которые хранятся в контейнере. Это позволяет узнать размер словаря. Цикл `for` написан удобным для словарей способом. Переменные `key` и `value` проходятся по элементам словаря. В `key` — ключ, а в `value` — значение.

Функция напечатает:



`Size = 2
dog : 4
ostrich : 2` 

Пары в словаре отсортированы по ключам, как элементы во множестве `set`.

Обращаться к элементам словаря можно по аналогии с вектором — квадратными скобками. Разница в том, что у вектора внутрь скобок передают только целые числа. Словарь — ассоциативный массив. Значения в нём ассоциированы со строками, поэтому в оператор `[]` можно добавлять и числа, и строки. Например, вы хотите узнать сколько ног у страуса. Забыли, бывает.



`cout << legs_count["ostrich"s] << endl;` 

Получите закономерный ответ:



`2` 

Элемент в словаре можно изменить:



`++legs_count["ostrich"s];` 

Теперь у страуса три ноги! Ему требуется помощь. Чтобы страус пришёл в форму, нужно обратиться напрямую к записи `legs_count["ostrich"s] = 2;`.

Новую запись в словарь добавляют тоже оператором `[]`:



`//...
legs_count["cat"s] = 4;
PrintMap(legs_count);
//...` 

Информация о кошке заняла своё место в алфавитном порядке по ключам:



`Size = 3
cat : 4
dog : 4
ostrich : 2` 

Синтаксис `map` довольно прост, а вот у работы с ним есть подводные камни. О них — в следующем уроке.

# Подводные камни map

Контейнер `map` состоит из ключа и значения. Чтобы работать с ключом, надо убедиться, что он есть. Для этого используют метод `count()`, который возвращает число вхождений ключа. Как и во множестве `set`, в `map` все ключи уникальны. Поэтому результатом будет либо ноль, либо единица:



`if (legs_count.count(animal_name) > 0) {
    cout << "Yes, we know this animal!"s << endl;
} else {
    cout << "Sorry, no info about this species!"s << endl;
}` 

Чтобы проверить словарь на пустоту, используют метод `empty()`. Он работает так же, как во множестве и векторе.

Чтобы удалить запись из словаря по ключу `key_name`, применяют метод `erase(key_name)`.

Пока всё понятно, никаких подводных камней. Но они возникают при обращении к элементу словаря.

Обратиться к элементу словаря по ключу можно оператором `[]`. Если обратиться к несуществующему элементу, он будет создан со значением по умолчанию.

Перед вами неполный словарь, который используется, чтобы посчитать ноги животных из списка:



`#include <iostream>
#include <string>
#include <map>
#include <set>

using namespace std;

int main() {
    map<string, int> legs_count = {{"dog"s, 4}, {"ostrich"s, 2}};
    const set<string> names = {"dog"s, "cat"s, "elephant"s};
    for (const string& name : names) {
        cout << name << " : "s << legs_count[name] << endl;
    }
}` 

Код выдаст неожиданный результат:



`cat : 0
dog : 4
elephant : 0` 

Но если распечатать словарь, будет понятно, в чём дело:



`Size = 4
cat : 0
dog : 4
elephant : 0
ostrich : 2` 

Каждый раз, когда вы спрашиваете значение по несуществующему ключу, оператор `[]` меняет словарь: добавляет ключ со стандартным для целых чисел нулевым значением.

![image](https://pictures.s3.yandex.net/resources/S7_01_1592340476.png)

Эта особенность бывает полезна. Представьте, что пересчитываете зверей в зоопарке. У вас есть их имена в виде вектора. Можно сначала проверить наличие имени-ключа в словаре и вручную добавить его первое появление:



`map<string, int> animals_count;
vector<string> names = //...
for (const string& name : names) {
    if (animals_count.count(name) == 0) {
        animals_count[name] = 1;
    } else {
        ++animals_count[name];
    }
}` 

Но теперь ясно, что все значения при первом обращении будут проинициализированы нулём. Поэтому достаточно цикла:



 `for (const string& name : names) {
    ++animals_count[name];
}` 

Если нужного ключа нет в строке `++animals_count[name];`, происходит следующее:

1.  Выполняется `animals_count[name]`. Ключа нет, поэтому он добавляется со значением по умолчанию. Для типа `int` это ноль.
2.  `animals_count[name]` возвращает ссылку на соответствующее ключу значение — ноль.
3.  К выражению из второго пункта применяется оператор `++`, который превращает ноль в единицу.

То есть, при отсутствии нужного ключа инкремент его значения добавит в словарь единицу.

# Словари и константность

При обращении по ключу словарь можно изменить. Поэтому использовать квадратные скобки с `const map<..., ...>` нельзя:



`const map<string, int> legs_count = {{"dog"s, 4}, {"ostrich"s, 2}};
int value = legs_count["dog"s];` 

Получим ошибку компиляции:



`test_func.cpp:10:33: error: passing ‘const std::map<std::__cxx11::basic_string<char>, int>’ as ‘this’ argument discards qualifiers [-fpermissive]
int value = legs_count["dog"s];
^
In file included from /usr/include/c++/7/map:61:0,
from test_func.cpp:3:
/usr/include/c++/7/bits/stl_map.h:504:7: note: in call to ‘std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type& std::map<_Key, _Tp, _Compare, _Alloc>::operator[](std::map<_Key, _Tp, _Compare, _Alloc>::key_type&&) [with _Key = std::__cxx11::basic_string<char>; _Tp = int; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >; std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type = int; std::map<_Key, _Tp, _Compare, _Alloc>::key_type = std::__cxx11::basic_string<char>]’
operator[](key_type&& __k)` 

Компилятор говорит: у неизменяемого объекта `const map` нельзя вызывать метод `operator[]`, который может его изменить. Комментарий `discards qualifiers` часто появляется именно из-за попытки изменить константный объект.

Чтобы словарь не обновлялся при запросе неизвестного ключа, применяют метод `at()`. Он действует аналогично квадратным скобкам, но не даёт обратиться к словарю по несуществующему ключу, так как генерирует ошибку. Такую ошибку называют исключение.

Исключения — отдельная большая тема, которая будет подробно раскрыта после вводного курса. Исключения бывают разные. В отличие от ошибок компиляции они возникают, когда программа уже выполняется. Если в процессе выполнения происходят ошибки, которые программа не в состоянии обработать, она срочно завершается, потому что дальнейшая работа невозможна. Последнее, что может сделать программа, — это сообщить, что́ с ней произошло. Обычно исключение генерируется вместе с поясняющим текстом.

Код с `at()` скомпилируется:



 `const map<string, int> birds_amount = {{"chicken"s, 2}, {"duck"s, 3}, {"goose"s, 2}};
  cout << birds_amount.at("bat"s) << endl;` 

Но во время исполнения во второй строке появится исключение:



`terminate called after throwing an instance of 'std::out_of_range'
  what():  map::at
Aborted (core dumped)` 

Сообщение говорит, что после выбрасывания исключения `std::out_of_range` была вызвана команда `terminate`. Значение вышло за пределы диапазона при вызове метода `map::at`. Ключа `bat` в словаре не нашлось, и программа не знала, что делать дальше. У словаря попросили то, чего у него нет.

Казалось бы, что хорошего в экстренном завершении программы. На самом деле так выражается её забота о своём стабильном состоянии. Если бы проверки на существование ключа не было, программа могла повести себя непредсказуемо, и все дальнейшие результаты не были бы надёжными. Чтобы этого избежать, программа сообщает разработчику о проблеме. Инструменты для обработки исключений существуют, но в этом уроке рассматриваться не будут.

Метод `at()` возвращает ссылку на элемент. Поэтому если прилетят ещё две утки, код отработает без проблем:



`birds_amount.at("duck"s) += 2` 

Посмотрите, как `at()` реагирует на выход за границы массива:



`#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> prices = {100, 235, 333};
    cout << prices.at(3) << endl;
}` 

При выполнении также будет выброшено исключение с подробным описанием ошибки:



`terminate called after throwing an instance of 'std::out_of_range'
  what():  vector::_M_range_check: __n (which is 3) >= this->size() (which is 3)
Aborted (core dumped)` 

В `map` несовместимы оператор `[]` и константность. С неизменяемым словарём используют метод `at()`, который вместо новых элементов создаёт ошибку-исключение. Как перехватывать подобные исключения, разберём дальше в курсе.


# Словари с нестандартными значениями

В прошлых уроках значениями словаря было что-нибудь простое: число, символ или строка. Но благодаря гибкости контейнеров и значение, и ключ могут иметь любой тип. В этом уроке вы научитесь манипулировать нестандартными значениями словаря, а заодно напишете центральную часть поискового сервера. Ваш сервер научится сохранять документы и искать их.

Сначала нужно разобраться, как поиск должен работать. Хотелось бы отправить серверу поисковый запрос и набор стоп-слов, а затем получить от него ID всех документов, где есть хотя бы одно слово из списка слов для поиска. Стоп-слова нужны серверу, чтобы исключить их из поискового запроса. Получается следующий алгоритм:

-   Взять слово из поискового запроса и проверить, что это не стоп-слово;
-   Если это не стоп-слово, найти информацию о том, в каких документах оно встречается. Для этого отлично подойдёт словарь. Ключом было бы слово для поиска, а значением — набор ID документов, где это слово встречается. Пусть словарь называется `word_to_documents`. Набор ID легко получить таким запросом:
    
    Скопировать код
    
     `word_to_documents[word_from_query]` 
    
    Да-да, этот запрос вернёт не что-либо одно — одно число или один символ, — а ссылку на целый контейнер со списком документов. Стандартные контейнеры настолько гибкие, что могут содержать в себе другие контейнеры.
    
-   Убрать из результата повторяющиеся ID документов.
-   Набор ID должен быть без повторов.

Вы уже знаете подходящий контейнер для хранения такого списка без повторов.

Что же за контейнер нужен для списка ID документов?

Вектор

Множество

Опять словарь! Получится словарь, где значением будет тоже словарь. И в нём еще один словарь. Очень удобно.

Чтобы хранить что-либо без повторов, удобно использовать множество и библиотеку `<set>`.

---

Для реализации поиска документов понадобится такое интересное хранилище:



`map<string, set<int>> word_to_documents;` 

Можно будет просто обратиться по слову-ключу и сразу получить доступ ко множеству всех документов, где это слово встречается. Это и было нужно.

Но прежде чем что-нибудь искать, важно добавить в базу данных документы, по которым будет идти поиск. Так будет выглядеть запрос на добавление документа в базу данных сервера:



`// создадим базу данных, в которой будем хранить соответствия "слово - документы"
map<string, set<int>> word_to_documents;
// переменная document - это тот документ, который нужно добавить в базу данных
string document = "a fat cat sat on a mat and ate a fat rat"s;
// подготовим множество стоп-слов
const set<string> stop_words = {"a"s, "the"s, "on"s, "end"s};
// определим id нового документа
int document_id = 1;

AddDocument(word_to_documents, stop_words, document_id, document);` 

Внутри функции `AddDocument`:

-   документ будет разбит на слова;
-   стоп-слова будут убраны из документа, ведь серверу не нужно хранить информацию о них;
-   каждое слово будет добавлено в словарь в качестве ключа, а во множество документов, соответствующих этому ключу, будет добавлен ID текущего документа.

Последний пункт можно реализовать через метод `insert`:



`// word_to_documents[word] - вернёт ссылку на множество, соответствующее данному слову.
// если ключа word в словаре до этого не существовало, он будет создан, а множество будет пустым.
// дальше просто вставим document_id в это множество.
word_to_documents[word].insert(document_id);` 

Вот так будет выглядеть код со вспомогательной функцией, которая убирает стоп-слова из рассмотрения:



`vector<string> SplitIntoWordsNoStop(const string& text, const set<string>& stop_words) {
    vector<string> words;
    // проходим по всем словам из текста и проверяем, что их нет в списке стоп-слов
    for (const string& word : SplitIntoWords(text)) {
        if (stop_words.count(word) == 0) {
            words.push_back(word);
        }
    }
    // вернём результат без стоп-слов
    return words;
}

void AddDocument(map<string, set<int>>& word_to_documents,
                 const set<string>& stop_words,
                 int document_id,
                 const string& document) {
    // пройдём по всем словам (без стоп-слов) и добавим их в базу данных
    for (const string& word : SplitIntoWordsNoStop(document, stop_words)) {
        word_to_documents[word].insert(document_id);
    }
}` 

В нём использована функция `SplitIntoWords`, которую вы уже реализовали.

Сервер научился сохранять документы в удобной для поиска структуре. Осталось научить его искать.