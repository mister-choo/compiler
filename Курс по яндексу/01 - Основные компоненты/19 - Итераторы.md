# Понятие итератора

Программисты любят использовать то, что уже написано. Причин на это много. Среди них наверняка есть и лень. Но гораздо важнее другое: если что-нибудь уже написано, значит это протестировано, ошибки найдены и исправлены. Если не все, то хотя бы часть. Поэтому программисты рады, когда менять в коде надо совсем мало. Чем меньше, тем лучше. Меньше изменений, меньше ошибок, меньше времени на разработку.

Чтобы избежать будущих изменений и сделать код более гибким, программисты прибегают к приёму, который можно назвать «добавление уровня абстракции».

Рассмотрим пример:


```cpp

#include <iostream>

using namespace std;

int main() {
    cout << "Платочки белые"s << endl;
    cout << "Платочки белые"s << endl;
    cout << "Платочки белые"s << endl;
    cout << "Платочки белые, глаза печальные"s << endl;
    cout << "Вагончик тронется"s << endl;
    cout << "Вагончик тронется"s << endl;
    cout << "Вагончик тронется"s << endl;
    cout << "Вагончик тронется, перрон останется"s << endl;
} 

```

Если окажется, что платочки не белые, а синие, придётся поправить это в четырёх местах. Шанс ошибиться и забыть внести нужное исправление достаточно большой.

Добавляем новый уровень абстракции — переменные, куда положим строки:


```cpp

#include <iostream>
#include <string>

using namespace std;

int main() {
    string chorus_1 = "Платочки белые"s;
    string chorus_2 = "Вагончик тронется"s;
    cout << chorus_1 << endl;
    cout << chorus_1 << endl;
    cout << chorus_1 << endl;
    cout << chorus_1 <<", глаза печальные"s << endl;
    cout << chorus_2 << endl;
    cout << chorus_2 << endl;
    cout << chorus_2 << endl;
    cout << chorus_2 << ", перрон останется"s << endl;
} 

```

Теперь заменить цвет платочков стало гораздо проще. Мы абстрагировались от конкретной строки и работаем с переменной. Переменная — наш новый уровень абстракции. Если пофантазировать с этим примером дальше, можно найти и такую абстракцию как цикл. За ней будет прятаться повторение строчек нужное количество раз. А мы увидим, что циклов уже два, и добавим ещё один уровень абстракции — функцию. Потом подумаем, что, может быть, не хотим выводить всю песню на консоль, и было бы здорово записать её в файл или отправить в сеть. Будут появляться всё более и более высокие уровни абстракции, которые позволят делать код гибче. Именно так когда-то была придумана концепция итераторов.

Отвлекитесь от платочков, нас ждут более насущные дела — итерация по контейнерам.

Для каждого контейнера переход от одного элемента к другому может осуществляться разными способами. Например, чтобы перейти с одного элемента вектора на другой, нужно просто сдвинуться в памяти компьютера вперёд на размер одного элемента вектора. Во множестве и словаре будет иначе. Возникают вопросы:

-   Должен ли запускаемый алгоритм знать эти различия?
-   Если пишем алгоритмы под каждый контейнер, каков шанс, что ошибка, найденная в одном из алгоритмов, будет исправлена в другом?

Гораздо удобнее придумать новую абстракцию и научить алгоритмы работать с ней, а за каждой абстракцией спрятать конкретную реализацию.

Вспомним уже известный вам алгоритм `count`:


```cpp

const vector<int> xs = {1, 2, 1, 1, 5};
cout << count(xs.begin(), xs.end(), 1) << endl; // 3 

```

Методы `xs.begin()` и `xs.end()` возвращают итераторы, и дальше алгоритм `count` работает именно с итераторами. Через них алгоритм получает доступ к элементам контейнера, может итерировать по элементам, но к самому контейнеру у алгоритма доступа нет. Вектор остаётся неизменным. Не меняется порядок элементов, размер не увеличивается и не уменьшается. Сделать это через итераторы нельзя. Получается, что итераторы ещё и защищают контейнер от неожиданных изменений. При этом заменить `vector` на другой контейнер не составит труда.

# Концепция полуинтервалов

В этом уроке вы познакомитесь с концепцией полуинтервалов и узнаете, как она связана с итераторами.

### Элемент, которого нет

Вернёмся к задаче из предыдущего урока:


```cpp

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct Lang {
    string name;
    int age;
};

int main() {
    vector<Lang> langs = {{"Python"s, 29}, {"Java"s, 24}, {"C#"s, 20}, {"Ruby"s, 25}, {"C++"s, 37}};
    // Выведите первый язык, начинающийся на J, используя алгоритм find_if
    auto result = find_if(langs.begin(), langs.end(), [](const Lang &lang) {
        return lang.name[0] == 'J';
    });
    cout << result->name << ", "s << result->age << endl;
} 

```

Попробуем найти то, чего в контейнере нет. Например, поищем хоть что-нибудь, начинающееся с “K”:


```cpp

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct Lang {
    string name;
    int age;
};

int main() {
    vector<Lang> langs = {{"Python"s, 29}, {"Java"s, 24}, {"C#"s, 20}, {"Ruby"s, 25}, {"C++"s, 37}};

    auto result = find_if(langs.begin(), langs.end(), [](const Lang &lang) {
        return lang.name[0] == 'K';
    });
    cout << result->name << ", "s << result->age << endl;
} 

```

Попытайтесь запустить этот код. Скорее всего, программа просто упадёт. Но понять, получилось ли что-то найти, хочется. Это несложно. Если ничего не найдено, функция вернёт в качестве результата тот же итератор, что возвращается при использовании метода `end`. Но называть его «‎концом контейнера» пока не будем — сначала нужно разобраться. Говоря «‎конец контейнера», можем иметь в виду два места:

1.  Последний элемент контейнера;
2.  Место, не содержащее никакого элемента и находящееся за последним из них.

![image](https://pictures.s3.yandex.net/resources/S2_01_1602617479.png)

Во втором случае речь об итераторе, который возвращает метод `end`. Этот итератор указывает на некое место за пределами контейнера. Так можно понять, что элемент в контейнере не найден.

Мы называем что-либо интервалом, если начало и конец НЕ входят в число элементов. В математике это принято обозначать так:

$(1; 10)$ — здесь и 1, и 10 НЕ входят в интервал. То есть входят в него целые числа 2, 3, 4, 5, 6, 7, 8 и 9.

Мы называем что-либо полуинтервалом, если что-нибудь одно (начало или конец) не включено в число элементов. В математике это выглядит так:

$[1; 10)$ — здесь 1 будет элементом, а 10 уже нет. В полуинтервал входят целые числа 1, 2, 3, 4, 5, 6, 7, 8, и 9. Число 10 всё ещё никуда не входит.

Переводя идею интервалов на итераторы, получаем концепцию полуинтервалов.

### Веди себя как итератор

Идею полуинтервалов разберём подробно. Но перед этим посмотрим, что такое итератор в принципе.

Это не тип данных и не контейнер. Итератор не содержит никаких данных, он может только указывать на них. Похож на ссылку, но его можно двигать. Ещё он умеет показывать на что-нибудь, что элементом не будет, а ссылка обязательно должна указывать на нечто содержательное.

По своей сути итератор — это объект, для которого определены некоторые действия. Например, оператор `*` позволяет получить доступ к элементу контейнера, на который итератор указывает. Так же определён оператор `++`, чтобы передвигаться от элемента к элементу. К итератору можно добавлять число и сдвигаться на некое количество позиций.

Всё это подразумевается, когда итератор передаётся в алгоритм. Если объект, полученный алгоритмом в качестве итератора, будет уметь делать то, что должен делать итератор, он будет признан итератором.

А теперь, зная, что к итератору можно прибавлять числа, посмотрим на полуинтервалы в примере. В нашем векторе языков программирования пять элементов, а позиций, на которые может условно указывать итератор — шесть. Если `langs.begin()` указывает на нулевой элемент, то `langs.begin() + 5` указывает на `langs.end()`, и между ними ровно пять элементов. Удобно, что разность итераторов равна количеству элементов в соответствующем полуинтервале.

# Итераторы в конструкторах контейнеров

Итераторы широко применяются не только в библиотеке алгоритмов и циклах обхода, но и в методах контейнеров. В этом уроке посмотрим, как это работает в конструкторах, а в следующем уроке затронем методы вставки и удаления, использующие итераторы.

Применять итераторы в конструкторах бывает удобно. Из вектора языков программирования с повторениями мы можем с легкостью сделать множество уникальных языков:


```cpp

#include <algorithm>
#include <iostream>
#include <set>
#include <string>
#include <vector>

using namespace std;

template <typename It>
void PrintRange(It range_begin, It range_end) {
    for (auto it = range_begin; it != range_end; ++it) {
        cout << *it << " "s;
    }
    cout << endl;
}

template <typename It>
auto MakeSet(It range_begin, It range_end) {
    return set(range_begin, range_end);
}

int main() {
    vector<string> langs = {"Python"s, "Java"s, "C#"s, "Ruby"s, "C++"s, "C++"s, "C++"s, "Ruby"s, "Java"s};
    auto unique_langs = MakeSet(langs.begin(), langs.end());
    PrintRange(unique_langs.begin(), unique_langs.end());
} 

```

Результат работы программы:
```

C# C++ Java Python Ruby 

```

Обратите внимание на простоту и изящество кода в примере. Мы просто даём итераторы — даже не сам контейнер — и компилятор понимает, какой конструктор для множества вызвать.

# Итераторы в методах контейнеров

Элементы любого контейнера можно перебрать, используя итераторы. Это прямое назначение итераторов. Зная место в контейнере, можно, например, удалить элемент или вставить новый. Итераторы позволяют не думать о порядковом номере элемента в контейнере. В этом уроке вы узнаете о возможностях итераторов в методах контейнера и научитесь обходить подводные камни при работе с ними.

### Метод Insert

Один из примеров использования итераторов в методах контейнеров — метод `insert`. Он даёт возможность вставить элемент в определённое место в контейнере — перед итератором, который передадим в качестве параметра.

Рассмотрим пример. Применим уже известный вам алгоритм `find`, чтобы найти всё в том же векторе языков С++. Этот алгоритм вернёт итератор на элемент С++ в векторе. Затем возьмём метод `insert`, вставим в наш вектор предка С++ — язык С — и выведем результат:


```cpp

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

template <typename It>
void PrintRange(It range_begin, It range_end) {
    for (auto it = range_begin; it != range_end; ++it) {
        cout << *it << " "s;
    }
    cout << endl;
}

int main() {
    vector<string> langs = {"Python"s, "Java"s, "C#"s, "Ruby"s, "C++"s};
    auto it = find(langs.begin(), langs.end(), "C++"s);
    langs.insert(it, "C"s);
    PrintRange(langs.begin(), langs.end());
} 

```

Вот наш вектор:

Скопировать код

`Python Java C# Ruby C C++` 

Язык С добавился в вектор перед С++. Иначе говоря, элемент был добавлен перед итератором, переданным в качестве аргумента. Разберёмся, почему это удобно.

В нашем векторе было пять элементов и шесть возможных позиций итераторов. Если бы метод `insert` вставлял элемент после переданного итератора, вставить на первое место в контейнер было бы невозможно. Дело в том, что если передать в качестве параметра итератор `begin`, элемент вставится на второе место. А при передаче итератора `end` возникла бы неопределённость. Элемента, на который указывает `end`, в контейнере нет, и как вставить элемент после него — непонятно.

Поэтому логично делать вставку до переданного итератора. В этом случае вызов `insert` с итератором `end` равносилен для вектора методу `push_back`.

Метод `insert` можно использовать ещё несколькими способами:

-   `container.insert(it, range_begin, range_end)` — вставит полуинтервал от `range_begin` до `range_end` до позиции `it`;
-   `container.insert(it, count, value)` — вставит `count` раз элемент `value` до позиции `it`;
-   `container.insert(it, {1, 2, 3})` — вставит `{1, 2, 3}` до `it`.

Если есть вставка, должно быть и удаление. В задачах к этому уроку вы самостоятельно разберётесь с методом `erase`, который работает по аналогии с `insert`.

### Важный эффект применения методов контейнера

Работая с итераторами, мы никак не модифицировали сам контейнер. Не меняли его размер, ничего не вставляли и не удаляли. Могли просто пройти по элементам, найти что-нибудь, поменять элементы местами, но контейнер при этом оставался неизменным. Итераторы сами по себе менять его не умеют. Итератор — всего лишь абстракция. Она подразумевает перемещение по контейнеру, а не изменение.

То есть раньше мы могли спокойно вызвать метод `begin`, сохранить результат в локальную переменную, использовать какой-нибудь алгоритм и не переживать, что с переменной что-то случилось:


```cpp

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

template <typename It>
void PrintRange(It range_begin, It range_end) {
    for (auto it = range_begin; it != range_end; ++it) {
        cout << *it << " "s;
    }
    cout << endl;
}

int main() {
    vector<string> langs = {"Python"s, "Java"s, "C#"s, "Ruby"s, "C++"s};
    // Присвоим локальной переменной значение итератора начала вектора
    auto it_begin = langs.begin();
    auto it_end = langs.end();
    auto it = find(it_begin, it_end, "C++"s);
    // Никаких проблем, все итераторы остались на своих местах
    PrintRange(it_begin, it);
    PrintRange(it, it_end);
} 

```

Но теперь мы знаем методы, которые изменяют контейнер. Под капотом этих методов с контейнером может произойти всё что угодно. В том числе он может быть скопирован в другой контейнер, а исходный контейнер будет при этом разрушен, и мы, пользователи, никогда об этом не узнаем. Реализация этих методов для нас — «чёрный ящик», она инкапсулирована.

Поэтому запомните: если контейнер каким бы то ни было способом был изменён, возможно, что ранее использованные итераторы инвалидированы. Работать с ними уже нельзя. Итератор не знает, что с контейнером что-то произошло, и не может модифицировать сам себя. За это отвечает пользователь.

```cpp


#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

template <typename It>
void PrintRange(It range_begin, It range_end) {
    for (auto it = range_begin; it != range_end; ++it) {
        cout << *it << " "s;
    }
    cout << endl;
}

int main() {
    vector<string> langs = {"Python"s, "Java"s, "C#"s, "Ruby"s, "C++"s};
    // Присвоим локальной переменной значение итератора начала вектора
    auto it_begin = langs.begin();
    auto it_end = langs.end();
    auto it = find(it_begin, it_end, "C++"s);
    // Здесь контейнер изменяется, а вместе с ним и все его итераторы!
    langs.insert(it, "C"s);
    // Непредсказуемое поведение
    PrintRange(it_begin, it_end);
} 

```

Мы не знаем, куда будет указывать локальная переменная после использования метода `insert`. Нужно вызвать метод `begin` снова, чтобы гарантировать правильность работы кода:


```cpp

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

template <typename It>
void PrintRange(It range_begin, It range_end) {
    for (auto it = range_begin; it != range_end; ++it) {
        cout << *it << " "s;
    }
    cout << endl;
}

int main() {
    vector<string> langs = {"Python"s, "Java"s, "C#"s, "Ruby"s, "C++"s};
    // Присвоим локальной переменной значение итератора начала вектора
    auto it_begin = langs.begin();
    auto it_end = langs.end();
    auto it = find(it_begin, it_end, "C++"s);
    // Здесь контейнер изменяется, а вместе с ним и все его итераторы!
    langs.insert(it, "C"s);
    // Обновим значения переменных
    it_begin = langs.begin();
    it_end = langs.end();
    // Теперь все точно сработает правильно
    PrintRange(it_begin, it_end);
} 

```

Подробности о том, что происходит с итераторами после работы метода, лучше смотреть в документации. У каждого метода свои тонкости.



 # Категории итераторов

В прошлых уроках мы обращались со всеми итераторами одинаково. Но на самом деле они отличаются друг от друга. В этом спринте вы изучите алгоритмы, которые упрощают жизнь программиста. Но для этого сначала разберёмся, какие категории итераторов существуют и чем они отличаются.

Вспомним, что итератор — это не тип данных, а набор действий, которые с ними можно совершить. Соответственно, типы итераторов отличаются по набору поддерживаемых действий. Видя тот или иной тип итератора в качестве аргумента для функции, можно понять, какие действия этот итератор должен поддерживать.

### Итератор чтения (Input iterator)

Поддерживаемые операции:

-   Чтение значения элемента. Это значит, что внутри метода или функции, принимающей такой итератор, нужно будет прочитать элемент по итератору. Вот так: `*it`;
-   Операторы сравнения `==` и `!=`. Это мы использовали, когда в цикле `for` сравнивали итератор с `end`;
-   Оператор `++` (как префиксный, так и постфиксный) для перемещения на следующий элемент.

Такие итераторы гарантируют возможность чтения элемента, но не гарантируют запись. Они должны поддерживать минимальный набор действий над собой.

Посмотрим на заголовок алгоритма [find](https://ru.cppreference.com/w/cpp/algorithm/find). Обратите внимание на `InputIt`. Это значит, что алгоритм будет обращаться к элементам контейнера, чтобы их прочитать. Итераторы всех изученных контейнеров — это итераторы чтения. Так что в `find_if` их передать можно:


```cpp

template< class InputIt, class T >
InputIt find( InputIt first, InputIt last, const T& value ); 

```

### Итератор записи (Output iterator)

Поддерживаемые операции:

-   Запись значения в элемент. Это значит, что метод или функция через итератор будут пытаться обратиться к элементу и записать в него какое-нибудь значение. Вот так: `*it = new_value`;
-   Операторы сравнения `==` и `!=`;
-   Оператор `++` (как префиксный, так и постфиксный).

Итераторы не обязаны гарантировать возможность чтения.

Пример алгоритма, использующего такой итератор, — [`copy`](https://ru.cppreference.com/w/cpp/algorithm/copy). Он копирует диапазон от `first` до `last` в диапазон, начинающийся с `d_first`. При этом `first` и `last` будут использованы только для чтения, а `d_first` — только для записи. Итераторами записи также будут, например, неконстантные итераторы вектора или строки. Если имеете дело со множеством или с константным контейнером, изменить значение по итератору ожидаемо не выйдет:


```cpp

template< class InputIt, class OutputIt >
OutputIt copy( InputIt first, InputIt last, OutputIt d_first ); 

```

### Однонаправленный итератор (Forward iterator)

Однонаправленный итератор — итератор чтения с возможностью обойти элементы контейнера, но только в одном направлении. Обход контейнера может быть сделан несколько раз. Только вперёд и ни шагу назад. Иначе говоря, оператор декремента `--` у них может быть не определён. Пример алгоритма, использующего такой итератор — [`replace`](https://ru.cppreference.com/w/cpp/algorithm/replace).

### Двунаправленный итератор (Bidirectional iterator)

Двунаправленный итератор — это однонаправленный итератор, которого научили ходить назад. Для двунаправленного итератора должен быть определён оператор декремента. Пример алгоритма, использующего такой итератор, — [`reverse`](https://ru.cppreference.com/w/cpp/algorithm/reverse).

### Итератор произвольного доступа (Random access iterator)

Самые строгие требования предъявляются к итератору произвольного доступа. Кроме всех операций, поддерживаемых двунаправленным итератором, в его наборе должны быть:

-   Операции сложения и вычитания с числами для перемещения сразу на определённое расстояние от текущей позиции;
-   Возможность вычитать итераторы друг из друга;
-   Операторы сравнения `>`, `<`, `>=`, `<=`;
-   Оператор `[ ]`. Выражение `it[n]` равносильно выражению `*(it + n)`, то есть оно позволяет получить доступ к элементу, отстоящему от итератора it на n позиций

Пример алгоритма, для которого нужны итераторы произвольного доступа, — [`random_shuffle`](https://ru.cppreference.com/w/cpp/algorithm/random_shuffle).

Если краем глаза заглянем в документацию, увидим, что на самом деле все категории итераторов — пустые классы. Они нужны только для того, чтобы пользователь по списку аргументов функции мог понять, какие операции внутри функции будут применяться и что передаваемый итератор должен поддерживать. Вся ответственность за передачу итератора нужной категории лежит на пользователе.

### Advance, distance и next

Бывает, что внутри кода нужно сдвинуть итератор на несколько шагов или узнать расстояние между двумя итераторами. При этом итераторов произвольного доступа среди имеющихся нет. В таких случаях применяют функции [advance](https://ru.cppreference.com/w/cpp/iterator/advance), [distance](https://ru.cppreference.com/w/cpp/iterator/distance) и [next](https://ru.cppreference.com/w/cpp/iterator/next).

`Advance` шаг за шагом сместит итератор `it` на нужное количество элементов. `n` может быть и отрицательным. Тогда итератор должен поддерживать требования к категории двунаправленных итераторов, а не просто итераторов чтения. Иначе поведение функции не определено. Пример:


```cpp

template< class InputIt, class Distance >
void advance( InputIt& it, Distance n ); 

```

`Distance` просто считает, сколько надо сделать шагов от `first` до `last`. Если дойти от `first` до `last` или от `last` до `first` невозможно, поведение функции не определено, и полагаться на результат не стоит. Пример:


```cpp

template< class InputIt >
typename std::iterator_traits<InputIt>::difference_type
distance( InputIt first, InputIt last ); 

```

`Next` похожа на `advance`, но не меняет сам итератор — он остаётся на месте. Next возвращает итератор на новую позицию, а `advance` сдвигает итератор, переданный в качестве параметра. Кроме этого, если не передадим в `next` параметр количества позиций, по умолчанию нам вернётся итератор на следующую позицию. Пример:


```cpp

template< class ForwardIt >
ForwardIt next( ForwardIt it,
                typename std::iterator_traits<ForwardIt>::difference_type n = 1 ); 

```

Для итераторов произвольного доступа эффективнее использовать оператор вычитания и сложения. Например, если вы уже внутри метода или функции, которая работает только с итераторами произвольного доступа, выберите арифметические операции. Функции `advance`, `distance` и `next` сначала должны определить, какой итератор перед ними. У арифметических операций дополнительной проверки на то, какая категория итератора применяется, нет. Но в случаях, когда хотите поддержать и другие категории итераторов, используйте `distance` и `advance`. Так вы избежите ошибок компиляции. О них — далее.

### Что будет, если сделать, как не надо

Отправим в алгоритм итератор неподходящей категории. Воспользуемся тем, что

-   итератор контейнера `set` — двунаправленный, как сообщает [документация](https://ru.cppreference.com/w/cpp/container/set);
-   алгоритм `random_shuffle` требует итераторы категории произвольного доступа.

Логики в том, чтобы вызывать `random_shuffle` для контейнера `set`, нет никакой, но нам интересно посмотреть поведение компилятора:


```cpp

set<string> unique_langs = {"Python"s, "Java"s, "C#"s, "Ruby"s, "C++"s};
random_shuffle(unique_langs.begin(), unique_langs.end()); 

```

Запустив компиляцию, увидим ошибки. Например, такую:

Скопировать код

`error: no match for 'operator+' (operand types are 'std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char> >' and 'int')
for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)` 

Компилятор пытается найти оператор сложения для итератора и для числа. Но оператора у него нет, так как двунаправленные итераторы не умеют складываться с числами. А без этого не работает алгоритм. Компилятор не находит подходящий метод и сообщает об ошибке.

При этом компилятор не говорит, что мы передали итератор не той категории. С этой точки зрения всё в порядке: в качестве итераторов можно передавать любые типы. Главное, чтобы компилятор смог найти все нужные для работы алгоритма методы.


# Стандартные алгоритмы — рекурсия

Вы уже достаточно знаете об итераторах, чтобы освоить алгоритмы. Изучать их начнём с интересного явления в программировании — рекурсии. Она понадобится вам дальше, когда будете писать алгоритм для сортировки элементов в контейнере.

### Как работает рекурсия

Идея рекурсии проста. В тот момент, когда ваш алгоритм должен начать повторять одно и то же действие, он вызывает сам себя. По сути, рекурсия — это цикл, только действия цикла находятся в функции, которая на каждом шаге вызывает саму себя.

Но, как и у любого цикла, у рекурсии должно быть условие окончания работы, позволяющее функции не вызвать саму себя и тем самым начать процесс выхода.

Чтобы разобраться, вычислим факториал числа. Но сначала вспомним, что такое факториал:


```cpp

0! = 1 (так принято)
1! = 1
2! = 1 * 2 = 2
3! = 1 * 2 * 3 = 6
4! = 1 * 2 * 3 * 4 = 24 

```

Иначе говоря:


```cpp

n! = (n-1)! * n 

```

То есть, чтобы вычислить факториал числа, нужно узнать факториал числа на единицу меньше, а потом умножить его на само число. И делать это до тех пор, пока число не станет равно единице, ведь для неё факториал определён и равен ей самой — ничего считать не надо. Вычислим факториал в цикле. Тогда это выглядело бы так:


```cpp

uint64_t Factorial(int num) {
    int factorial = 1;
    while (num > 1) {
        factorial *= num;
        --num;
    }
    return factorial; 

```

На каждом шаге умножаем факториал, полученный на предыдущем шаге, на число из текущего шага. Цикл заканчивается, когда доходим до единицы. Случай с нулём обрабатывается корректно, и мы просто не заходим в цикл. Нам важно написать цикл именно так. Это наглядно проиллюстрирует, как работает рекурсия.

Заменим цикл на рекурсивный вызов и получим:


```cpp

uint64_t Factorial(int num) {
    int factorial = 1;
    if (0 != num) {
        factorial = Factorial(num - 1) * num;
    }
    return factorial;
} 

```

Чтобы увидеть происходящее в рекурсии, добавим вывод на экран:


```cpp

uint64_t Factorial(int num) {
    int factorial = 1;
    cout << "Текущее число = "s << num << endl;
    if (num != 0) {
        factorial = Factorial(num - 1) * num;
    }
    cout << "Значение факториала "s << factorial << "для числа "s << num << endl;
    return factorial;
} 

```

При подсчёте факториала для числа четыре будет выведено следующее:


```cpp

Текущее число = 4
Текущее число = 3
Текущее число = 2
Текущее число = 1
Текущее число = 0
Значение факториала 1 для числа 0
Значение факториала 1 для числа 1
Значение факториала 2 для числа 2
Значение факториала 6 для числа 3
Значение факториала 24 для числа 4 

```

Сначала как будто «падаем» в рекурсию до конца — пока не достигнем условия выхода. Дальше начинаем «раскручиваться»‎ обратно: возвращаем предыдущему вызову функции текущий результат, умножая его на число, потом опять возвращаем результат выше до тех пор, пока не вернёмся к первому вызову, где число было равно четырём. Делаем последние вычисления и возвращаем конечный результат.

В предыдущем спринте вы изучали раскрутку стека. Стек функций показывает, какие функции в каком порядке были вызваны. К этой информации можно обратиться во время отладки программы. Но внутри стека сохраняются и все данные о локальных переменных и аргументах каждого вызова. То есть несмотря на то, что функция вызывает сама себя, на самом деле это ничем не отличается от вызова разных функций. На стеке будут храниться аргументы и переменные каждого конкретного вызова.

Когда рекурсивная функция делает `return` или просто заканчивает своё выполнение, если возвращаемый тип `void`, возвращаемся по стеку к предыдущему вызову. Все данные переменных и аргументов в стеке останутся в том виде, в каком они были при вызове функции самой себя.

Посмотрим, что будет, если условие выхода не выполнится. Предположим, мы написали его неправильно:


```cpp

uint64_t Factorial(int num) {
    int factorial = 1;
    cout << "Текущее число = "s << num << endl;
    // обратите внимание на изменение в условии выхода
    if (num != 1) {
        factorial = Factorial(num - 1) * num;
    }
    cout << "Значение факториала "s << factorial << "для числа "s << num << endl;
    return factorial;
} 

```

Если теперь попытаемся вычислить факториал нуля, функция будет вызывать себя бесконечно. Это приведёт к тому, что стек функций станет слишком большим, чтобы храниться в памяти, и программа не сможет продолжить работу.

### Как работать с рекурсией

Хорошего программиста отличают не тайные знания о хитростях языка и не крутейшая среда разработки. Самый умный программист никогда не пишет код сразу. Первое, что он (или она) делает — берёт ручку, листок бумаги и создаёт так называемый «псевдокод». Обдумывает, как программа, класс или функция должны выглядеть. Рисует квадратики и стрелочки, пишет на своем родном, человеческом, языке. Пытается понять каждую деталь, которую ему предстоит написать. Потом меняет угол зрения. Представляет себя пользователем своей программы, придумывает, какие тесты может сделать. Записывает их и там же, на бумаге, ручкой проверяет, будет ли его программа работать для этих тестов. После этого хороший программист открывает лучшую среду разработки и пишет свой гениальный код.

Программист похуже в это время уже третий раз переписывает свою программу, правит баги, проходит отладку и снова обнаруживает что-нибудь, о чём не подумал (или не подумала).

Рекурсия позволяет писать красивые, элегантные и лаконичные решения. Но планировать её следует тщательно. Иначе в случае ошибки вы рискуете получить не просто неверное значение, а переполнение стека и зависание программы. Кроме того, несмотря на изящество, для рекурсии сложно делать отладку. Каждый раз нужно внимательно следить, в каком вызове функции вы находитесь. Особо коварные баги любят прятаться в рекурсиях, зная, что найти их там тяжело.

Перед тем как писать рекурсию, возьмите листок бумаги и препарируйте свою задачу. Ответьте на три вопроса:

1.  **Какие параметры она будет принимать?** Часто верные параметры — уже половина решения. В нашем примере всё просто — это число, для которого ищем факториал.
2.  **Какие действия должна совершить функция на каждом шаге?** В нашем случае это просто умножение текущего числа на результат факториала для числа, меньшего на единицу.
3.  **Каково условие завершения?** В случае с факториалом, если число стало равно одному, никакие вычисления дальше не нужны, и можем начинать «‎раскручиваться» обратно.

Когда ответы на все три вопроса для вас ясны, и вы подумали про тесты, приступайте к написанию кода. Лучшие рекурсивные решения — это тщательно спланированные.


## Задание 3

А теперь по-настоящему серьёзный вызов: Ханойская башня — популярная головоломка XIX века по версии Википедии.

Даны три стержня. На один из них нанизаны восемь колец разного размера. Кольца лежат меньшее на большем. Задача в том, чтобы перенести пирамиду из восьми колец на другой стержень за наименьшее число ходов. За один раз можно переносить только одно кольцо, причём нельзя класть большее кольцо на меньшее.

Решите эту задачу рекурсивным методом. Напишите функцию `SolveHanoi`, которая принимает ссылку на вектор из трёх стержней-башен. На первой башне надето определённое количество дисков — не обязательно восемь, как в классической задаче. Количество можно узнать, воспользовавшись методом `GetDisksNum`. Класс `Tower` уже имеет некоторые методы или части методов. Другие методы вы можете дописывать так, как вам нужно для решения. В результате работы функции `SolveHanoi` все диски в правильном порядке должны оказаться на третьей башне.

Чтобы решить задачу, вспомните, что во все методы класса неявно передаётся указатель на объект `this`. А если применить оператор `*`, можно получить доступ к самому элементу. Чтобы освежить в памяти детали, вернитесь к уроку «[Перегрузка операций присваивания](https://praktikum.yandex.ru/trainer/cpp/lesson/b1a644aa-2ee4-4ccc-8009-d52ad7846925/task/5889e48e-cd73-44e3-96bb-7c9b3e6c0bc6/)».

### Пример использования


```cpp

int main() {
    int towers_num = 3;
    int disks_num = 3;
    vector<Tower> towers;
    // добавим в вектор три пустые башни
    for (int i = 0; i < towers_num; ++i) {
        towers.push_back(0);
    }
    // добавим на первую башню три кольца
    towers[0].SetDisks(disks_num);

    SolveHanoi(towers);
} 

```

### Пример результата работы

Ниже не пример вывода на экран — в задаче он не требуется. Это пример того, что должно произойти с вектором башен после вызова `SolveHanoi`:


```cpp

Вектор башен до перемещения:
Башня 1: 3 2 1
Башня 2: 0 0 0
Башня 3: 0 0 0

Вектор башен после перемещения:
Башня 1: 0 0 0
Башня 2: 0 0 0
Башня 3: 3 2 1
```


# Стандартные алгоритмы из `<algorithm>`

Вы уже знакомы с некоторыми алгоритмами из стандартной библиотеки `<algorithm>`. Теперь вы можете расширить знания — освоить алгоритмы, в применении которых нужны итераторы.

Алгоритмов в библиотеке много. Работая над реальными задачами, вы не раз будете самостоятельно разбираться с алгоритмами, библиотеками и методами контейнеров. Прямо сейчас вы научитесь это делать, используя официальную документацию C++ [по ссылке](https://ru.cppreference.com/w/). Возьмём алгоритм `remove_if`.

Откройте страницу [https://ru.cppreference.com/w/cpp/algorithm/remove](https://ru.cppreference.com/w/cpp/algorithm/remove).

Казалось бы, из названия алгоритма следует функционал. Но это не совсем так. Посмотрите, как выглядит заголовок функции. `remove` и `remove_if` принимают полуинтервал итераторов, из которого должны быть удалены элементы. Удаляются они в следующих ситуациях:

-   если равны некоему значению (в случае с `remove`);
-   если функция, переданная в `remove_if`, возвращает `true`.

Контейнер в алгоритм не передаётся, только его итераторы.

# Выводим результаты поиска страницами

Итераторы можно применять далеко не в самых очевидных случаях. Представьте, что ваш поисковый сервер содержит сотни тысяч или даже миллионы документов. Из них тысячи подходят под запрос пользователя. В этом случае вывод всех запросов на экран разом не будет хорошей идеей. Нужно разбивать результаты на страницы.

Пригодятся итераторы. Предположим, у нас есть контейнер. Тогда одна страница — это некий диапазон определённого размера из этого контейнера. Первый элемент входит в страницу, а последний — нет. Зато последний будет первым элементом на следующей странице. То есть можем получить контейнер с результатами, а потом на основе него создать вектор диапазонов, где диапазон будет просто парой итераторов. Первый итератор укажет на начало страницы, а второй — на её конец.

Отвечать за разделение по страницам может новый класс. Назовём его `Paginator`. Пусть это будет класс-шаблон. Он работает так же, как метод-шаблон, только при создании объекта такого класса надо указать тип. С подобными классами вы уже встречались. Например, все классы контейнеров — шаблоны. Синтаксис будет выглядеть так:


```cpp

template <typename Iterator>
class Paginator {
        // тело класса
};
```
