# Введение

Вы уже сталкивались с алгоритмами поиска и методами контейнеров `find` и `count`. Алгоритм [`find`](https://ru.cppreference.com/w/cpp/algorithm/find) и его родственники `find_if` и `find_if_not` ищут элемент в контейнере. Алгоритмы [`count`](https://ru.cppreference.com/w/cpp/algorithm/count) и `count_if` возвращают количество элементов, равных переданному параметру, и количество элементов, для которых выполняется некое условие.

Когда у контейнера есть собственные методы поиска, лучше использовать их, а не общий алгоритм. Например, при поиске в словаре или множестве метод `find` будет эффективнее, чем алгоритм `find`:


```cpp

map<int, string> my_map;
my_map[0] = "первый"s;
my_map[1] = "второй"s;
my_map[2] = "третий"s;
// результаты этих двух поисков будут одинаковы,
// но первый будет сделан более эффективно
auto it_more_efficient = my_map.find(1);
auto it = find(my_map.begin(), my_map.end(), 1); 

```

Простой поиск элемента, проверка его существования и подсчёт элементов — не единственные алгоритмы поиска. В этой теме вы научитесь:

-   искать первый элемент, равный данному или больший,
-   искать первый элемент, больший, чем данный,
-   делать всё это в отсортированном и неотсортированном векторе, строке, в словаре и множестве.

Чтобы систематизировать знания, вы будете отмечать методы и функции в таблице.


# Бинарный поиск

В прошлом уроке вы освоили алгоритмы поиска в неотсортированном векторе, а в этом займётесь отсортированным вектором. Вектор и строка в данном случае эквивалентны.

Рассмотрим алгоритм, позволяющий проверить существование элемента в отсортированном векторе. В математике такой алгоритм называется двоичным или бинарным поиском. Предположим, перед нами отсортированный вектор чисел:

Скопировать код

`1 2 4 4 6 7 8 8 8 9 11` 

Попытаемся найти в этом векторе число девять:

-   Найдём средний элемент. Здесь это семь.
-   7 != 9, но при этом 7 < 9, а вектор отсортирован. Значит все элементы слева от семи нам не подходят, ведь они меньше семи, и девятки там точно нет:
    
    Скопировать код
    
     `1 2 4 4 6 7 8 8 8 9 11` 
    
-   Найдём средний элемент части, расположенной справа от семёрки. Это последняя восьмёрка:
    
    Скопировать код
    
     `8 8 8 9 11` 
    
-   8 != 9 и 8 < 9. Снова отбросим правую часть и продолжим поиск.
-   Найдём середину в оставшейся части. Там всего два элемента. В качестве середины можно взять элемент справа или слева.
-   Возьмём элемент слева и поймём: это именно то, что мы искали:
    
    Скопировать код
    
     `9 11` 
    

Такой метод реализован в функции [`binary_search`](https://ru.cppreference.com/w/cpp/algorithm/binary_search):


```cpp

template< class ForwardIt, class T >
bool binary_search( ForwardIt first, ForwardIt last, const T& value ); 

```

Функция `binary_search` принимает итераторы на начало и конец диапазона поиска, а также значение, которое мы ищем. После своей работы функция возвращает `true`, если элемент найден и `false`, если он отсутствует.

# Поиск в отсортированном векторе, словаре и множестве

В этом уроке заполним таблицу полностью: разберём остальные методы поиска в отсортированном векторе, в словаре и множестве.

### Отсортированный вектор

Помимо функции `binary_search`, для поиска элементов в отсортированном векторе применяют функции `lower_bound`, `upper_bound` и `equal_range`.

-   [upper_bound](https://ru.cppreference.com/w/cpp/algorithm/upper_bound)

Эта функция вернёт итератор на элемент, больший искомого. Допустим, у нас есть отсортированный вектор:


```cpp

vector<int> v = {1, 1, 2, 3, 4, 4, 4, 5, 6};
auto it = upper_bound(v.begin(), v.end(), 4);
cout << "Номер позиции в векторе "s << distance(v.begin(), it) << endl;
cout << "Значение элемента "s << *it << endl; 

```

Будем искать первый элемент больше четвёрки. Здесь это пятёрка. Именно на позицию пятёрки будет указывать итератор, возвращённый функцией `upper_bound`:

1 1 2 3 4 4 4 **5** 6

Программа выведет:

Скопировать код

`Номер позиции в векторе 7
Значение элемента 5` 

-   [lower_bound](https://ru.cppreference.com/w/cpp/algorithm/lower_bound)

Эта функция вернёт итератор на элемент, больший или равный искомому. Возьмём тот же пример и будем искать первый элемент, больший или равный четвёрке:



```cpp
vector<int> v = {1, 1, 2, 3, 4, 4, 4, 5, 6};
auto it = lower_bound(v.begin(), v.end(), 4);
cout << "Номер позиции в векторе "s << distance(v.begin(), it) << endl;
cout << "Значение элемента "s << *it << endl; 

```

Получим итератор на позицию первой четвёрки в данном векторе:

1 1 2 3 **4** 4 4 5 6

Программа выведет:

Скопировать код

`Номер позиции в векторе 4
Значение элемента 4` 

-   [equal_range](https://ru.cppreference.com/w/cpp/algorithm/equal_range)

Эта функция вернёт пару итераторов. Первый из них — результат `lower_bound`, а второй — результат `upper_bound`. Казалось бы, зачем нам функция, которая дублирует работу двух других. На самом деле поиск двух результатов так реализуется эффективнее, чем если бы сначала была вызвана функция `lower_bound`, а потом `upper_bound`. Искать пару сразу проще, чем каждый элемент по отдельности. Такой приём вы уже видели на примере `minmax_element`.


```cpp

vector<int> v = {1, 1, 2, 3, 4, 4, 4, 5, 6};
auto [lower, upper] = equal_range(v.begin(), v.end(), 4);
cout << "Номер начальной позиции в векторе "s << distance(v.begin(), lower) << endl;
cout << "Номер конечной позиции в векторе "s << distance(v.begin(), upper) << endl; 

```

Пара итераторов в примере будет указывать на диапазон:

1 1 2 3 **4 4 4 5** 6

Концепция полуинтервала продолжает работать и здесь, поэтому внимательно посмотрим на пятёрку. Мы получили полуинтервал, в рамках которого все элементы равны данному. Результат `upper_bound` играет роль конца диапазона. То есть пятёрка в диапазон не входит, но станет его окончанием. Программа выведет:

Скопировать код

`Номер начальной позиции в векторе 4
Номер конечной позиции в векторе 7` 

Если бы в векторе не оказалось четвёрок, `lower_bound` и `upper_bound` вместе указывали бы на пятёрку. Это было бы то самое место, куда четвёрку можно вставить без нарушения сортировки.

Чтобы определить количество элементов, равных данному, достаточно расстояния между итераторами, которые вернула `equal_range`. А чтобы перебрать все нужные элементы, используют цикл от левой до правой границы найденного диапазона.



### Множества и словари

У множеств и словарей есть свои методы, одноимённые с функциями, которые мы уже разобрали. Эти методы работают эффективнее, чем функции, так как изначально знают, с каким контейнером имеют дело. Поиск организуется в соответствии с устройством конкретного контейнера. Но есть специфические моменты:

-   Проверить существование элемента во множестве или словаре можно, применив специальный метод `contains`. Правда, он появится только в следующем стандарте языка — в С++20. Поэтому в нынешнем стандарте используют метод `count`. Если элемент в контейнере есть, метод `count` вернёт 1, а если нет — 0.
-   Перебор всех подходящих элементов для множества и словаря не имеет значения, так как если элемент существует, он один — перебирать просто нечего.
-   То же можно сказать о подсчёте количества: результат всегда будет или 0, или 1.

Теперь сделаем финальную версию таблицы.
![[Pasted image 20211118162431.png]]![[Pasted image 20211118162443.png]]![[Pasted image 20211118162449.png]]