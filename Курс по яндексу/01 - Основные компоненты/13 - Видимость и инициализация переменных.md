# Области видимости переменных

Объекты в С++ имеют некоторую область видимости — часть программы, где к ним можно обратиться по имени. Переменные используются в области своей видимости.

Возьмём функцию `ReadLine` из кода поисковой системы. Переменная `s` объявлена в начале функции, поэтому может применяться во всей функции:

Скопировать кодCPP

`string ReadLine() {
    string s;
    getline(cin, s);
    return s;
}` 

Поменяем местами первые две строки:

Скопировать кодCPP

`string ReadLine() {
    getline(cin, s);
    string s;
    return s;
}` 

Эту функцию можем даже не вызывать — компилятор категорически откажется с этим работать:

Скопировать код

`test.cpp: In function ‘std::string ReadLine()’:
test.cpp:7:18: error: ‘s’ was not declared in this scope
    7 |     getline(cin, s);` 

Фраза `‘s’ was not declared in this scope` значит буквально «имя `s` в месте вызова `getline` не объявлено». `Scope` — это и есть та самая область видимости.

Общее правило видимости таково: переменная видна, начиная от своего объявления и заканчивая ближайшей закрывающей операторной скобкой. Эти скобки применяют и независимо — как раз чтобы ограничить область видимости.

В этом фрагменте реализации метода `FindAllDocuments` переменная `inverse_document_freq` не может быть использована в первом условном операторе, а также после цикла:

Скопировать кодCPP

`for (const string& word : query.plus_words) {
    // тут пока не видно
    if (word_to_document_freqs_.count(word) == 0) {
        continue;
    }
    // и тут всё ещё нет
    const double inverse_document_freq = ComputeWordInverseDocumentFreq(word);
    // а тут уже видно
    for (const auto [document_id, term_freq] : word_to_document_freqs_.at(word)) {
        const auto& document_data = documents_.at(document_id);
        if (document_predicate(document_id, document_data.status, document_data.rating)) {
            document_to_relevance[document_id] += term_freq * inverse_document_freq;
        }
    }
} 
// и снова не видно!` 

Переменная `word` объявлена в заголовке цикла — и потому видна во всём цикле, но не снаружи. Аналогично область видимости параметров функции — это всё тело функции.

Компилятор не запретит нам объявить переменную с уже существующим именем во вложенной области видимости:

Скопировать кодCPP

`int ComputeAverageRating(const vector<int>& rating) {
    if (rating.empty()) {
        return 0;
    }
    int rating_sum = 0;
    for (const int rating : rating) {  // ого!
        rating_sum += rating;
    }
    return rating_sum / static_cast<int>(rating.size());
}` 

Этот код будет отлично работать. Но горе тому программисту, который попробует разобраться, что такое `rating` внутри цикла. Особенно если размер цикла превысил десяток-другой строк.

Начинающие программисты часто не думают об областях видимости и объявляют все необходимые переменные как можно раньше. А зря: это может привести к ошибкам.

Рассмотрим код, который по вектору слов `words` строит вектор `pure_words`. Слова в этом векторе очищены от спецсимволов, таких как дефис, плюс и восклицательный знак:

Скопировать кодCPP

`#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main() {
    const vector<string> words = {"!кот"s, "-пушистый"s};
    vector<string> pure_words;

    string pure_word;
    for (const string& word : words) {
        for (const char c : word) {
            if (c != '-' && c != '+' && c != '!') {  // если c не спецсимвол
                pure_word.push_back(c);
            }
        }
        pure_words.push_back(pure_word);
    }

    for (const string& word : pure_words) {
        cout << word << endl;
    }
}` 

На выходе будет не то, что ожидалось:

Скопировать код

`кот
котпушистый` 

Это частая ошибка излишне экономных программистов: автор не хотел создавать новую строчку `pure_word` на каждой итерации цикла, но, похоже, забыл её очистить после `push_back`. Если эту переменную сразу объявить максимально глубоко, проблемы не будет:

Скопировать кодCPP

`for (const string& word : words) {
    string pure_word;  // новая переменная для каждой итерации
    for (const char c : word) {
        if (c != '-' && c != '+' && c != '!') {  // если c не спецсимвол
            pure_word.push_back(c);
        }
    }
    pure_words.push_back(pure_word);
}` 

Код работает, но его всё ещё можно улучшить. Над словом `word` совершается конкретное действие — очистка от спецсимволов. Вынесем его в функцию:

Скопировать кодCPP

`string PurifyWord(const string& word) {
    string pure_word;
    for (const char c : word) {
        if (c != '-' && c != '+' && c != '!') {  
            pure_word.push_back(c);
        }
    }
    return pure_word;
}

// ...

for (const string& word : words) {
    const string pure_word = PurifyWord(word);
    pure_words.push_back(pure_word);
}` 

Мы объявили переменную `pure_word` константной и тем самым явно отметили: `word` преобразуется в `pure_word` функцией `PurifyWord`. Больше с этой переменной ничего не происходит.

Без отдельной переменной программа тоже будет работать:

Скопировать кодCPP

`for (const string& word : words) {
    pure_words.push_back(PurifyWord(word));
}` 

Этот код не только короче, но и эффективнее. Мы не только грамотно выбрали область видимости для переменной `pure_word`, но и разделили две разные области:

-   удаление спецсимволов переносом в функцию,
-   добавление результата в вектор.

Всё это сделало код более понятным и легко тестируемым.

# Инициализация переменных

Вы уже сталкивались с опасностью неинициализированных числовых переменных. Разберём на примере. Объявим переменную `x`, прибавим к ней восемь и выведем:

Скопировать кодCPP

`#include <iostream>

using namespace std;

int main() {
    // другие операции
    int x;  // не задали начальное значение
    x += 8;
    cout << x << endl;
}` 

Если это первые команды в программе, она, скорее всего, выведет `8`. Если нет, можем получить произвольное число — например `21889`. При этом компилятор видит проблему и даёт предупреждение:

Скопировать код

`test.cpp: In function ‘int main()’:
test.cpp:14:7: warning: ‘x’ is used uninitialized in this function [-Wuninitialized]
   14 |     x += 8;
      |     ~~^~~~` 

Это наглядная демонстрация одного из базовых принципов C++: не плати за то, что не используешь. Переменная не инициализирована. Автор кода написал: хочу переменную. Переменная появилась, а тратить лишнюю операцию на её зануление нет причин. В мультфильме «Вовка в Тридевятом царстве» двое из ларца получили от Вовки размытые инструкции. И сделали совсем не то, чего он ожидал. С++ тоже требует чётких инструкций: хотите нулевой `x` — так и напишите.

Инициализируйте все переменные, которые так или иначе относятся к числовым:

-   целочисленные — `int`, `size_t`, `int64_t` и пр.;
-   вещественные — `float`, `double` и пр.;
-   `char`;
-   `bool`;
-   `enum`.

Создание таких локальных переменных — просто резервирование области памяти нужного размера. С точки зрения времени выполнения программы это бесплатно. С более сложными объектами — строками, векторами, словарями — дела обстоят иначе. Создавая их без дополнительной информации, вы гарантированно получите пустой объект.

Та же история с вашими собственными структурами и классами: по умолчанию их поля инициализируются подобно локальным переменным. Как правильно задавать начальные значения полей, вы узнаете в теме о конструкторах.

При этом стандартные классы заботятся о пользователе: созданная по умолчанию пара чисел `pair<int, int> x;` или вектор, длина которого равна пяти — `vector<int> v(5);`, — будут содержать нули.

Редкий пример ситуации, когда явная инициализация переменной избыточна:

Скопировать кодCPP

`int document_count;
cin >> document_count;` 

Переменная заполнилась конкретным значением сразу после объявления. Но в таком случае мы не можем объявить переменную константной. Отчасти поэтому, а отчасти из-за более сложного считывания в коде поисковой системы мы инициализировали количество документов по-другому:

Скопировать кодCPP

`const int document_count = ReadLineWithNumber();` 

Применим похожий приём, чтобы заполнить переменную разными значениями в зависимости от условия:

Скопировать кодCPP

`int result_temperature;
if (mode == Mode::MIN) {
    result_temperature = min(temperature_today, temperature_yesterday);
} else {
    result_temperature = max(temperature_today, temperature_yesterday);
}` 

Такой код опасен: если добавить команды перед `if` или заменить последний `else` на `else if` и добавить в `Mode` третье значение, в переменной `result_temperature` может появиться мусор. Исправить получится даже без функции. Применим так называемый тернарный оператор:

Скопировать кодCPP

`const int result_temperature =
    mode == Mode::MIN
    ? min(temperature_today, temperature_yesterday)
    : max(temperature_today, temperature_yesterday);` 

Выражение после символа `=` состоит из трёх частей:

-   до `?` записано условие, как в `if`;
-   между `?` и `:` записано значение, которое будет результатом выражения, если условие истинно;
-   после `:` записано значение, которое будет результатом выражения, если условие ложно.

Возьмите себе за правило всегда инициализировать переменные и поля числовых типов. И не забывайте включать предупреждения компилятора.