# Зачем нужна профилировка

Как вы знаете, одно из самых важных преимуществ C++ перед другими современными языками программирования — скорость. Синтаксис вряд ли можно объективно назвать сильной стороной: кому-то он нравится, кому-то нет. А вот программы на С++ выполняются быстрее всего. Тут ему на самом деле нет равных. Однако если писать синтаксически правильный, но плохой код, никакие преимущества C++ не сделают программу быстрой. В этом уроке вы узнаете, как отслеживать проблемы в коде в реальном времени.

### Профилировка

Рассмотрим такой код:


```cpp

// заголовок cstdlib понадобится для функции rand,
// выдающей случайные числа
#include <cstdlib>
#include <iostream>
#include <vector>

using namespace std;

vector<int> ReverseVector(const vector<int>& source_vector) {
    vector<int> res;
    for (int i : source_vector) {
        res.insert(res.begin(), i);
    }

    return res;
}

int CountPops(const vector<int>& source_vector, int begin, int end) {
    int res = 0;

    for (int i = begin; i < end; ++i) {
        if (source_vector[i]) {
            ++res;
        }
    }

    return res;
}

void FillRandom(vector<int>& v, int n) {
    for (int i = 0; i < n; ++i) {
        // получаем случайное число с помощью функции rand.
        // с помощью (rand() % 2) получим целое число в диапазоне 0..1.
        // в C++ имеются более современные генераторы случайных чисел,
        // но в данном уроке не будем их касаться
        v.push_back(rand() % 2);
    }
}

int main() {
    vector<int> random_bits;

    // операция << для целых чисел это сдвиг всех бит в двоичной
    // записи числа. Запишем с её помощью число 2 в степени 17 (131072)
    static const int N = 1 << 17;

    // заполним вектор случайными числами 0 и 1
    FillRandom(random_bits, N);

    // перевернём вектор задом наперёд
    vector<int> reversed_bits = ReverseVector(random_bits);

    // посчитаем процент единиц на начальных отрезках вектора
    for (int i = 1, step = 1; i <= N; i += step, step *= 2) {
        // чтобы вычислить проценты мы умножаем на литерал 100. типа double;
        // целочисленное значение функции CountPops при этом автоматически
        // преобразуется к double, как и i
        double rate = CountPops(reversed_bits, 0, i) * 100. / i;
        cout << "After "s << i << " bits we found "s << rate << "% pops"s
             << endl;
    }
} 

```

Эта программа иллюстрирует важное следствие математического закона больших чисел: чем больше случайных чисел ноль и один есть в наборе, тем меньше вероятность, что процент единиц будет сильно отклоняться от 50%. Обращение вектора добавлено только для иллюстрации.

Запустим код и посмотрим, сколько времени займёт выполнение. Скорость зависит в том числе от оборудования. Но этот код в любом случае выполнится не моментально. Разберёмся, где узкое место и в чём проблема.

Для этого проводят операцию профилирования — выборочное измерение времени выполнения участков кода. Есть несколько готовых профилировщиков — отдельных инструментов, показывающих, сколько времени работала функция. Они подключаются к вашей программе и очень часто — например, раз в миллисекунду — просматривают стек вызовов, проверяя, где выполнение происходит в данный момент. Анализируя данные профилировщика, вы легко найдёте узкие места — медленные функции, в которых программа проводит больше всего времени.

Некоторые известные профилировщики:

-   Intel®VTune™Profiler (Windows, Linux). Сложный коммерческий продукт в составе большого пакета инструментов Intel, предназначенных для анализа производительности. Имеет графический интерфейс для просмотра и составления различных отчётов о работе кода.
-   Microsoft Visual Studio (Windows). Начиная с версии 2017, в Microsoft Visual Studio входит собственный несложный профилировщик. Как и профилировщик Intel, он имеет интуитивный графический интерфейс.
-   Консольные инструменты (Linux). В ряде UNIX-подобных операционных систем есть инструменты strace, ltrace и gprof. Первые два служат для профилировки системных и библиотечных вызовов. strace, ltrace можно использовать с любой программой, они даже не требуют наличия в ней отладочной информации. gprof — это полноценный профилировщик, который может анализировать вашу программу. Он выдаёт результат в виде текстового файла.

На практике прибегать к сложным инструментам профилировки нужно не всегда. Поэтому вы напишете свой простой профилировщик. Он будет не сторонним инструментом, а встроится прямо в ваш код. Иногда такой профилировщик эффективнее, ведь он измеряет не всё, а только то, что вам нужно.

Когда в программе всего три операции, можно действовать так и не профилировать. Хотя, вероятно, вы уже столкнулись с проблемами: удаление оборачивания влияет на следующий код. В реальных программах «подозреваемых» куда больше, и наивными методами не обойтись — искать узкое место в большом коде трудно. Даже в нашей маленькой программе пока непонятно, какой вклад в общее время вносит каждая из операций. Это вы узнаете в следующих уроках и научитесь программы ускорять.

### Оптимизатор

Когда компилятор завершает работу, в дело вступает встроенный оптимизатор. Он сделает всё, чтобы автоматически ускорить программу, не испортив её. Оптимизатор может многое — удалять код, разворачивать функции, подставляя код функции на место, где она вызывается, менять местами операции, удалять избыточные копирования. Шагая отладчиком по коду программы, вы могли заметить, что выполнение проходит не совсем так, как задумано. Это потому что поработал оптимизатор.

Вы можете влиять на оптимизатор, настраивая параметры компиляции. Вариантов два:

-   совсем отключить его. Так обычно делают для Debug-версий, поскольку оптимизатор может сильно усложнять отладку;
-   выбрать максимальную оптимизацию в Release-сборке.

Оптимизатор C++ — сложная вещь, и в некоторых случаях его поведение совсем не очевидно. Но даже самый изощрённый оптимизатор не сделает из плохого и медленного кода быстрый и эффективный. Возможности оптимизатора широки, но не безграничны.

Оптимизация перепутает функции вашей программы, как спагетти. Некоторые функции она и вовсе удалит, встроив их код в другие. Это в свою очередь влияет на наглядность результатов профилировщика. В вашем профилировщике не будет такого недостатка. Но чтобы создать профилировщик, нужно овладеть временем, а вернее, механизмами его измерения в C++. Их вы изучите в следующем уроке.

Расположите стадии сборки программы в правильном порядке:


# Измеряем время

Главная задача профилировщика — измерять время выполнения определённых операций. Алгоритм измерения прост:

-   запомнить начальный момент (до операции),
-   запомнить конечный момент (после операции),
-   вычесть из значения времени в конечный момент значение времени в начальный,
-   получится продолжительность операции.

В C++ для этого есть замечательная, но довольно сложная библиотека `<chrono>`. С частью её функционала познакомимся, создавая собственный профилировщик.

Посмотрим, как работает `<chrono>`. Измерим время пятисекундного ожидания. Чтобы заставить программу подождать, используют функцию `this_thread::sleep_for` из библиотеки `<thread>`. Эту библиотеку вы изучите позже. Сейчас из неё понадобится только функция ожидания, останавливающая программу на заданное время:


```cpp

#include <chrono>
#include <iostream>
#include <thread>

using namespace std;

int main() {
    cout << "Ожидание 5s..."s << endl;
    const chrono::steady_clock::time_point start_time = chrono::steady_clock::now();

    // операция - ожидание 5 секунд
    this_thread::sleep_for(chrono::seconds(5));
    const chrono::steady_clock::time_point end_time = chrono::steady_clock::now();

    const chrono::steady_clock::duration dur = end_time - start_time;
    cout << "Ожидание завершено"s << endl;
} 

```

В выводе программы пока нет ничего содержательного:


```
Ожидание 5s...
Ожидание завершено 
```
Чтобы узнать время, в C++, как и в обычной жизни, нужно обратиться к часам. В `<chrono>` есть разные виды часов, предназначенные для определённых целей. В нашем случае идеально подходят часы `chrono::steady_clock`. Часы дают момент времени. А разность моментов времени — это продолжительность. `time_point` и `duration` — типы данных, поэтому вы не сможете случайно сложить два момента времени вместо вычитания или использовать момент времени там, где нужна продолжительность. Здесь мы указали типы полностью, а в дальнейшем для краткости будем писать `auto`.

Приведём продолжительность в понятный вид — например, в миллисекунды. Для этого применим функцию `chrono::duration_cast`. Мы пишем профилировщик — служебную часть программы, напрямую не связанную с её работой, поэтому результат будем выводить не в `cout`, а в `cerr`. Этот поток вывода при желании можно отделить от `cout`, перенаправив его в отдельный лог-файл с отладочной информацией:


```cpp

#include <chrono>
#include <iostream>
#include <thread>

using namespace std;
using namespace chrono;

int main() {
    cout << "Ожидание 5s..."s << endl;
    const auto start_time = steady_clock::now();

    // операция - ожидание 5 секунд
    this_thread::sleep_for(seconds(5));
    const auto end_time = steady_clock::now();

    const auto dur = end_time - start_time;
    cerr << "Продолжительность сна: "s << duration_cast<milliseconds>(dur).count() << " ms"s << endl;

    cout << "Ожидание завершено"s << endl;
} 

```

Вот какой результат может получиться:


```
`Ожидание 5s...
Продолжительность сна: 5002 ms
Ожидание завершено` 
```
Библиотеку `<chrono>` применяют не только для замера времени. Так, в нашем коде мы использовали её и для ожидания. Этот код можно упростить, если подключить пространство имён `std::literals`:



```cpp
#include <chrono>
#include <iostream>
#include <thread>

using namespace std;
using namespace chrono;
// хотите немного магии? тогда используйте namespace literals
using namespace literals;

int main() {
    cout << "Ожидание 5s..."s << endl;
    const auto start_time = steady_clock::now();

    // операция - ожидание 5 секунд
    this_thread::sleep_for(5s);
    const auto end_time = steady_clock::now();

    const auto dur = end_time - start_time;
    cerr << "Продолжительность сна: "s << chrono::duration_cast<chrono::milliseconds>(dur).count() << " ms"s << endl;

    cout << "Ожидание завершено"s << endl;
} 

```

Мы написали просто 5s, и компилятор понял, что мы имели в виду пять секунд! `std::literals` позволяет использовать различные единицы измерения времени от наносекунд (ns) до часов (h). Причём единицы необязательно должны быть целыми: иногда нужно подождать полсекунды.

Вам могло показаться странным, что к типу продолжительности обращаемся через часы:


```cpp

chrono::steady_clock::duration 

```

Кажется, будто у каждых часов своя продолжительность. Но `5s` — тоже продолжительность, и ни на какие часы она не завязана. На самом деле есть универсальная продолжительность: `chrono::duration`. Это шаблонный класс, и его шаблонные параметры определяют две вещи:

1.  числовой тип, который будет представлять количество тиков,
2.  размер одного тика в виде дробного количества секунд.

`chrono::steady_clock::duration` — это также `chrono::duration`, но с уже подобранными специально для `steady_clock` шаблонными параметрами.

Числовой тип продолжительности может быть не только целым, таким как `int` и `int64_t`, но также и вещественным `float` или `double`. Каждые часы сами определяют тип и длительность тика, которые для них подходят, и могут представить все возможные варианты.

# Упрощаем логирование

Выполняя задание в прошлом уроке, вы заметили, что это довольно утомительная работа. А главное — легко можно ошибиться и перепутать многочисленные переменные типа `time_point`. К счастью, в C++ есть замечательный механизм, который позволяет выполнять парные действия удобно и без риска ошибок.

Как вы думаете, какой механизм упростит измерение времени?

Конструктор и деструктор класса как раз подходят для того, чтобы выполнять парные действия.

Подойдёт обычный `for`, который сделает две итерации: на первой измерит время начала, на второй — время конца.

Тут не обойтись без исключений.

Можем использовать классы. Сейчас увидите, что конструктор и деструктор отлично решают задачу.

Создадим класс `LogDuration`, объект которого при создании и уничтожении будет запоминать время. При уничтожении он выведет продолжительность операции в `cerr`:


```cpp

class LogDuration {
public:
    LogDuration() {
    }

    ~LogDuration() {
        const auto end_time = steady_clock::now();
        const auto dur = end_time - start_time_;
        cerr << duration_cast<milliseconds>(dur).count() << " ms"s << endl;
    }

private:
    const steady_clock::time_point start_time_ = steady_clock::now();
}; 
```


`LogDuration` упростит профилировку. Надо просто создать переменную типа `LogDuration` с любым названием, и она автоматически измерит время до выхода из области видимости. Рассмотрим работу класса `LogDuration` на примере:



```cpp
#include <chrono>
#include <iostream>
#include <thread>

using namespace std;
using namespace chrono;
using namespace literals;

class LogDuration {
public:
    LogDuration() {
    }

    ~LogDuration() {
        const auto end_time = steady_clock::now();
        const auto dur = end_time - start_time_;
        cerr << duration_cast<milliseconds>(dur).count() << " ms"s << endl;
    }

private:
    const steady_clock::time_point start_time_ = steady_clock::now();
};

int main() {
    cout << "Ожидание 5s..."s << endl;

    {
        LogDuration sleep_guard;
        // операция - ожидание 5 секунд
        this_thread::sleep_for(5s);
    }

    cout << "Ожидание завершено"s << endl;
}
```
# Призываем макросы

В прошлом уроке вы упростили профилировку. Технология, которую вы использовали, называется RAII. Она применяется не только для контроля за ресурсами, но и для планирования действия, которое должно совершиться при выходе из области видимости. Эту технологию вы подробно изучите далее в курсе.

Название переменной, которая позволила создать объект `LogDuration`, не несёт в себе никакой информации. Более того, мы даже к этой переменной не обращаемся. Чтобы скрыть ненужную информацию, используем препроцессор. С ним вы уже сталкивались во втором спринте. Определим такой макрос:


```cpp

#define LOG_DURATION(x) LogDuration UNIQUE_VAR_NAME_PROFILE(x) 

```

Далее нужно разработать такой макрос `UNIQUE_VAR_NAME_PROFILE`, который будет выдавать уникальное имя переменной. Для профилировщика это не так важно — вряд ли у нас будут две профилировки в одном пространстве имён. Но всё-таки это удобно.

Можем использовать макрос `__LINE__`. Препроцессор заменяет его на номер строки, в которой использован этот макрос. Нам также понадобится оператор слияния лексем `##`:


```cpp

#define UNIQUE_VAR_NAME_PROFILE profile_guard_ ## __LINE__

int main() {
    int UNIQUE_VAR_NAME_PROFILE;
} 

```

Забавно, в этой программе нет `#include`, при этом она совершенно корректна, хотя ничего не делает — даже единственную переменную исключит оптимизатор. Посмотрим, что на выходе у препроцессора:


```cpp

#line 1 "main.cpp"

int main() {
    int profile_guard___LINE__;
} 

```

Этот файл мы получили, применив специальный режим компилятора. В таком режиме он запускает только препроцессор. Для компилятора GCC этот режим можно запустить из командной строки, указав специальный флаг: `gcc -E in.cpp -o in.i`.

Ожидали мы не этого. Очевидно, препроцессор «приклеил» `__LINE__` слишком рано, до того, как подставил номер строки. Схитрим и добавим ещё одно макроопределение:


```cpp

#define PROFILE_CONCAT(X, Y) X ## Y
#define UNIQUE_VAR_NAME_PROFILE PROFILE_CONCAT(profile_guard_, __LINE__)

int main() {
    int UNIQUE_VAR_NAME_PROFILE;
} 

```

Код стал на одну строчку больше. Проверим результат:


```cpp

#line 1 "main.cpp"

int main() {
    int profile_guard___LINE__;
} 

```

Результат не изменился. Почти смирившись, что ничего не выйдет, сделаем последнюю попытку. Добавим ещё один макрос:


```cpp

#define PROFILE_CONCAT_INTERNAL(X, Y) X ## Y
#define PROFILE_CONCAT(X, Y) PROFILE_CONCAT_INTERNAL(X, Y)
#define UNIQUE_VAR_NAME_PROFILE PROFILE_CONCAT(profile_guard_, __LINE__)

int main() {
    int UNIQUE_VAR_NAME_PROFILE;
} 

```

Посмотрим, что выдал препроцессор:



```cpp
#line 1 "main.cpp"

int main() {
    int profile_guard_6;
} 
```


Ничего себе, получилось! Такого трюка для определения `UNIQUE_VAR_NAME_PROFILE` — макроса, генерирующего уникальное имя переменной, — требуют довольно запутанные правила раскрытия макросов. Окончательный вид будет таким:


```cpp

#define PROFILE_CONCAT_INTERNAL(X, Y) X ## Y
#define PROFILE_CONCAT(X, Y) PROFILE_CONCAT_INTERNAL(X, Y)
#define UNIQUE_VAR_NAME_PROFILE PROFILE_CONCAT(profileGuard, __LINE__)
#define LOG_DURATION(x) LogDuration UNIQUE_VAR_NAME_PROFILE(x)
```
# Измеряем и ускоряем

Вы потратили много усилий на макросы и теперь ваш профилировщик готов. Посмотрим, на что он способен.

Возможно, вы догадались, почему в примере из прошлого урока так много времени занимает оборачивание вектора. А если не догадались — нестрашно, сейчас разберёмся. Дело в том, что когда вектор достаточно велик, вставка элементов в начало и середину — долгая операция: нужно подвинуть много элементов вправо, чтобы освободить ячейку. А мы делаем эту операцию много раз. Куда быстрее вставлять в конец — вспомните пример с чемоданом из начала курса:

![image](https://pictures.s3.yandex.net/resources/S3_2_1_1603450600.png)_Чтобы положить что-то вниз чемодана, как и в начало вектора, нужно переместить всё содержимое_

Возьмём код из предыдущего урока. Изменим программу так, чтобы вставка производилась в конец. Раньше мы читали с начала и вставляли в начало. А теперь будем читать с конца и вставлять в конец. Вроде бы ничего не изменилось, но теория подсказывает, что вставка в конец эффективнее.

Чтобы изменить направление прохода по вектору, используем обратные итераторы `rbegin` и `rend`. Они работают так же, как `begin` и `end`, но проходят контейнер в обратном направлении:


```cpp

vector<int> ReverseVector2(const vector<int>& source_vector) {
    vector<int> res;

    // будем проходить source_vector задом наперёд
    // с помощью обратного итератора
    for (auto iterator = source_vector.rbegin(); iterator != source_vector.rend(); ++iterator) {
        res.push_back(*iterator);
    }

    return res;
} 
```


Не забываем поменять в `main` `ReverseVector` на `ReverseVector2` и измеряем время.

![[Pasted image 20211129173639.png]]

Круто, производительность всей программы возросла более чем в 50 раз! Попробуем ускорить ещё. Но чтобы разница была заметной, увеличим размер вектора в 256 раз: с 2¹⁷ до 2²⁵ или 33554432:

```cpp


static const int N = 1 << 25; 

```

Теперь измерения выглядят так:

![[Pasted image 20211129173626.png]]

Начинаем ускорять с “Fill random” — самой медленной части, потому что она вносит основной вклад в скорость программы. Ведь даже если мы очень постараемся и ускорим Counting в 100 раз, производительность всей программы улучшится только на 4%, а если в 100 раз ускорить Fill random, то на 67%. Разница очевидна.

При случайном заполнении вектора требуется только один бит информации, а `rand()` выдаёт как минимум 15 случайных бит. Сколько точно — зависит от операционной системы и компилятора. Используем все 15, которые нам гарантированы:


```cpp

// <algorithm> нужен для функции min
#include <algorithm>
... 
void FillRandom2(vector<int>& v, int n) {
    for (int i = 0; i < n; i += 15) {
        int number = rand();

        // мы можем заполнить 15 элементов вектора,
        // но не более, чем нам осталось до конца:
        int count = min(15, n - i);

        for (int j = 0; j < count; ++j)
            // таким образом, получим j-й бит числа.
            // операцию побитового сдвига вы уже видели в этой программе
            // на этот раз двигаем вправо, чтобы нужный бит оказался самым последним
            v.push_back((number >> j) % 2);
    }
}
... 
```


![[Pasted image 20211129173604.png]]

Ускорение уже скромнее. Однако это лучше, чем ничего. Мы договорились ускорять самую медленную часть программы, но идей, как оптимизировать “Fill random” пока нет. Поэтому улучшим функцию оборачивания, вторую по скорости. Вставлять элемент в конец вектора эффективнее, чем в начало, но можно ещё ускорить процесс. Для этого зарезервируем место — применим метод `reserve`, указав количество элементов, которые будут в векторе в итоге:


```cpp

vector<int> ReverseVector3(const vector<int>& source_vector) {
    vector<int> res;
    res.reserve(source_vector.size());

    // будем проходить sourceVector задом наперёд
    // с помощью обратного итератора
    for (auto iterator = source_vector.rbegin(); iterator != source_vector.rend(); ++iterator) {
        res.push_back(*iterator);
    }

    return res;
} 
```


![[Pasted image 20211129173544.png]]

Отлично! Не так хорошо, как при первой оптимизации, но всё-таки ускорение почти в три раза — это очень неплохо.


# Проверяем, всё ли ускорили

В прошлом уроке мы проделали неплохую работу: улучшили скорость работы вначале в 50 раз, а затем ещё минимум в два раза. Казалось бы, методы ускорения исчерпаны. Однако последнюю операцию — подсчёт количества единиц — мы пока не трогали. Хоть она занимает всего около 10% времени программы, поработаем над ней тоже, просто чтобы ей не было обидно.

Вспомним, что у нас есть к этому моменту:



```cpp
#include <algorithm>
#include <chrono>
#include <cstdlib>
#include <iostream>
#include <vector>

#include "log_duration.h"

using namespace std;

vector<int> ReverseVector3(const vector<int>& source_vector) {
    return {source_vector.rbegin(), source_vector.rend()};
}

int CountPops(const vector<int>& source_vector, int begin, int end) {
    int res = 0;

    for (int i = begin; i < end; ++i) {
        if (source_vector[i]) {
            ++res;
        }
    }

    return res;
}

void FillRandom2(vector<int>& v, int n) {
    for (int i = 0; i < n; i += 15) {
        int number = rand();

        // мы можем заполнить 15 элементов вектора,
        // но не более, чем нам осталось до конца:
        int count = min(15, n - i);

        for (int j = 0; j < count; ++j)
            // операцию побитового сдвига вы уже видели в этой программе
            // на этот раз двигаем вправо, чтобы нужный бит оказался самым последним
            v.push_back((number >> j) % 2);
    }
}

void Operate() {
    LOG_DURATION("Total"s);

    vector<int> random_bits;

    // операции << для целых чисел это сдвиг всех бит в двоичной
    // записи числа. Запишем с её помощью число 2 в степени 17 (131072)
    static const int N = 1 << 17;

    // заполним вектор случайными числами 0 и 1
    
    {
        LOG_DURATION("Fill random"s);
        FillRandom2(random_bits, N);
    }

    // перевернём вектор задом наперёд
    vector<int> reversed_bits;
    {
        LOG_DURATION("Reverse"s);

        reversed_bits = ReverseVector3(random_bits);
    }

    {
        LOG_DURATION("Counting"s);
        // посчитаем процент единиц на начальных отрезках вектора
        for (int i = 1, step = 1; i <= N; i += step, step *= 2) {
            double rate = CountPops(reversed_bits, 0, i) * 100. / i;
            cout << "After "s << i << " digits we found "s << rate << "% pops"s << endl;
        }
    }
} 
```


Каждый раз суммируем весь диапазон, а могли бы просто добавлять к уже посчитанной сумме новые слагаемые. Для этого нужно усложнить алгоритм:



```cpp
{
    LOG_DURATION("Counting"s);
    // посчитаем процент единиц на начальных отрезках вектора
    int prev_sum = 0;
    int prev_i = 0;
    for (int i = 1, step = 1; i <= n; i += step, step *= 2) {
        const int sum = prev_sum + CountPops(reversed_digits, prev_i, i);

        cout << "After "s << i << " digits we found "s << (sum * 100. / i) << "% pops"s << endl;

        prev_i = i;
        prev_sum = sum;
    }
} 
```


![[Pasted image 20211129175453.png]]

А вот тут нас постигла неудача: лишние вычисления мы вроде бы убрали, однако результат изменился незначительно. Дело в том, что это суммирование занимает малую часть всего времени. Узкое место алгоритма — вывод в поток, а не суммирование. Но даже если вывод в поток ускорить, это не даст заметного выигрыша во всей программе. Об оптимизации потоков поговорим в следующей теме.

# Два важных правила оптимизации

В предыдущем уроке нас постигла неудача: оптимизация не дала желаемого ускорения. Это показывает, что оптимизация — не всегда хорошо. Код стало сложнее писать и читать, а результат оказался нецелесообразным. Чтобы избегать подобных неприятностей, следуйте первому правилу оптимизации.

> Первое правило оптимизации: избегайте преждевременной оптимизации.

Главные достоинства вашей программы — это надёжность, понятность и скорость. Усложняя программу ради скорости, вы ухудшаете понятность, а скорее всего, и надёжность, потому что в сложных и непонятных программах гораздо проще допустить ошибку. Особенно обидно, если результат того не стоил.

Если оптимизация сработала, и вы путём большого труда ускорили функцию, занимавшую 10 миллисекунд, до одной миллисекунды — это хорошее достижение. Но если вся программа при этом работает 10 секунд, ускорение попросту не будет заметно. Понять, где именно нужна оптимизация, поможет профилировка. Это второе правило оптимизации.

> Второе правило оптимизации: измеряйте.

Только измерения помогут выявить узкие места программы — те, где ваша программа в действительности проводит больше всего времени. Их расположение часто противоречит интуиции.

Есть даже эмпирическое правило Парето, согласно которому

> 80% всего времени выполнения программы тратится на 20% кода.

В реальных программах это соотношение может быть иным и часто даже более разительным. Но в любом случае оно говорит, что во время разработки стоит думать не только об эффективности кода, но и о том, что ему может понадобиться оптимизация.


- Оптимизация — это изменение программы, улучшающее производительность, но не меняющее результат.
	- Действительно. Изменения, не меняющие результат, называются «рефакторинг». Его проводят для разных целей, не только ради эффективности. Основная цель рефакторинга — улучшить код.
- Оптимизация имеет смысл только для критичных мест программы. Чтобы выявить их, используется профилировка.
	- Да, профилировка поможет выявить распределение расходов времени и понять, в каком именно месте кода программа проводит больше всего времени.