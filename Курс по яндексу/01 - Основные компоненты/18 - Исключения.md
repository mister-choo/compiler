# Введение

До недавних пор мы обходили стороной тему обработки ошибок. Для простоты обучения всё происходило в идеальном мире, где на вход программе всегда поступают корректные данные, ресурсы у компьютера бесконечны, а операции ввода-вывода всегда завершаются успешно.

В реальном мире программы редко работают в тепличных условиях. Доступная память может закончиться, сетевое соединение оборваться, файл на диске оказаться повреждённым, а пользователь может ошибиться и вместо числа передать программе произвольную строку.

Программа, игнорирующая существование ошибок, едва ли проработает долго. Она быстро дойдёт до состояния, в котором её данные перестанут быть согласованными. Тогда программа либо зависнет, либо совершит неразрешённую операцию, после чего её работа будет прервана операционной системой. Пользователи такой программы тоже будут не в восторге. Особенно если потеряют результаты своей многочасовой работы или безопасность компьютера окажется под угрозой.

Хорошо написанные программы умеют обнаруживать проблемные ситуации, корректно их обрабатывать и продолжать работу. А если ошибка окажется серьёзной, такая программа корректно прервётся, по возможности сохранив пользовательские данные.

В этой теме вы познакомитесь с исключениями — механизмом языка C++, позволяющим сигнализировать о внештатных ситуациях в работе программы и обрабатывать их.

# Используем для обработки ошибок коды возврата

В этом уроке разберёмся, как обнаруживать внештатные ситуации в программе и реагировать на них, используя уже знакомые вам средства языка.

Рассмотрим программу, находящую корни квадратного уравнения:


```cpp

#include <cmath>
#include <iostream>
#include <utility>

using namespace std;

// Находим корни квадратного уравнения a*x^2 + b*x + c = 0
pair<double, double> SolveQuadraticEquation(double a, double b, double c) {
    // Находим дискриминант
    double discriminant = b * b - 4 * a * c;

    // Находим корни уравнения
    double x1 = (-b - sqrt(discriminant)) / (2 * a);
    double x2 = (-b + sqrt(discriminant)) / (2 * a);

    return {x1, x2};
}

int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;
    const pair<double, double> roots = SolveQuadraticEquation(a, b, c);

    cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
    cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
} 

```

Запустим код и проанализируем, что получится. Для некоторых входных данных программа выдаст понятные результаты:


```cpp

Введите коэффициенты уравнения a*x^2 + b*x + c = 0
1 0 -4
Корни уравнения 1*x^2 + 0*x + -4 = 0
  x1=-2; x2=2 

```

При других входных данных результаты будут странные:

```cpp


Введите коэффициенты уравнения a*x^2 + b*x + c = 0
1 0 4
Корни уравнения 1*x^2 + 0*x + 4 = 0
  x1=-nan; x2=-nan 

```

Дело в том, что во втором случае дискриминант квадратного уравнения оказался отрицательным, а функция `sqrt`, вычисляющая квадратный корень, для отрицательных чисел возвращает особое значение `nan` — «не число». Последующие операции с участием `nan` также возвращают «не число». Так или иначе, пользователю стоило бы выдать более осмысленный результат вроде сообщения «Уравнение не имеет действительных корней».

Есть несколько способов решить эту задачу.

**Способ 1 (плохой): нештатную ситуацию обнаруживает вызывающий код.** Проверку на отрицательность дискриминанта можно было бы разместить внутри функции `main` перед вызовом функции `SolveQuadraticEquation`:


```cpp

int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;
    if (b * b - 4 * a * c < 0) {
        cout << "Уравнение не имеет действительных корней"s << endl;
    } else {
        const pair<double, double> roots = SolveQuadraticEquation(a, b, c);

        cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
    }
} 

```

У этого способа несколько серьёзных недостатков. Функция пишется один раз, а применяется, как правило, многократно. Проверки в каждом месте использования `SolveQuadraticEquation` приводят к дублированию кода и ошибкам, особенно когда над проектом работает несколько человек. Другая проблема в том, что так мы выносим детали реализации функции за её пределы. Задача функции — упрощать использование фрагмента кода, а не усложнять его. Третья проблема — лишнее вычисление дискриминанта.

**Способ 2 (очень плохой): проверить корни на равенство** `nan`**, применив функцию `[isnan](https://en.cppreference.com/w/cpp/numeric/math/isnan)`.** Функция `isnan` проверяет, будет ли переданное ей значение `double` «‎не-числом», то есть особым значением, показывающим что результат нельзя выразить вещественным числом:


```cpp

int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;

    pair<double, double> roots = SolveQuadraticEquation(a, b, c);
    if (!isnan(roots.first) && !isnan(roots.second)) {
        cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
    } else {
        cout << "Уравнение не имеет действительных корней"s << endl;
    }
} 

```

Недостаток этого способа в том, что функция решения уравнения в случае отрицательного дискриминанта выполняет вычисления, не имеющие смысла. Здесь это приводит к появлению результата, равного `nan`. В более сложных ситуациях игнорирование ошибок может привести к краху программы или порче данных.

**Способ 3: нештатную ситуацию обнаруживает сама функция.** Проверка на отрицательный дискриминант размещается внутри функции, выполняющей вычисления. Это решение устраняет дублирование кода и сохраняет детали реализации внутри функции. Но возникает проблема: надо сообщить вызывающему коду об ошибке.

Изменим сигнатуру функции так, чтобы она принимала по ссылке дополнительный параметр `success` типа `bool`:


```cpp

pair<double, double> SolveQuadraticEquation(double a, double b, double c, bool& success) {
    double discriminant = b * b - 4 * a * c;
    if (discriminant < 0) {
        success = false;
        // Функция должна вернуть пару значений. Пусть это будут нули
        return {0, 0};
    }
    success = true;

    double x1 = (-b - sqrt(discriminant)) / (2 * a);
    double x2 = (-b + sqrt(discriminant)) / (2 * a);
    return {x1, x2};
} 

```

В точке использования нужно завести переменную, передать её в функцию, а потом проверить значение:


```cpp

int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;

    bool success = false;
    const pair<double, double> roots = SolveQuadraticEquation(a, b, c, success);

    if (success) {
        cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
    } else {
        cout << "Уравнение не имеет действительных корней"s << endl;
    }
} 

```

Но и у третьего способа есть недостатки:

-   функция стала принимать на один параметр больше;
-   в случае ошибки функция возвращает результат `{0,0}`. Этот результат — не решение уравнения. Правильная его интерпретация отдаётся на откуп вызывающему коду, который должен предварительно проверить значение выходного параметра `success`.

Нужен другой способ. Снова изменим сигнатуру функции, чтобы она возвращала значение типа `bool`, сигнализирующее об успехе, а корни уравнения записывала в параметр, принимаемый по ссылке:


```cpp

bool SolveQuadraticEquation(double a, double b, double c, pair<double, double>& roots) {
    double d = b * b - 4 * a * c;
    if (d < 0) {
        return false;
    }

    double x1 = (-b - sqrt(d)) / (2 * a);
    double x2 = (-b + sqrt(d)) / (2 * a);
    roots = {x1, x2};
    return true;
} 

```

В месте использования нужно заранее объявить переменную для сохранения результата и проверить возвращаемое значение функции в условном операторе:


```cpp

int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;

    pair<double, double> roots;
    if (SolveQuadraticEquation(a, b, c, roots)) {
        cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
    } else {
        cout << "Уравнение не имеет действительных корней"s << endl;
    }
} 

```

Нельзя сказать, что такой способ намного лучше третьего. Хотя функция не пытается вернуть суррогатное значение, проверка возвращаемого значения возлагается на вызывающий код. А об этом легко забыть:


```cpp

pair<double, double> roots;
// Здесь программист забыл проверить результат вызова функции
SolveQuadraticEquation(a, b, c, roots);
cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
cout << "  x1="s << roots.first << "; x2="s << roots.second << endl; 

```

Проблемы с проверкой возвращаемого значения можно частично решить, если пометить функцию `SolveQuadraticEquation` специальным атрибутом `[[nodiscard]]`. Так компилятор будет предупреждать, что возвращаемое значение функции не используется:


```cpp

[[nodiscard]] bool SolveQuadraticEquation(double a, double b, double c, 
                                          pair<double, double>& roots) {
    double d = b * b - 4 * a * c;
    if (d < 0) {
        return false;
    }

    double x1 = (-b - sqrt(d)) / (2 * a);
    double x2 = (-b + sqrt(d)) / (2 * a);
    roots = {x1, x2};
    return true;
} 

```

При попытке скомпилировать код увидим предупреждение:


```cpp

warning: ignoring return value of function declared with 'nodiscard' attribute [-Wunused-result]
    SolveQuadraticEquation(a, b, c, roots);
    ^~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~ 

```

Казалось бы, победа! Но этот способ не панацея. В более сложной ситуации предупреждение о неиспользуемом результате выдаваться не будет:



```cpp
bool success;
/*...*/
pair<double, double> roots1, roots2;
success = SolveQuadraticEquation(a1, b1, c1, roots1);

// Информация об ошибке вычисления предыдущего уравнения оказалась утеряна
success = SolveQuadraticEquation(a2, b2, c2, roots2);
if (success) {
    /* обрабатываем roots1 и roots2 */
} 

```

Когда пишете надёжные программы, выдающие предсказуемые результаты, позаботьтесь об обработке нештатных ситуаций. Для этих целей подойдут коды возврата и атрибут `[[nodiscard]]`. Он предупреждает вас о неиспользуемом результате вызова функции или метода.

## Задание

Сделайте поисковую систему надёжнее, добавив в методы `AddDocument`, `MatchDocument` и `FindTopDocuments` обработку следующих ошибок:

-   Указание в поисковом запросе более чем одного минуса перед словами, которых не должно быть в документах, например: `кот --пушистый`. В середине слов минусы разрешаются, например: `иван-чай`.
-   Отсутствие в поисковом запросе текста после символа «минус», например `кот -`.
-   Наличие спецсимволов — то есть символов с кодами в диапазоне от 0 до 31 включительно — в тексте документов и поискового запроса.
-   Попытка добавить документ с отрицательным id.
-   Попытка добавить документ с id, совпадающим с id документа, который добавился ранее.

Обновите сигнатуру методов `MatchDocument` и `FindTopDocuments`, чтобы они сообщали об успехе выполнения возвратом значения типа `bool`, а результаты поиска и сопоставления документов возвращали через выходной параметр `result`, принимаемый по ссылке. В случае, если методы выполнились с ошибкой, основная функция не должна выводить результаты их работы в стандартный поток вывода.

Метод `AddDocument` должен возвращать значение типа `bool`: в случае успеха — `true`, а если запрос неудачный — `false`. Чтобы не забыть проверить результат этих методов, пометьте их атрибутом `[[nodiscard]]`.

Также добавьте метод `GetDocumentId`, позволяющий получить идентификатор документа по его порядковому номеру. В случае, если порядковый номер документа выходит за пределы от `[0; кол-во документов)`, метод должен вернуть значение `SearchServer::INVALID_DOCUMENT_ID`:


```cpp

class SearchServer {
public:
    // Defines an invalid document id
    // You can refer to this constant as SearchServer::INVALID_DOCUMENT_ID
    inline static constexpr int INVALID_DOCUMENT_ID = -1;
    ...
    [[nodiscard]] bool AddDocument(int document_id, 
																	 const string& document, 
																	 DocumentStatus status,
                                   const vector<int>& ratings) {
        ...
    }

    template <typename DocumentPredicate>
    [[nodiscard]] bool FindTopDocuments(const string& raw_query, 
																				DocumentPredicate document_predicate,
                                        vector<Document>& result) const {
        ...
    }

    [[nodiscard]] bool FindTopDocuments(const string& raw_query, 
																				DocumentStatus status,
                                        vector<Document>& result) const {
        ...
    }

    [[nodiscard]] bool FindTopDocuments(const string& raw_query, 
																				vector<Document>& result) const {
        ...
    }

    [[nodiscard]] bool MatchDocument(const string& raw_query, 
																		 int document_id,
                                     tuple<vector<string>, 
																		 DocumentStatus>& result) const {
        ...
    }

    int GetDocumentId(int index) const {
        ...
    }
    ...
}; 

```

Пример использования класса поисковой системы с обновлённым интерфейсом:


```cpp

void PrintDocument(const Document& document) {
    cout << "{ "s
         << "document_id = "s << document.id << ", "s
         << "relevance = "s << document.relevance << ", "s
         << "rating = "s << document.rating << " }"s << endl;
}

int main() {
    SearchServer search_server("и в на"s);

    // Явно игнорируем результат метода AddDocument, чтобы избежать предупреждения
    // о неиспользуемом результате его вызова
    (void) search_server.AddDocument(1, "пушистый кот пушистый хвост"s, DocumentStatus::ACTUAL, {7, 2, 7});

    if (!search_server.AddDocument(1, "пушистый пёс и модный ошейник"s, DocumentStatus::ACTUAL, {1, 2})) {
        cout << "Документ не был добавлен, так как его id совпадает с уже имеющимся"s << endl;
    }

    if (!search_server.AddDocument(-1, "пушистый пёс и модный ошейник"s, DocumentStatus::ACTUAL, {1, 2})) {
        cout << "Документ не был добавлен, так как его id отрицательный"s << endl;
    }

    if (!search_server.AddDocument(3, "большой пёс скво\x12рец"s, DocumentStatus::ACTUAL, {1, 3, 2})) {
        cout << "Документ не был добавлен, так как содержит спецсимволы"s << endl;
    }

    vector<Document> documents;
    if (search_server.FindTopDocuments("--пушистый"s, documents)) {
        for (const Document& document : documents) {
            PrintDocument(document);
        }
    } else {
        cout << "Ошибка в поисковом запросе"s << endl;
    }
}

```

Внесите необходимые изменения в методы парсинга поискового запроса и документа, чтобы они могли сообщить вызываемому коду о наличии ошибки возвратом булевых значений.

Чтобы проверить, что слово не содержит спецсимволы, добавьте в класс поисковой системы статический метод `IsValidWord`, проверяющий при помощи стандартного алгоритма [`none_of`](https://en.cppreference.com/w/cpp/algorithm/all_any_none_of), что **ни один из** символов строки не содержит символов с кодами от 0 до пробела (не включая пробел).


```cpp
class SearchServer {
    ...
private:
    ...
    static bool IsValidWord(const string& word) {
        // A valid word must not contain special characters
        return none_of(word.begin(), word.end(), [](char c) {
            return c >= '\0' && c < ' ';
        });
    }
    ...
};
```
# Применяем класс optional

В прошлом уроке вы успели почувствовать неудобства, связанные с возвратом значений через выходные параметры функций:

-   Нужно заранее объявлять переменную-приёмник. Она передаётся в функцию по ссылке, куда функция записывает результат своей работы;
-   Нужно инициализировать выходной параметр внутри функции;
-   Нельзя использовать константы в качестве выходных параметров функций.

Вот был бы способ вместо выходного параметра вернуть либо результат функции, либо некоторое значение, которое означало бы ошибку! Такой способ есть, и вы его освоите прямо сейчас.

Возьмём решение, когда функция может либо вернуть некоторый результат, либо не вернуть его — например, из-за ошибки. Чтобы улучшить решение, применим встроенный шаблонный класс `optional`. Он управляет **опциональными значениями** — значениями, которые могут быть представлены или не представлены. С ними ваша программа способна работать с переменными, которые в один момент времени хранят значение, а в другой — остаются пустыми.

Опциональные значения могут быть простой альтернативой кодам возврата, хотя их область применения этим не ограничивается. Как и в случае с классом `vector`, тип значения, которое хранится в `optional`, нужно указать внутри угловых скобок:

```cpp


// Функция возвращает пару корней квадратного уравнения либо пустое значение, когда решения нет
optional<pair<double, double>> SolveQuadraticEquation(double a, double b, double c) {
    double discriminant = b * b - 4 * a * c;
    if (discriminant < 0) {
        // Возвращаем специальное значение nullopt, означающее отсутствие значения
        return nullopt;
    }

    double x1 = (-b - sqrt(discriminant)) / (2 * a);
    double x2 = (-b + sqrt(discriminant)) / (2 * a);

    // Возвращаем корни уравнения
    return pair{x1, x2};
} 

```

Проверить экземпляр `optional` на наличие в нём значения можно, используя метод `has_value`. Ещё вы можете обращаться с `optional` как со значением типа `bool`, например в операторах ветвления. Пустой объект `optional` будет вести себя как `false`, а непустой — как `true`:


```cpp

optional<int> result;
...
if (result.has_value()) // либо просто: if (result)
{
    // result содержит значение
} else {
    // в переменной result пусто
} 

```

Чтобы получить доступ к значению, хранящемуся внутри `optional`, используют метод `value` и унарный оператор `*`. Если внутри `optional` хранится структура или класс, можно получить доступ к его полям напрямую. Для этого есть специальный оператор `->`:


```cpp

int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;
    // Вместо const optional<pair<double, double>> roots используем auto,
    //     позволяя компилятору вывести тип переменной roots самостоятельно
    if (const auto roots = SolveQuadraticEquation(a, b, c);
        roots.has_value())
    {
        cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        // Доступ к значению можно получить при помощи метода roots.value() или (*roots)
        // Если внутри хранится структура или класс, то доступ к его полям 
        //   можно получить при помощи ->
        cout << "  x1="s << roots.value().first << "; x2="s << roots->second << endl;
    } else {
        cout << "Уравнение не имеет действительных корней"s << endl;
    }
} 

```

Переменную `roots` мы объявили прямо внутри условного выражения оператора `if`, а после `;` проверили её значение. Такой способ объявления переменной позволяет ограничить её область видимости границами оператора `if`, если за пределами этого оператора переменная не используется:


```cpp

if (string name = ReadString(); !name.empty()) {
    cout << "Привет, "s << name << endl;
} else {
    cout << "Привет, незнакомец"s << endl;
} 

```

Для типа `optional` перегружена операция приведения к типу `bool`. Поэтому проверить наличие значения можно просто:


```cpp

// Значение roots будет проверено на наличие значения 
// при помощи оператора приведения к типу bool
if (const auto roots = SolveQuadraticEquation(a, b, c)) {
    cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
    cout << "  x1="s << roots.value().first << "; x2="s << roots->second << endl;
} else {
    cout << "Уравнение не имеет действительных корней"s << endl;
} 

```

Применив `optional`, мы смогли написать функцию, которая способна сообщить об ошибке в ходе работы. При этом дополнительные выходные параметры в сигнатуру функции вводить не надо. Ключевое слово `auto` избавляет от многословности при объявлении типа переменной.
# Введение в исключения

В предыдущем уроке вы использовали `optional` и упростили код обработки ошибок поисковой системы. Но в таком решении есть ряд недостатков.

-   Некоторые конструкции могут выглядеть неочевидно из-за приведения значений `optional` к типу `bool`. Например, вызов метода `FindTopDocuments`:


```cpp

if (search_server.FindTopDocuments("кот пушистый"s)) {
} 

```

Этот код воспринимается как «‎Если поисковый сервер нашел документы»‎. Но семантика у него иная: «‎Если поиск документов завершился без ошибок»‎. А чтобы проверить наличие документов, нужно написать:


```cpp

if (auto documents = search_server.FindTopDocuments("кот пушистый"s);
    documents && !documents->empty())
{
} 

```

-   Когда важно знать не только о наличии ошибки, но и о её причинах, `optional` уступает кодам ошибок.

Посмотрим, во что может превратиться программа, использующая коды ошибок:


```cpp

struct SomeResult { /*...*/ };

enum class ErrorCode {
    Success,
    FailedToSolveQuadraticEquation,
    FailedToWriteDataToFile,
};
// Эта функция может завершиться неудачей по разным причинам, поэтому используем enum
// для возврата кода ошибок
ComplexProblemSolvingErrorCode SolveComplexProblem(SomeResult& result) {
    double a, b, c;
    /* ... */
    pair<double, double> roots;
    // Проверили результат функции, которая может завершиться неудачей
    if (!SolveQuadraticeEquation(a, b, c, roots)) {
        return ErrorCode::CantSolveQuadraticEquation;
    }

    vector<double> numbers = {roots.first, roots.second};
    // Проверяем результат работы еще одной функции
    if (!SaveNumbersToFile(numbers, "file.txt"s)) {
        return ErrorCode::FailedToWriteDataToFile;
    }
    /* Еще несколько подобных проверок */

    // Наконец-то собрали результат
    result = MakeResult(roots.first, roots.second, a + b);
    // Сообщаем об успешном выходе
    return ErrorCode::Success;
} 

```

Читаемость сильно пострадала, потому что код, выполняющий полезную работу, перемешался с кодом, который обрабатывает ошибки. Более того, код по-прежнему нельзя назвать надёжным. Ведь приложение реагирует на коды возврата только тогда, когда проверяет их.

В случае с классами коды ошибок работают ещё хуже. Конструкторы, как мы знаем, не имеют возвращаемого значения. Но они должны создать объект, который находится в согласованном состоянии. Это влечёт множество вопросов. А что, если конструктор не может создать такой объект? Например, как параметризованный конструктор класса `Rational` должен создать дробь, если в качестве знаменателя передали ноль? Проигнорировать ошибку и оставить объект в невалидном состоянии? Превратить число с нулевым знаменателем в 0/1 и притвориться, что ничего не было? Завести у дроби особое состояние вроде `nan`, усложнив тем самым операции над ним и заставив пользователей класса мучиться с его обработкой?


```cpp

class Rational {
public:
    Rational(int numerator, int denominator)
        : numerator_(numerator)
        , denominator_(denominator)
    {
        if (denominator_ == 0) {
            /* В каком состоянии оставить дробь? */
        }
    }
    ...
private:
    int numerator_ = 0;
    int denominator_ = 1;
}; 

```

Беспомощны коды ошибок и при перегрузке операций. В обычные функции можно добавить параметр для возврата кода ошибки, а в операцию — нельзя:


```cpp

int main() {
    Rational x, y;
    cin >> x >> y;
    // Неужели перед каждым делением нужно проверять, не делим ли мы на 0?
    cout << x / y << endl;
} 

```

К счастью, создатели языка C++ включили в него мощный механизм исключений. Они исправят недостатки, присущие кодам ошибок. Чтобы начать работать с исключениями, разберём несколько новых понятий и ключевых слов.

### Выбрасывание исключения. Ключевое слово throw

Сигнализируя о возникновении исключительной ситуации, программа может выбросить исключение. Для этого применяется ключевое слово `throw`. Синтаксис throw-выражения:


```cpp

throw *выражение* 

```

При выполнении выражения `throw`, происходит следующее:

-   На основе `выражения` создаётся объект исключительной ситуации;
-   Управление передаётся в ближайший обработчик исключений, способный поймать выброшенное исключение;
-   Если подходящий обработчик исключения не найден, программа аварийно завершает свою работу.

Например, эта программа не успеет вывести текст и аварийно прекратит работу, потому что возникающие внутри неё исключения никак не обрабатываются:

```cpp


int main() {
    throw 42; // Выбрасываем значения 42 типа int в качестве объекта исключения
    cout << "Этот текст не будет выведен"s << endl;
} 

```

### Обработка исключений в блоке try-catch

Чтобы программа реагировала на исключительные ситуации, код, выбрасывающий исключения, должен выполняться внутри блока `try`, за которым следуют один или несколько блоков `catch`:


```cpp

#include <iostream>

using namespace std;

void ThrowSomething() {
    int value;
    cin >> value;
    throw value;
}

int main() {
    // Внутри блока try могут быть выброшены ислючения
    try {
        ThrowSomething();
        cout << "Этот текст не будет выведен"s << endl;
    } catch (int i) {
        // Это обработчик исключений типа int
        cout << "Поймано целое число: "s << i << endl;
    } catch (double d) {
        cout << "Поймано вещественное число: "s << d << endl;
    } catch (...) {
        // В этот обработчик мы попадём, если ни один из предыдущих обработчиков не сработает
        cout << "Поймано исключение неизвестного типа"s << endl;
    }
    cout << "Выход из программы"s << endl;
} 

```

Запустим программу и проанализируем её работу:


```

**123**
Поймано целое число: 123
Выход из программы 

```

В этот раз выражение `throw` располагается в теле функции `ThrowSomething`, вызванной внутри блока `try`. Так как этот try-блок содержит блок `catch`, способный поймать выброшенное исключение типа `int`, управление будет передано в блок `catch`. Внутри него пойманный объект исключения будет доступен по имени `i`. После выхода из блока `catch` управление будет передано на ближайшую инструкцию, следующую за блоками `try-catch`. В данном случае — на вывод строки «Выход из программы».

Обработчик `catch (...)` способен поймать любые типы исключений, которые не были пойманы предыдущими блоками `catch`. Например, если бы мы выбросили исключение типа `string` вместо `int` или `double`. Внутри этого обработчика объект пойманного исключения напрямую не доступен, ведь мы не знаем его тип. Поэтому просто сообщаем, что поймали неизвестное исключение.

### Объекты исключительных ситуаций. Стандартные классы исключений

В примерах выше тип `int` для наглядности используется как объект, который несёт информацию об исключительной ситуации. На практике в качестве объектов-исключений применяются не примитивные типы, а классы. Это даёт преимущества:

-   Классы позволяют хранить подробную информацию о возникшей проблеме: понятное сообщение об ошибке, которое можно показать пользователю или записать в файл журнала ошибок, числовой код ошибки, название функции или метода, в котором возникла проблема.
-   Разные классы ошибок могут требовать различной реакции, и приложение может использовать для них разные обработчики.

В стандартной библиотеке C++ определены несколько классов стандартных исключений. Они объявлены в файле `<stdexcept>`. Вот некоторые из них:

-   [`invalid_argument`](https://en.cppreference.com/w/cpp/error/invalid_argument). Исключение связано с некорректным значением аргумента функции или метода.
-   [`domain_error`](https://en.cppreference.com/w/cpp/error/domain_error). Ошибки, связанные с выходом за пределы области определения функции. Например, этот тип ошибок можно использовать, чтобы сообщить о попытке деления на ноль или найти точку пересечения параллельных прямых.
-   [`out_of_range`](https://en.cppreference.com/w/cpp/error/out_of_range). Исключение, связанные с обращением к элементам коллекции за пределами указанного диапазона. Именно это исключение выбрасывается методом `at` в коллекциях `map` и `vector` при попытке обратиться к несуществующему элементу.
-   [`runtime_error`](https://en.cppreference.com/w/cpp/error/runtime_error). Исключения, которые связаны с ошибками, возникающими во время выполнения программы, а не с логикой её работы.
-   [`bad_alloc`](https://en.cppreference.com/w/cpp/memory/new/bad_alloc). Ошибки, сообщающие о нехватке памяти. Например, при добавлении элемента в контейнер.

Применим механизм исключений и перепишем функцию `SolveQuadraticEquation`:


```cpp

#include <cmath>
#include <iostream>
#include <stdexcept>

using namespace std

pair<double, double> SolveQuadraticEquation(double a, double b, double c) {
    double discriminant = b * b - 4 * a * c;
    if (discriminant < 0) {
        throw domain_error("квадратное уравнение не имеет действительных корней"s);
    }

    double x1 = (-b - sqrt(discriminant)) / (2 * a);
    double x2 = (-b + sqrt(discriminant)) / (2 * a);
    return {x1, x2};
} 

```

В отличие от версии с кодом возврата, здесь нет ничего лишнего: функция принимает коэффициенты уравнения и возвращает пару корней уравнения. Если найти решение не удаётся, она вместо результата выбрасывает исключение `domain_error`, содержащее описание возникшей ошибки.

Для перехвата исключения обернём содержимое тела функции `main` в блок `try`:


```cpp

int main() {
    try {
        cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
        double a, b, c;
        cin >> a >> b >> c;

        pair<double, double> roots = SolveQuadraticEquation(a, b, c);
        cout << "Корни: уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
    } catch (const domain_error& error) {
        // При помощи метода what() можно получить строковое представление текста ошибки
        cout << "Ошибка: "s << error.what() << endl;
    }
} 

```

Структура функции `main` изменилась по сравнению с версией, где мы использовали коды возврата. Внутри блока try размещается код, который выполняется, если проблем нет. А обработка исключительной ситуации теперь находится в блоке `catch`, куда управление попадёт только при возникновении ошибки. Код, выполняющий полезную работу, отделился от кода обработки ошибок. Это улучшило читаемость кода.

Рассмотрим перехват исключений, имеющих тип `int` и `runtime_error`, для которых не заданы особые обработчики, в обработчике `catch(...)`:

```cpp


#include <iostream>
#include <stdexcept>
#include <string>

using namespace std;

int main() {
    try {
        int x;
        cin >> x;
        if (x == 0) {
            throw invalid_argument("value is zero"s);
        } else if (x == 1) {
            throw domain_error("value is equal to 1"s);
        } else if (x == 2) {
            throw runtime_error("value is equal to 2"s);
        } else {
            throw 42;
        }
    } catch (const domain_error& e) {
        cout << "Domain error: "s << e.what() << endl;
    } catch (const invalid_argument& e) {
        cout << "Invalid argument: "s << e.what() << endl;
    } catch (...) {
        cout << "Unknown error"s << endl;
    }
} 

```

Исключения, типы которых — это классы и структуры, ловите по константной ссылке, а не по значению. Вы подробно разберёте данный вопрос, когда будете изучать наследование. А пока просто запомните. Если обработчик исключения не модифицирует пойманный объект исключения, ссылку следует делать константной.

Механизм исключений языка C++ позволяет разделить путь выполнения программы на две части:

-   работающую, если программа выполняется успешно;
-   работающую, когда нормальный ход выполнения невозможен.

Программа всегда реагирует на исключительную ситуацию. Управление передаётся в подходящий обработчик исключительной ситуации. Если обработчик найден не будет, программа аварийно завершит работу

# Раскрутка стека. Исключения в конструкторе и деструкторе

В этом уроке вы узнаете, что именно происходит при выбрасывании исключения в программе. А ещё изучите особенности работы исключений в конструкторе и деструкторе объекта.

### Раскрутка стека

В прошлом уроке вы узнали, что при выполнении выражения `throw` управление передаётся в ближайший подходящий обработчик исключения. Чтобы проследить, как выбрасывание исключений влияет на жизненный цикл созданных в программе объектов, создадим класс `Greeter`. Он выводит сообщения в своём конструкторе и деструкторе:

```cpp


class Greeter {
public:
    Greeter(const string& name)
        : name_(name)  // Сохраняем name_ внутри
    {
        cout << "Hello, "s << name_ << endl;
    }

    ~Greeter() {
        cout << "Goodbye, "s << name_ << endl;
    }

private:
    string name_;
};

void Test() {
    Greeter a{"Test-A"s};
    Greeter b{"Test-B"s};
    cout << "Throwing an exception"s << endl;
    throw runtime_error("oops");
}

int main() {
    Greeter greeter_main{"main"s};
    try {
        Greeter outer{"outer"s};

        try {
            Greeter inner{"inner"s};
            Test();
        } catch (const invalid_argument& e) {
            cout << "invalid_argument: "s << e.what() << endl;
        }
        cout << "This text will not be printed"s << endl;
    } catch (const runtime_error& e) {
        cout << "runtime_error: "s << e.what() << endl;
    }
    cout << "------"s << endl;
} 

```

Программа выведет:

```

`Hello, main
Hello, outer
Hello, inner
Hello, Test-A
Hello, Test-B
Throwing an exception
Goodbye, Test-B
Goodbye, Test-A
Goodbye, inner
Goodbye, outer
runtime_error: oops
------
Goodbye, main` 
```
При выбрасывании исключения происходит раскрутка стека: программа последовательно покидает вложенные блоки, пока не достигнет начала блока `try`. Если в текущем блоке `try` будет найден подходящий блок `catch`, управление передаётся в него. В противном случае процесс будет продолжаться. Во время раскрутки стека вызываются деструкторы всех локальных переменных каждого блока в порядке, обратном вызову конструкторов.

В нашем случае обработчик исключения, способный поймать `runtime_error`, находится во внешнем блоке `try`. Первыми будут вызваны деструкторы объектов внутри функции `Test`. Вызваны они будут в порядке, обратном их конструированию: сначала деструктор `b`, потом `a`. Затем — деструктор объекта `inner` из внутреннего блока `try`, а после — деструктор объекта `outer` из внешнего блока `try`. Следом выполнится обработчик пойманного исключения. В конце, перед самым выходом из функции `main`, произойдёт разрушение переменной `greeter_main`.

Таким образом, C++ гарантирует вызов деструкторов для всех созданных объектов при выходе из их области видимости, какова бы ни была причина выхода: обычное выполнение программы, возврат из функции по `return` либо выбрасывание исключения.

Детерминированный механизм вызова деструкторов — одна из сильных сторон C++. Он упрощает управление ресурсами. Если каждым ресурсом программы владеет некоторый класс, то при выходе из области видимости переменной этого класса гарантированно произойдёт вызов деструктора. Деструктор автоматически освободит ресурс.

### Выбрасывание исключения в конструкторе и деструкторе

Вы уже знаете, что в C++ жизненный цикл объекта начинается с вызова конструктора. Его основная задача — инициализировать начальное состояние объекта. После окончания работы конструктора инициализация объекта считается завершённой. При выходе из области видимости объекта происходит его деинициализация. Она сопровождается вызовом деструктора. Посмотрим, что происходит на этих этапах при выбрасывании исключения.

Иногда конструктор не может создать объект, находящийся в согласованном состоянии. Например, при попытке создать обыкновенную дробь с нулевым знаменателем. Если конструктор не может выполнить свою задачу, откажитесь от конструирования такого объекта, выбросив в конструкторе исключение. При этом нужно иметь в виду особенности, специфичные для языка C++.

Если во время работы конструктора выбрасывается исключение, инициализация объекта считается незавершённой. При этом деструктор такого объекта вызван не будет, что логично: объект фактически не создан. Зато будут вызваны деструкторы тех его полей, которые к этому моменту уже сконструированы. Рассмотрим на примере:


```cpp

#include <iostream>
#include <stdexcept>
#include <string>

using namespace std;

class Greeter {
public:
    Greeter(const string& name)
        : name_(name)  // Сохраняем name_ внутри
    {
        cout << "Hello, "s << name_ << endl;
    }

    ~Greeter() {
        cout << "Goodbye, "s << name_ << endl;
    }

private:
    string name_;
};

class Thrower {
public:
    Thrower()
        : field_("field"s) // передаём параметры конструктору поля field_
    {
        cout << "Thrower()"s << endl;
        // Исключение, выброшенное здесь, будет поймано за пределами конструктора
        throw runtime_error("Oops"s);
    }

    ~Thrower() {
        cout << "~Thrower()"s << endl;
    }

private:
    Greeter field_;
};

int main() {
    try {
        Thrower t;
    } catch (const runtime_error& e) {
        cout << e.what() << endl;
    }
} 

```

Программа выведет:


```cpp

Hello, field
Thrower()
Goodbye, field
Oops 

```

Сначала будет сконструировано поле `field_` класса `Thrower`. Об этом говорит вывод `Hello, field`. Затем при выполнении тела конструктора `Thrower` будет выведена строка `Thrower()` и выброшено исключение, обработчик которого находится за пределами конструктора. В процессе раскрутки стека вызовется деструктор сконструированного поля `field_`, что подтверждает вывод строки `Goodbye, field`. А вот деструктор `Thrower` вызван не будет, так как конструирование объекта не было завершено.

### Выбрасывание исключения в деструкторе

По умолчанию деструкторы в C++ не должны выбрасывать исключения. Если нарушить это правило, программа аварийно завершится. Такое ограничение обеспечивает корректную работу механизма раскрутки стека.

В коде ниже деструктор класса `ThrowsInDestructor` бросает исключение, которое в самом деструкторе никак не обрабатывается. В результате при выбрасывании исключения программа аварийно завершит работу:


```cpp

#include <iostream>
#include <stdexcept>
#include <string>

using namespace std;

class ThrowsInDestructor {
public:
    ~ThrowsInDestructor() {
        cout << "See you"s << endl;
        throw runtime_error("Oops"s);
    }
};

int main() {
    try {
        ThrowsInDestructor x;
    } catch (...) {
        // Этот код не будет вызван, так как выбрасывание исключения в деструкторе
        // класса ThrowsInDestructor приведёт к аварийному завершению работы программы
        cout << "Exception was caught"s;
    }
} 

```

Современные компиляторы умеют сообщать о таких проблемах предупреждением:


```cpp

warning: '~ThrowsInDestructor' has a non-throwing exception specification but can still throw [-Wexceptions]
        throw runtime_error("Oops"s);
        ^ 

```

Если в деструкторе есть код, который может выбросить исключение, этот код помещают внутрь блока `try/catch`:


```cpp

// Удаляет файл. В случае ошибки может выбросить исключение
void DeleteFile(const string& path) {
    // ...
}

// Управляет временным файлом на диске. При своём разрушении удаляет временный файл
class TemporaryFile {
public:
    explicit TemporaryFile(const string& path)
        : path_(path) {
    }

    const string& GetPath() const {
        return path_;
    }

    ~TemporaryFile() {
        int retries = 10;
        while (retries > 0) {
            try {
                DeleteFile(path_);
                break;
            } catch (...) {
                // Возможно, повезёт на следующей попытке,
                // если ошибка удаления файла была временной. 
                // Например, в момент удаления файл проверялся антивирусом 
                --retries;
            }
        }
    }

private:
    string path_;
};

int main() {
    // Для работы использует
    TemporaryFile tmpFile("temp.txt"s);

    /* Что-нибудь делаем с этим файлом */

    // При выходе из функции деструктор TemporaryFile постарается удалить файл с диска
} 

```

Раскрутка стека — полезный механизм, который за счёт детерминированного вызова деструкторов объектов освобождает ресурсы системы при возникновении исключительных ситуаций. Выбрасывание исключения в конструкторе — стандартный способ уведомить об ошибках, препятствующих созданию жизнеспособного объекта. А вот деструкторы выбрасывать исключений не должны.