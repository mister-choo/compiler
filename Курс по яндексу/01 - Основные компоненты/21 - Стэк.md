# Введение, FIFO и LIFO

Эти странные сочетания букв в названии урока — не два итальянских брата, а аббревиатуры, обозначающие принципы работы абстрактного контейнера:

-   FIFO (first in, first out) — «Первый зашёл, первый вышел»‎;
-   LIFO (last in, first out) — «‎Последний зашёл, первый вышел»‎.

Оба принципа часто встречаются в реальной жизни. Представьте, что вы в магазине. Взяли тележку на входе, протёрли ручку антибактериальной салфеткой и отправились собирать продукты по списку. С полной тележкой вы подходите к кассе и видите оба принципа в действии:

1.  Перед вами ещё несколько человек. Того, кто первый пришёл, кассир обслужит первым. Это FIFO — «Первый зашёл, первый вышел»‎.
2.  Подошла ваша очередь, и вы начинаете разгружать тележку. Прежде всего на ленте окажется то, что в тележке сверху. То есть то, что вы положили в неё последним. Это LIFO — «‎Последний зашёл, первый вышел»‎.

Эти принципы из повседневной жизни нашли применение в программировании. Принцип FIFO называется очередью, а LIFO — стеком. Этот стек напрямую связан со стеком вызовов функций. Как именно — узнаете в этой теме.

Пока речь идёт не о контейнерах и библиотеках, а об абстракции, у которой может быть бесконечное количество реализаций. Реализации в примерах и заданиях — не единственные возможные.

В этой теме вы узнаете, как некоторые контейнеры языка С++ помогают реализовать принцип работы очереди или стека.
# Стек

Вы уже видели, как работает LIFO в ситуации с тележкой в магазине. Другим примером может быть магазин с патронами. Первым из ствола вылетит тот патрон, который вставлен последним. Более близкое к программированию применение стека — знакомый вам стек функций. Он организован точно так же, как магазин с патронами.

Рассмотрим пример:


```cpp

void Bar() {
    int x = 2;
}

void Foo() {
    int x = 1;
    Bar();
}

int main() {
    int x = 0;
    Foo();
} 

```

1.  Всё начинается с функции `main`. Она добавляется в стек.
2.  `main` вызывает функцию `Foo`. Все локальные переменные функции `Foo` оказываются сверху функции `main`. При этом локальные переменные функции `main` не доступны из стека функции `Foo`. Можно не бояться, что у них совпадают имена.
3.  Функция `Foo` вызывает функцию `Bar`. Происходит то же самое, что на прошлом шаге, только теперь на верх стека добавляется функция `Bar`.
4.  Предположим, `Bar` закончила работу. Теперь её можно удалить из стека. Сверху теперь снова оказалась функция `Foo` и все её локальные переменные на месте.
5.  Теперь функция `Foo` тоже закончила работу. Сверху стека оказалась функция `main`, с которой всё начиналось.
6.  Функция `main` закончила своё выполнение. Стек пуст. Это значит, что программа завершила работу, а возвращаемое значение функции `main` и есть возвращаемое значение всей программы.

Попробуйте так же нарисовать стек для рекурсивной функции.

Из всех примеров вытекает, какими должны быть методы класса `Stack`:

-   Вставка элемента в стек — `Push`;
-   Удаление элемента из стека — `Pop`;
-   Получение значения вершины стека — `Peek`;
-   Размер стека — `Size`;
-   Проверка на пустоту — `IsEmpty`. Проверить контейнер на пустоту можно и через функцию `Size`. Но она будет долго пересчитывать все элементы. А `IsEmpty` позволяет без пересчёта узнать, пуст контейнер или нет.

# Очередь и дек

Разобравшись с LIFO (last in, first out), перейдём к FIFO (first in, first out). Очередь — естественный способ хранения и использования различных объектов. Через очередь передаются запросы на обработку. Через очередь пересылаются данные в сети. Всё, что требует порядка выполнения, использует очередь. В C++ для этого существует стандартный контейнер [queue](https://ru.cppreference.com/w/cpp/container/queue).

У очереди две специализации:

1.  Приоритетная очередь. Элементы сортируются по их приоритету. Первым на удаление из неё пойдёт элемент с наивысшим приоритетом. Возможны два подхода к реализации такой очереди:
    -   искать подходящее по приоритету место в очереди в момент вставки элемента. Тогда при удалении можно будет просто убрать первый;
    -   всегда добавлять элемент в конец, а в момент удаления искать элемент с наивысшим приоритетом.

В стандартной библиотеке есть специальный контейнер [priority_queue](https://ru.cppreference.com/w/cpp/container/priority_queue).

2.  Дек — очередь с двусторонним доступом. Она позволяет добавлять и удалять элементы с обоих концов. От вектора дек отличается тем, что не гарантирует хранение всех элементов в памяти последовательно. С одной стороны, это делает дек более гибким. Он может увеличиваться и уменьшаться в зависимости от количества элементов без копирования элементов в новый отрезок памяти. С другой стороны, перемещаться по элементам вектора проще, ведь они заведомо расположены рядом. Выбирая между `deque` и `vector`, отдавайте предпочтение `deque`, если основными операциями будут вставка и удаление с концов контейнера. А `vector` удобнее, когда нужен поиск или любой другой последовательный проход по элементам. В стандартной библиотеке есть специальный контейнер [deque](https://ru.cppreference.com/w/cpp/container/deque).
# Очередь запросов

В прошлом уроке вы узнали, что для упорядочивания часто поступающих запросов их организуют в очередь. Это полезно в нескольких случаях.

-   Когда запросов приходит слишком много, их обработка занимает время. Запросы, ожидающие обработки, могут просто «‎посидеть»‎ в очереди и подождать, пока сервис-обработчик доберётся до них.
-   Для хранения только нужных запросов. Например, вы хотите знать, какие запросы пользователи отправляли на поисковый сервер. Но важны только актуальные запросы за последние сутки. То есть вам интересно время отправки. Хранить запросы старше суток не требуется.

Каждую минуту приходит один запрос от пользователя. То есть максимальное количество запросов, которые надо хранить, — это количество минут в сутках (1440). Появление 1441 запроса будет означать, что сутки прошли, первый запрос прошлых суток нам больше не интересен и может быть удалён. Для реализации такого механизма удобно использовать `deque`. Новый запрос легко вставится в конец, а устаревший запрос удалится из начала.