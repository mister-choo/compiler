# Эффективный вектор

О векторе сказано уже много. Резюмируем ваши знания. Его главное свойство, объясняющее все сильные и слабые стороны, — это последовательное расположение всех элементов в памяти. Создадим вектор из трёх элементов и добавим один элемент в конец:


```cpp

vector<int> v = {1, 2, 3};
v.push_back(4); 

```

При создании вектора на стеке появится объект под именем `v`, который будет содержать информацию о векторе:

-   `int* data` — указатель на выделенный на куче отрезок памяти для трёх элементов типа `int`;
-   `size` — количество элементов, которые в данный момент находятся в векторе;
-   `capacity` — количество элементов, для которых потенциально есть место в выделенной памяти, тоже три.

Данные всех трёх параметров можно получить через одноимённые методы вектора.

Что будет выведено в результате работы этой программы?


```cpp

vector<int> v = {1, 2, 3};
v.push_back(4);
const int* data = v.data();
for (int i = 0; i < v.size(); ++i) {
    cout << *(data + i) << ' ';
}
cout << endl;
for (int i = 0; i < v.capacity(); ++i) {
    cout << *(data + i) << ' ';
} 

```

Два неизвестных числа у каждого пользователя могут быть разными. Это не цифры из лотереи, а некий мусор, лежавший в памяти, которую сейчас использует вектор для хранения элементов. `Capacity` вектора выросла вдвое: была 3, стала 6. Но `size` вектора увеличился на единицу: был 3, стал 4. Когда появятся новые элементы, вектор просто перезапишет их на место мусора. С дальнейшим добавлением элементов `size` станет равен `capacity`, и вектору снова придётся её удвоить.

Для освобождения от мусора есть специальный метод. Он нечасто используется и называется `shrink_to_fit`. Метод переаллоцирует память так, чтобы `capacity` стала равна `size`. Интересно, что этот запрос необязательно будет выполнен. Реализация контейнера такова, что запрос можно оставить без внимания. Да, и такое бывает.

Вернёмся к добавлению элементов в вектор.

В каком порядке будут выполнены эти шаги при работе метода `push_back`?
1.  Проверка, достаточно ли capacity, чтобы добавить новый элемент
2.  Выделение нового блока памяти в два раза больше предыдущего
3.  Копирование старых элементов из предыдущего блока памяти в новый
4.  Добавление нового элемента
5.  Освобождение предыдущего блока памяти, увеличение `capacity` и `size`

Как только добавим в вектор ещё два элемента, место кончится опять. Снова придётся перевыделять память, увеличивая `capacity` в два раза, и копировать туда элементы старого блока. Согласитесь, это неэффективно, если мы заранее знаем, сколько элементов должно быть в векторе. Именно для таких случаев есть метод `reserve`, который вы уже встречали в пятом спринте.

Какой ещё важный сторонний эффект у того, что при добавлении элемента в вектор память может перевыделяться?

Указатель, полученный методом `data`, будет инвалидироваться. После любых операций, которые потенциально могут перевыделять память, лучше этот указатель переопределить, вызвав метод `data` заново.

Не забудьте ответ на этот вопрос. Указатель вектора имеет свойство инвалидироваться или, иначе говоря, становиться неверным, недействительным.

Реализация `SimpleVector` похожа на реализацию стандартного вектора. Внутри вектора есть указатель на участок памяти, где располагаются элементы, и по ним можно итерировать. В конце этой темы вернёмся к `SimpleVector` и улучшим его реализацию, добавив метод `Reserve`.

# Эффективный дек

Вы уже много знаете о векторе, но ещё не изучали, как работает дек, в чём его сила и слабость. С деком — двунаправленной очередью — вы познакомились в четвёртом спринте. В этом уроке рассмотрим его реализацию и выясним, в каких случаях стоит выбрать вектор, а в каких — дек.

Принципиальная разница дека и вектора: дек не обещает хранить элементы в памяти подряд. Сразу, не думая и не вникая в реализацию, можно сказать, что итерироваться по вектору должно быть проще, чем по деку. Проверим интуицию — разберёмся, как организована итерация по деку. Создадим дек, добавим в него три элемента при инициализации, потом ещё один в конец и один в начало:

```cpp

deque<int> d = {1, 2, 3};
deque.push_back(4);
deque.push_front(0); 

```

Будь это вектор, перевыделение памяти и копирование элементов произошли бы уже дважды — при добавлении каждого из новых элементов. Но дек работает иначе:

1.  В стеке будет создан объект `d`, где сохранится количество элементов, расположенных в памяти. Кроме этого, внутри дека есть вектор, хранящий указатели на участки памяти, где находятся элементы. Иначе эти участки называются чанками. Изначально у дека будет один чанк размера три, где будут лежать элементы 1, 2 и 3.
2.  Теперь вызовем `push_back`. Места в памяти для нового элемента нет. Дек выделит новый чанк — например, тоже размера три. Положим туда новый элемент на первое место. Не забудем добавить в вектор чанков новый указатель.
3.  Пока всё идет неплохо. Вызываем `push_front`, и начинается самое интересное. Положить элемент нужно так, чтобы потом найти его по порядковому номеру. Мы же хотим удобный доступ к элементам. Секрет в том, что дек в очередной раз выделит новый чанк и положит туда 0, но не в начало, а в конец. Первые два элемента этого чанка пока останутся пустыми. Точнее там будет лежать некий мусор. Но внутри своей структуры дек держит специальный параметр "shift". Этот параметр говорит, насколько первый элемент дека отстоит от начала чанка. В нашем случае `shift = 2`.


`n` — номер искомого элемента в деке,

`chunk_size` — размер чанка,

`shift` — сдвиг первого элемента относительно начала первого чанка,

`found_chunk` — номер чанка, в котором находится искомый элемент,

`found_position` — номер позиции искомого элемента внутри чанка.

Формула для `found_chunk` :

`(n + shift) / chunk_size`

Формула для `found_position` :

`(n + shift) % chunk_size`

Очевидно, дек легко найдёт элемент по номеру его позиции. А значит, этот контейнер отлично поддерживает итераторы произвольного доступа.

Как дек устроен изнутри, стало ясно. Теперь разберёмся, что эффективнее — дек или вектор.


Эффективен в случае частых вставок в начало

- Дек

Указатели инвалидируются после вставки или удаления объектов

- Вектор

Указатели остаются рабочими после вставки или удаления объектов

- Дек

Вставка в начало вызывает копирование всех элементов, которые до этого были в контейнере

- Вектор

Чтобы найти объект по его индексу, достаточно прибавить индекс к указателю на начало элементов

- Вектор

Поиск объекта по индексу требует вычислений с использованием операций деления и взятия остатка от деления

- Дек

Все элементы находятся в памяти последовательно, поэтому итерация не составляет труда

- Вектор

Итерация через элементы затруднена тем, что элементы могут находиться в разных частях памяти

- Дек


Как видите, получив эффективность вставки в начало, а также рабочие указатели, мы потеряли в лёгкости итерации и поиска.


Напишите программу, которая:

-   Использует `push_back` и вставляет в вектор 1000000 случайных элементов. Не применяйте `Reserve` в этом случае. Представьте, что не знаете, сколько элементов будет вставлено;
-   Использует `push_back` и вставляет столько же элементов в дек;
-   Делает то же самое, но для 5000000 элементов.

Попробуйте увеличивать и уменьшать количество элементов. Примените профилировщик, чтобы сравнить результаты.

Какой контейнер оказался эффективнее?

Дек

Данные разнятся, но на больших числах дек оказывается эффективнее. Он не копирует данные и за счёт этого выигрывает.


Сделайте другой тест. Вы знаете, что итерировать по вектору должно быть проще, чем по деку. Чтобы проверить это, используйте сортировку. Напишите программу, которая бы сортировала 1000000 случайных элементов в векторе и в деке. Измените количество элементов. Сравните результаты.

Какой контейнер оказался эффективнее?

Вектор

В этом случае более эффективным должен получиться вектор.

Возникает вопрос: что делать, если программист не может однозначно предсказать происходящее с контейнером. Например, это некий буфер, куда мы будем записывать данные, а потом должны по запросу пользователя их отсортировать? Здесь однозначного ответа нет, и не верьте тем, кто говорит, что знает его. Когда невозможно предсказать, как контейнер будет использоваться, подобрать подходящий можно, проведя измерения. Используйте профилировщик. Точные данные о времени выполнения операций помогут принять верное решение о выборе контейнера.

# Инвалидация указателей и ссылок

Первая часть этого урока будет посвящена указателям. Разобравшись с ними, вы легко справитесь со ссылками на элементы вектора и дека во второй части.

### Указатели на элементы вектора и дека при удалении/вставке

Вы уже знаете, что произойдёт с указателем `data_ptr`:


```cpp

vector<int> v = {1, 2, 3};
int* data_ptr = v.data();
v.push_back(4); 

```

Он может инвалидироваться.

Если при вставке нового элемента память перевыделена, элементы будут находиться уже по другому адресу. То же самое случится с любыми указателями на элементы вектора, если произойдёт модификация контейнера.

Закрепим. Что будет выведено на экран?


```cpp

vector<string> oh_my_god = { "Oh "s, "my "s, "God"s };
const string* ptr = &oh_my_god[0];
const int exclamations = 1000;

cout << *ptr << *(ptr + 1) << *(ptr + 2) << endl;

for (int i = 0; i < exclamations; ++i) {
    oh_my_god.push_back("!");
}

cout << *ptr << *(ptr + 1) << *(ptr + 2) << endl; 

```

Честно говоря, непонятно.

Указатель будет инвалидирован, и однозначно ответить, что будет выведено на экран, невозможно. Иногда в программировании ответ «поведение/значение не определено»‎ — правильный.

Заменим контейнер на дек:

Скопировать кодCPP
```cpp

deque<string> oh_my_god = { "Oh "s, "my "s, "God"s };
string* ptr = &oh_my_god[0];
const int exclamations = 1000;

cout << *ptr << *(ptr + 1) << *(ptr + 2) << endl;

for (int i = 0; i < exclamations; ++i) {
    oh_my_god.push_back("!");
}

cout << *ptr << *(ptr + 1) << *(ptr + 2) << endl; 

```

Преимущество дека перед вектором в том, что при вставке в начало и в конец копирования не происходит. Это спасает указатели. В данном примере будет выведено:


```cpp

Oh my God
Oh my God 

```

Вставим элементы в середину:


```cpp

deque<string> oh_my_god = { "Oh "s, "my "s, "God"s };
string* ptr = &oh_my_god[0];
const int exclamations = 1000;

cout << *ptr << *(ptr + 1) << *(ptr + 2) << endl;

// Вставим восклицательные знаки после Oh my
auto it = oh_my_god.begin() + 2;
oh_my_god.insert(it, exclamations, string("!"s));

// Выведем весь дек с помощью ptr
for (int i = 0; i < oh_my_god.size(); ++i) {
    cout << *(ptr + i);
} 

```

При выводе дек выглядит не так, как планировалось — мало восклицательных знаков и пропал `God`:


```cpp

Oh my God
Oh my !!!!!!!!!!!!!! 

```

Резюме:

-   При вставке/удалении в вектор указатели инвалидируются всегда;
-   При вставке/удалении в начало или в конец дека — сохраняются;
-   При вставке/удалении из середины дека указатели инвалидируются.

### Ссылки на элементы вектора и дека при удалении/вставке

Для ссылок верно всё, что было верно для указателей:

-   При вставке/удалении в вектор ссылки инвалидируются всегда;
-   При вставке/удалении в начало или в конец ссылки сохраняются;
-   При вставке/удалении из середины дека ссылки инвалидируются.


# Инвалидация итераторов

Вспомните, что происходит с указателями при операциях вставки/удаления в дек и вектор.

Указатели инвалидируются всегда

- Вектор

Ссылки инвалидируются всегда

- Вектор

При вставке/удалении в начало или в конец указатели и ссылки сохраняются

- Дек

При вставке/удалении в середину указатели и ссылки сохраняются

- Ни то, ни другое

При вставке/удалении в середину указатели и ссылки инвалидируются

- И то, и другое

Ссылки не инвалидируются никогда

- Ни то, ни другое

Указатели не инвалидируются никогда

- Ни то, ни другое



Разберёмся, что происходит с итераторами. В целом они умнее обычных ссылок и указателей, поэтому у них есть шансы спастись после изменения контейнера. Поэкспериментируем:


```cpp

int main() {
    // создадим вектор с одним элементом
    vector<int> numbers = {1};
    // найдём итератор на начало
    auto it = numbers.begin();
    cout << *it << endl;
    // вставим достаточно много элементов,
    // чтобы точно вызвать перевыделение памяти
    for (int i = 0; i < 1000; ++i) {
        numbers.push_back(i);
    }
    cout << *it << endl;
} 

```

После работы программы увидим на экране:


```cpp

1
8264304 

```

Второе число может быть другим, это просто мусор. Выходит, итератор вектора инвалидировался. В целом ожидаемо, так как внутри итератора находится указатель, который, как вы уже знаете, точно инвалидируется.

Проведём аналогичный эксперимент с деком. В том же примере заменим контейнер:


```cpp

int main() {
    // заменим контейнер
    deque<int> numbers = {1};
    ...
} 

```

Результат на экране:


```cpp

1
1 

```

Значение элемента не изменилось. Выглядит многообещающе, но итераторы нужны, чтобы итерировать. Проверим, способен ли ещё на это наш итератор:


```cpp

int main() {
    deque<int> numbers = {1};
    auto it = numbers.begin();
    cout << *it << endl;

    for (int i = 0; i < 1024; ++i) {
        numbers.push_back(i);
    }
    // попытаемся вывести последний элемент из дека
    cout << *it << " " << *(it + numbers.size() - 1) << endl;
} 

```

Запустите программу выше в своей IDE и отметьте, что получилось:

Всё сломалось!


Итератор очень старался, но не смог. И всё сломалось. Значит, итераторы инвалидировались несмотря на все старания.

Резюме: операции с изменением числа элементов инвалидируют итераторы и у вектора, и у дека.

# Эффективный список

В предыдущем спринте вы написали свой односвязный список. В стандартной библиотеке есть похожий контейнер, но двусвязный. Разница лишь в том, что перемещаться по нему можно не только вперёд, но и назад.

В векторе все элементы расположены последовательно в одном участке памяти. В деке элементы находятся в памяти в небольших чанках. Продолжая идею уменьшения количества последовательно расположенных элементов, приходим к выделению отдельного участка памяти для каждого элемента. При этом каждый элемент будет знать, где лежит предыдущий и следующий.

Рассмотрим удаление элемента из списка:


```cpp

list<int> numbers = {1, 2, 3, 4};
auto it = find(numbers.begin(), numbers.end(), 3);
numbers.erase(it); 

```

Чтобы найти элемент в списке, используем функцию `find`. Как и у других линейных контейнеров, собственного метода `find` у списка нет. Это значит, что поиск будет осуществляться за линейное время и потребует прохода по всем элементам один за другим.

Найдя тройку, вызываем метод `erase`, который правильно перенаправляет указатели предыдущего и следующего элемента. Время удаления константное.

Вспомните, какова сложность удаления элемента из вектора и дека.

Линейная

Удаление из дека или вектора линейное, а из списка — константное. В этом преимущество списка перед вектором и деком.

Со вставкой элемента то же самое. Выделяется память под элемент, верно расставляются связи. Таким образом, и вставка, и удаление из середины работают для списка быстрее, чем для вектора и дека.

Функциональность списков ограничена, в том числе потому, что быстро получить доступ к элементу по его индексу невозможно. У списка двунаправленный итератор, а не итератор произвольного доступа. Это усложняет — а иногда делает невозможным — работу некоторых алгоритмов. Например, функцию бинарного поиска для списка использовать нельзя, так как эта функция требует итераторы произвольного доступа.

С другой стороны, алгоритм `reverse` существует в виде метода списка, и в реализации этого метода нет переставления элементов местами, что может быть достаточно затратно. Метод `reverse` просто переставляет указатели на соседние элементы.

Преимущество списка в том, что его устройство позволяет оставлять итераторы рабочими. Ни один из других изученных контейнеров такой возможности не предоставлял. Ни вставка, ни удаление, ни какой-либо другое изменение не инвалидируют итераторы списка — если, конечно, вы не удалили тот элемент, на который итератор указывал. В этом случае чуда не произойдёт, и итератор будет инвалидирован.

Ещё менее популярный контейнер, основанный на том же принципе, — [`forward_list`](https://ru.cppreference.com/w/cpp/container/forward_list), однонаправленный список. Он может подойти, если нужно итерировать по элементам только в одну сторону, так как в этом случае экономится память. Каждый элемент помнит указатель только на следующий элемент, но не на предыдущий.

# Проще и быстрее: std::array

Подумайте, в каких случаях использовать динамическую память для хранения элементов контейнера действительно нужно. Данные в куче сохраняются даже после окончания работы функции, где была выделена память. Это полезно не всегда — до сих пор мы создавали контейнер в функции, и после её работы этот контейнер был нам больше не нужен. Динамическое выделение памяти удобно, когда не знаем, сколько точно будет элементов в контейнере. Потенциально их может оказаться как очень много, так и очень мало. Поэтому желательно выделять память «‎по запросу»‎, а не резервировать лишнюю.

Но иногда мы заранее знаем, что элементов будет определённое небольшое количество. Тогда накладные расходы, связанные с выделением памяти в куче, нам не нужны — это достаточно ресурсозатратная операция. На такие случаи есть контейнер `std::array` — массив, который вообще не выделяет память в куче, а хранит всё на стеке функции.

Сначала проверим, что элементы массива действительно лежат на стеке функции. Используем простой приём:


```cpp

#include <array>
#include <iostream>

using namespace std;

int main() {
    // создадим на стеке переменные x и y,
    // положим между ними массив, заполненный восьмёрками
    int x = 111111;
    array<int, 10> numbers;
    numbers.fill(8);
    int y = 222222;
    // пройдёмся по адресам между y и x
    // и выведем то, что лежит в памяти
    for (int* p = &y; p <= &x; ++p) {
        cout << *p << " "s;
    }
    cout << endl;

    return 0;
} 

```

Результат работы программы:


```cpp

222222 8 8 8 8 8 8 8 8 8 8 6 0 111111 

```

Вывод на экран в вашей IDE может немного отличаться, но это не меняет результата — все десять восьмёрок хранятся последовательно в стеке.

Массивы в языке С устроены так же, но всё-таки `std::array` удобнее. У него есть методы, итераторы, и его можно, например, скопировать:


```cpp

#include <array>
#include <iostream>

using namespace std;

int main() {
    array<int, 10> numbers;
    numbers.fill(8);
    // копируем массив
    const auto numbers_copy = numbers;
    // итерируем по массиву
    for (int x : numbers_copy) {
        cout << x << " ";
    }
    cout << endl;

    return 0;
} 

```

Результат работы:


```cpp

8 8 8 8 8 8 8 8 8 8 

```

Разберёмся, в каких ситуациях массив эффективнее. Представим, что у нас есть функция, которая всегда возвращает пять разных элементов. Напишем два варианта этой функции — один вариант с вектором, другой с массивом:


```cpp

#include "profile.h"

#include <array>
#include <vector>

using namespace std;

vector<int> BuildVector(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

array<int, 5> BuildArray(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

const int COUNT = 1000000;

int main() {
    {
        LOG_DURATION("vector");
        for (int i = 0; i < COUNT; ++i) {
            auto numbers = BuildVector(i);
        }
    }
    {
        LOG_DURATION("array");
        for (int i = 0; i < COUNT; ++i) {
            auto numbers = BuildArray(i);
        }
    }

    return 0;
} 

```

В `array<int, 5>` число пять означает максимальное количество элементов, которое может быть сохранено в объекте такого типа. Элементов всегда будет пять, не больше и не меньше. При этом типы `array<int, 5>` и `array<int, 4>` не будут совместимы друг с другом — они абсолютно разные. Запустим программу без оптимизации. Получим:


```cpp

vector: 147 ms
array: 4 ms 

```

А с оптимизацией результат ещё интереснее:


```cpp

vector: 55 ms
array: 0 ms 

```

Несмотря на то, что алгоритмическая сложность у этих двух функций одна и та же, массив работает в разы быстрее вектора.

Какая алгоритмическая сложность у измеряемых макросом `LOG_DURATION` секций?

$C\cdot N$, где C — количество вызовов функции, а N — количество элементов в контейнере.

NN, где NN — количество элементов в контейнере.

$C \cdot N\cdot K$, где $C$ — количество вызовов функции, $N$ — количество элементов в контейнере, $K$ — некая переменная константа.

Проведём ещё один эксперимент. Добавим сортировку для массива, но не будем трогать функцию с вектором. Это увеличит алгоритмическую сложность, и она станет равна $C\cdot N\cdot\log$:


```cpp

#include "profile.h"

#include <algorithm>
#include <array>
#include <vector>

using namespace std;

vector<int> BuildVector(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

array<int, 5> BuildArray(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

const int COUNT = 1000000;

int main() {
    {
        LOG_DURATION("vector");
        for (int i = 0; i < COUNT; ++i) {  // C * N
            auto numbers = BuildVector(i);
        }
    }
    {
        LOG_DURATION("array");
        for (int i = 0; i < COUNT; ++i) {  // C * N * logN
            auto numbers = BuildArray(i);
            sort(begin(numbers), end(numbers));
        }
    }

    return 0;
} 

```

Посмотрим на результаты:


```cpp

vector: 55 ms
array: 6 ms 

```

Важное наблюдение: функция с массивом всё ещё работает быстрее, хотя её алгоритмическая сложность больше. В данном случае расходы на выделение памяти для вектора оказались выше, чем добавление сортировки для массива.

# Разработка контейнера SimpleVector.

В этом и следующем уроках вы разработаете шаблонный класс `SimpleVector`. Это сильно упрощённый аналог стандартного контейнера `vector`, со сходной структурой и функционалом. Работа над SimpleVector поможет вам лучше понять устройство и особенности стандартного `vector`.

### Устройство контейнера SimpleVector

В основе SimpleVector — массив в динамической памяти. Сам контейнер хранит лишь адрес начала массива, а также информацию о его текущем размере и вместимости:

-   Размер — количество элементов, содержащееся в массиве;
-   Вместимость — максимальное количество элементов, которые могут поместиться в массив.


```cpp

template <typename Type>
class SimpleVector {
public:
    ...
private:
    // Вместо сырого указателя лучше использовать умный указатель, такой как ArrayPtr
    Type* items_;

    size_t size_;
    size_t capacity_;
}; 

```

Можно провести аналогию с ведром воды — `capacity_` определяет максимальный объём воды, которая помещается в ведро, а `size_` — текущее количество воды в ведре.

Сконструированный по умолчанию вектор имеет нулевой размер и вместимость, а указатель на массив равен `nullptr`.

Итератор end ссылается на элемент, следующий за последним элементом контейнера. Последний элемент контейнера имеет индекс 4, следовательно, итератор end ссылается на элемент с индексом 5.

### Изменение размера вектора

Как и `std::vector`, класс SimpleVector может изменять свой размер в сторону увеличения и уменьшения. Для этого служит метод `Resize`:

```cpp

template <typename T>
class SimpleVector {
public:
    void Resize(size_t new_size) { ... }
    ...
}; 

```

Самый простой случай — уменьшение размера массива. Для этого SimpleVector достаточно изменить значение поля `size_`.

Таким образом, SimpleVector при уменьшении своего размера не удаляет элементы из массива. «Лишние» элементы продолжают существовать вплоть до удаления массива по адресу `items_`. Например, до разрушения SimpleVector.

Чуть сложнее выглядит увеличение размера в пределах текущей вместимости контейнера. Помимо увеличения значения поля `size_` происходит заполнение новых элементов значением по умолчанию для типа `Type`.

Чтобы заполнить элементы контейнера или массива одним и тем же значением, можно использовать алгоритм [`std::fill`](https://en.cppreference.com/w/cpp/algorithm/fill). Он присваивает элементам диапазона заданное значение.

Так как SimpleVector — шаблонный класс, операция присваивания для некоторых типов `Type` может выбрасывать исключения. Например, при нехватке памяти. Чтобы обеспечить строгую гарантию безопасности исключений, меняйте размер массива лишь после успешного заполнения новых элементов значением по умолчанию.

Самое интересное происходит, когда новый размер превышает текущую вместимость SimpleVector. В этом случае SimpleVector создаёт новый массив большего размера в динамической памяти, куда копирует элементы исходного массива и инициализирует остальные элементы значением по умолчанию. Для копирования элементов подходит алгоритм [`std::copy`](https://en.cppreference.com/w/cpp/algorithm/copy).

Подобно `std::vector` во многих реализациях стандартной библиотеки, новую вместимость SimpleVector можно выбрать как максимум из `new_capacity` и `capacity_ * 2`. Удваивание вместимости минимизирует частоту копирований элементов из одного массива в другой.

После копирования и заполнения элементов нулевым значением можно обновить `size_` и `capacity_`, а старый массив — удалить. Так вы обеспечите строгую гарантию безопасности исключений. Умный указатель `ArrayPtr` позволит сделать код не только надёжнее, но и проще.

Какую асимптотическую сложность имеет операция `Resize` в классе SimpleVector? Выберите один ответ.

$O(N)$

Худший случай работы метода `Resize(N)` происходит при увеличении размера с изменением вместимости контейнера. В этом случае надо скопировать в новый массив `k` существующих элементов и присвоить `N-k` элементам значение по умолчанию. Всего `k + (N-k) = N` операций.


### Очистка контейнера SimpleVector

Очистку SimpleVector выполняет метод `Clear`. Он не изменяет его вместимость и семантически эквивалентен вызову `Resize` с аргументом, равным нулю. Метод `Clear` не выбрасывает исключений.


```cpp

template <typename T>
class SimpleVector {
public:
    void Clear(size_t new_size) noexcept { ... }
    ...
}; 

```

Какую асимптотическую сложность имеет операция `Clear` в классе SimpleVector? Выберите один ответ.

O(1)

Обнуление поля `size_` не зависит от количества элементов массива. Поэтому операция `Clear` выполняется за константное время.


В предыдущем уроке вы познакомились с устройством SimpleVector и создали в нём операции для управления размером контейнера и доступа к его элементам. В этом уроке вы реализуете:

-   возможность сравнивать содержимое векторов, вставлять и удалять элементы;
-   пользовательский конструктор копирования;
-   пользовательский оператор присваивания.

### Сравнение содержимого векторов

Вы уже реализовали операцию сравнения содержимого односвязных списков. Аналогично можно реализовать операции сравнения векторов, применив известные вам стандартные алгоритмы.

При сравнении векторов их вместимость нужно игнорировать. Например, два вектора одного размера, содержащие одни и те же элементы, равны, даже если имеют разную вместимость.

Какой стандартный алгоритм позволит реализовать операторы `<`, `<=`, `>`, `>=` в классе `SimpleVector`? Выберите один ответ.


`std::lexicographical_compare`

Этот алгоритм выполняет лексикографическое сравнение элементов двух диапазонов. Он позволит реализовать оператор `<`, а остальные операции можно выразить на основе оператора `<`.

### Удаление последнего элемента вектора

Для «удаления» последнего элемента служит метод `PopBack`:

```cpp
template <typename Type>
class SimpleVector {
public:
    void PopBack() noexcept { ... };
}; 
```

Чтобы удалить последний элемент непустого контейнера SimpleVector нужно уменьшить значение поля `size_`. Элемент продолжит находиться в векторе, но будет недоступен для использования.

Не допускается вызывать `PopBack`, когда вектор пуст. Такая же особенность есть и у метода `pop_back` стандартного вектора.

### Добавление элемента в конец вектора

Для вставки элемента в конец вектора служит метод `PushBack`:


```cpp

template <typename Type>
class SimpleVector {
public:
    void PushBack(const Type& value) { ... };
}; 

```

При добавлении элемента в конец вектора возможны две ситуации, зависящие от того, заполнен вектор полностью или нет.

Когда вектор заполнен частично, запишем вставляемый элемент следом за последним элементом вектора и увеличим его размер.

Чуть сложнее обстоит ситуация, когда вектор заполнен полностью. В этом случае выделите новый массив с удвоенной вместимостью, скопируйте в него элементы исходного массива, а в конец поместите вставляемый элемент. После этого можно обновить размер и вместимость вектора, переключиться на новый массив, а старый массив — удалить.

При выполнении метода `PushBack` в куче выделяется память и вызывается оператор присваивания у элементов массива. Эти операции могут выбросить исключение. Чтобы сделать метод устойчивым к возникновению исключений, примените умный указатель `ArrayPtr`, а поля `size_` и `capacity_` измените после того, как скопируете элементы в новый массив.

Так как при вставке значения в конец заполненного вектора происходит пересоздание массива элементов, операция `PushBack` делает невалидными существующие ссылки и итераторы. То же самое происходит и в случае `std::vector`.

Какую асимптотическую сложность имеет операция `PushBack` в классе `SimpleVector`? Выберите один ответ. В вариантах ответа буквой N обозначается размер вектора.

O(1)

Операция вставки в конец SimpleVector имеет константную амортизированную сложность за счёт того, что при заполнении массива его вместимость увеличивается вдвое. Для N вызовов `PushBack` суммарное количество операций над элементами массива будет зависеть от N линейно.

### Удаление элемента из произвольного места вектора

Для удаления произвольного элемента вектора служит метод `Erase`. Он принимает итератор, указывающий на удаляемый элемент вектора, и возвращает итератор, который ссылается на элемент, следующий за удалённым:


```cpp
template <typename Type>
class SimpleVector {
public:
    Iterator Erase(ConstIterator pos) { ... }
    ...
}; 
```

При работе этого метода элементы, следующие за удаляемым, должны быть скопированы на его место один за другим. После того, как все элементы будут скопированы, нужно уменьшить размер массива и вернуть указатель на элемент, следующий за удалённым.

При копировании элементов на место удалённого ранее хранившиеся в массиве значения перезаписываются. Если в середине такого процесса будет выброшено исключение, восстановить прежнее значение перезаписанных элементов массива будет невозможно. В этом случае вектор останется в согласованном, пусть и не первоначальном состоянии. В таком случае говорят, что метод предоставляет базовую гарантию безопасности исключений.

Обеспечить строгую гарантию безопасности исключений можно, создав новую копию массива в методе `Erase`, что негативно повлияло бы на производительность. По этой же причине метод `vector::erase` также даёт базовый уровень гарантий безопасности исключений.

### Вставка элемента в произвольное место вектора

Для вставки элемента в произвольное место вектора служит метод `Insert`. Он принимает итератор, ссылающийся на место вставки, и само вставляемое значение. Метод возвращает итератор, который ссылается на вставленный элемент:

```cpp
template <typename Type>
class SimpleVector {
public:
    Iterator Insert(ConstIterator pos, const Type& value) { ... }
    ...
}; 
```

Как и в случае с `PushBack`, при вставке возможны две ситуации:

-   вектор заполнен частично,
-   вектор заполнен полностью.

При частичной заполненности вектора элементы, начиная с позиции вставки, сперва копируются на одну позицию «вправо».

После этого в освободившееся место записывается вставляемый элемент и увеличивается размер вектора.

Какой алгоритм подойдёт для копирования диапазона элементов массива «вправо» на одну позицию?

`std::copy_backward`

Этот алгоритм скопирует элементы диапазона, начиная с самого последнего. Такой порядок подходит для копирования элементов контейнера «вправо».

Когда элемент вставляется в заполненный вектор, в куче выделяется массив с удвоенной вместимостью. В этот массив копируются элементы, которые предшествуют вставляемому, сам вставляемый элемент и элементы, следующие за ним. В конце вектор обновляет свой размер и вместимость, начинает ссылаться на новый массив, а старый массив удаляет:

Как и в случае с `Erase`, базовая гарантия безопасности исключений естественна для метода `Insert`. Аналогичное решение принято и для метода `insert` класса `std::vector`.

Строгой гарантии безопасности исключений можно добиться так: сделать копию вектора, модифицировать её, а в конце обменять содержимое оригинала и копии.

### Обмен содержимого векторов

Для обмена содержимого текущего вектора с другим предназначен метод `swap`:

```cpp
template <typename Type>
class SimpleVector {
public:
    void swap(SimpleVector& other) noexcept { ... }
}; 
```

Чтобы обменять содержимое векторов, достаточно обменять значения их полей. Эта операция выполняется за константное время, не требует выделения памяти и не бросает исключений.