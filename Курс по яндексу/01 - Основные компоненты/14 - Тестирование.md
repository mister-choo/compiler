# Принципы тестирования и отладки кода

Выполняя задания курса, вы могли столкнуться с тем, что ваше решение не принимается тестирующей системой. Хотя вы на своём компьютере убедились: код компилируется без ошибок и даже проходит тесты. Но если тестирующая система не принимает решение, вероятно, в нём правда есть ошибка.

Не отчаивайтесь. Когда изучаете новый язык программирования или технологию, ошибки — это нормально. Даже опытные программисты ошибаются. Более того, чем опытнее программист, тем с большим недоверием он относится к собственному коду — ищет и устраняет в нём ошибки. В этом уроке вы узнаете, как ошибки предупреждать и исправлять.

### Внимательно читайте условие задачи

Убедитесь, что не упустили ни одной детали в условии и правильно поняли, как должна работать ваша программа.

### Проверьте, как программа работает на примерах из условия

Часто в задании есть примеры ввода и вывода. Они демонстрируют ожидаемые результаты работы программы на некотором наборе входных данных. Если ваше решение даёт не тот результат, который ожидается, в нём точно ошибка.

Но примеры покрывают лишь малую часть входных данных, с которыми может столкнуться программа. То, что ваше решение работает на примерах, тоже не гарантирует его правильность. Как говорил Эдгер Дейкстра, тестирование показывает наличие ошибок, но не доказывает, что их нет.

### Вносите изменения в программу небольшими порциями и регулярно тестируйте её работу

Чем меньше изменений вы внесли, тем меньше различий в коде придётся изучить, чтобы найти причину ошибки. Не забывайте после каждого изменения проверять работу программы. Так вы раньше обнаружите и исправите ошибку.

### Составьте план тестирования

Часто в рабочих ситуациях непонятно, почему программа ведёт себя неправильно. Ведь вы не знаете, при каких входных данных возникла ошибка.

Чтобы разобраться в чём дело, воспроизведите ошибку — найдите набор входных данных, при котором она проявит себя.

Возможна обратная ситуация. Вы написали программу и хотите перед выпуском убедиться, что она работает корректно. Подходить к этому хаотично и запускать программу на паре-тройке примеров входных данных не стоит. Так вы рискуете пропустить серьёзные ошибки. А вот пользователи программы их не пропустят.

Переходя к тестированию своей программы, — реальной или учебной — разработайте план тестирования. Для этого проанализируйте условия задачи и выделите классы эквивалентности. Класс эквивалентности — это одно или несколько значений входных данных, к которым программа применяет одинаковую логику.

Например, у вас есть задача определить, високосный год или нет. В ней можно выделить следующие классы эквивалентности:

- Год, номер которого кратен 400, — високосный;
- Остальные годы, номер которых кратен 100, — невисокосные (1700, 1800, 1900, 2100);
- Остальные годы, номер которых кратен четырём, — високосные;
- Прочие годы, не кратные четырём, — невисокосные.

При тестировании программы достаточно будет проверить её работу на небольшом наборе входных данных, выбрав один или два года из каждого класса эквивалентности.

Когда составляете план тестирования, учитывайте крайние (граничные) случаи. Например, если значение целочисленного параметра должно быть в диапазоне от 0 до 100 включительно, следует проверить работу программы при значениях параметра вблизи границ: 0, 1, 99, 100. Если параметр строковый, проверьте работу программы на пустых строках и строках с одним символом. Если имеете дело с контейнером типа `vector`, `set` и `map`, протестируйте, как программа себя ведёт с пустыми контейнерами.

Граничные условия нужно обрабатывать, так как ошибки часто возникают вблизи границ, отделяющих корректные данные от некорректных.

Определившись с набором входных данных, проверьте работу программы на этом наборе. Выходные данные должны соответствовать ожидаемым.

Выходные данные, полученные от этой же программы, в качестве ожидаемого результата использовать не следует. Иначе выдаваемый результат будет совпадать с ожидаемым, даже если в коде есть ошибки. Вычислите ожидаемые данные вручную или получите их из внешнего доверенного источника.

Внимательно читайте условие задачи, вносите изменения в программу маленькими порциями и сразу тестируйте, проверяйте решение на примерах ввода и вывода и на граничных условиях. Выделите классы эквивалентности и составьте план тестирования. Так вы быстрее отловите и исправите ошибки.

# Тестируем по плану

В прошлом уроке вы изучили принципы тестирования, помогающие отладить решение задач. Применим их на практике.

Допустим, у вас есть задача: написать программу, которая считывает со стандартного входа три строки, разделённые пробелами и состоящие из строчных латинских букв. Программа должна вывести в стандартный вывод лексикографически минимальную из этих трёх строк. Например:

- для строк `milk`, `milkshake`, `month` должна быть выведена строка `milk`;
- для строк `c`, `a`, `b` должна быть выведена строка `a`;
- для строк `fire`, `fog`, `wood` должна быть выведена строка `fire`.

Задачу можно решить так:

Скопировать кодCPP

```#include `<iostream>`
#include `<string>`

using namespace std;

int main() {
string a, b, c;

```cpp
cin >> a >> b >> c;

if (a < b && a < c) {  // Первая строка является минимальной?
    cout << a << endl;
} else if (b < a && b < c) {  // Вторая строка является минимальной?
    cout << b << endl;
} else if (c < a && c < b) {  // Третья строка является минимальной?
    cout << c << endl;
}
```

}`

Программа успешно компилируется. Проверим её работу на примерах, которые даны в условии:

Скопировать код

`milk milkshake month milk`

Скопировать код

`c a b a`

Скопировать код

`fire fog wood fire`

Программа отработала правильно. Казалось бы, можно отправлять решение на проверку.

Сделаем это и увидим, что программа не прошла один из тестов. Значит, в ней есть ошибки, которые не проявили себя на примерах из условия задачи. Чтобы исправить ошибки, составим план тестирования.

По условию задачи, пользователь вводит три строки, а программа проверяет, находится ли минимальная строка на первой, второй или третьей позиции. Возможны следующие варианты:

- Все три строки разные. Среди них минимальная строка может быть на первом, втором или третьем месте. При этом относительное местоположение двух других строк значения не имеет. Например:

  `alpha beta gamma`

  `beta alpha gamma`

  `gamma beta alpha`
- Две из трёх строк одинаковые. Пусть одинаковые строки будут являться минимальными. В противном случае входные данные подпадали бы под предыдущий класс эквивалентности. Примеры входных данных:

  `alpha beta alpha`

  `beta alpha alpha`

  `alpha alpha beta`
- Все три строки одинаковые. Например:

  `alpha alpha alpha`

Таким образом, для этой программы у нас семь классов эквивалентности — то есть семь наборов входных данных. План тестирования готов.

Теперь проверим работу программы на каждом варианте входных данных. Когда все строки разные, она работает правильно:

Скопировать код

`alpha beta gamma alpha`

Скопировать код

`beta alpha gamma alpha`

Скопировать код

`gamma beta alpha alpha`

Проверим вариант, где две одинаковые строки минимальны:

Скопировать код

`alpha beta alpha`

Странно, программа не вывела ничего, хотя из трёх строк одна точно должна быть ответом. Взглянем на проверяемые условия:

Скопировать кодCPP

```cpp
`if (a < b && a < c) {  // Первая строка минимальная? cout << a << endl; } else if (b < a && b < c) {  // Вторая строка минимальная? cout << b << endl; } else if (c < a && c < b) {  // Третья строка минимальная? cout << c << endl; }`

```

Первое, что бросается в глаза, — избыточность условия вывода третьей строки. Ведь если ни первая, ни вторая строка не будут ответами, значит, ответ — третья. Уберём последнюю проверку:

Скопировать кодCPP

`#include `<iostream>`
#include `<string>`

using namespace std;

int main() {
string a, b, c;

```cpp
cin >> a >> b >> c;

if (a < b && a < c) {  // Первая строка минимальная?
    cout << a << endl;
} else if (b < a && b < c) {  // Вторая строка минимальная?
    cout << b << endl;
} else {  // Третья строка точно минимальная
    cout << c << endl;
}
```

}`

Проверим, как программа ведёт себя на входных данных, с которыми тест падал:

Скопировать код

`alpha beta alpha alpha`

Отлично, она стала работать правильно там, где не работала. Но считать программу готовой нельзя, ведь мы проверили её не на всех запланированных тестах. Исправляя одну ошибку, мы могли внести новую или пропустить другие. Поэтому важно выполнить все тесты.

Проверим работу программы на предыдущих тестах, чтобы убедиться: то, что работало, мы правками не сломали. Затем продолжим тестирование по плану.

Тесты с тремя разными строками:

Скопировать код

`alpha beta gamma alpha`

Скопировать код

`beta alpha gamma alpha`

Скопировать код

`gamma beta alpha alpha`

Тесты с двумя одинаковыми строками:

Скопировать код

`alpha beta alpha alpha`

Скопировать код

`beta alpha alpha alpha`

Скопировать код

`alpha alpha beta beta`

И снова неожиданность. Программа вывела строку `beta`, хотя в лексикографическом порядке строка `alpha` идёт до `beta`. Проанализируем, как выполняется код на данных `alpha alpha beta`:

Скопировать кодCPP
```cpp

`if (a < b && a < c) {  // Первая строка минимальная? cout << a << endl; } else if (b < a && b < c) {  // Вторая строка минимальная? cout << b << endl; } else {  // Третья строка точно минимальная cout << c << endl; }`

```
```cpp

На таком входном наборе в переменной `a` хранится значение “alpha”, в переменной `b` — “alpha”, а в переменной `c` — “beta”, и ожидается, что будет выведено значение переменной `a` либо переменной `b`. Но `a` и `b` содержат одно и то же значение. Поэтому из-за строгих сравнений `a < b` и `b < a` ни одно из первых двух условий не выполняется, а выполняется третья ветка, выводящая значение переменной `c`. Чтобы исправить ошибку, используем нестрогие сравнения — при равенстве строк неважно, какую из них выводить:

```

Скопировать кодCPP
```cpp

`#include `<iostream>`
#include `<string>`

using namespace std;

int main() {
string a, b, c;

```
```

cin >> a >> b >> c;

if (a <= b && a <= c) {  // Первая строка минимальная?
    cout << a << endl;
} else if (b <= a && b <= c) {  // Вторая строка минимальная?
    cout << b << endl;
} else {
    cout << c << endl;
}
```

}`

Повторим провалившийся тест и убедимся, что новая версия кода решает выявленную проблему:

Скопировать код

`alpha alpha beta alpha`

Ура! Исправили уже две ошибки. Теперь посмотрим, как программа ведёт себя на последнем тесте с тремя одинаковыми строками:

Скопировать код

`alpha alpha alpha alpha`

Исправляя последнюю ошибку, мы могли внести в программу дефект. Перепроверим её работу на всех тестах плана тестирования:

Скопировать код

`alpha beta gamma alpha`

Скопировать код

`beta alpha gamma alpha`

Скопировать код

`gamma beta alpha alpha`

Скопировать код

`alpha beta alpha alpha`

Скопировать код

`beta alpha alpha alpha`

Всё в порядке. Теперь программу можно считать завершённой и смело отправлять её на проверку. Так происходит ручное тестирование.

```jupyter
print(5)

```

Пример 1. Игра «поиск",
Имеется два игрока $A$ и $B ;$ игрок $A$ прячется, а $B$ его ищет. В распоряжении $A$ имеется два убежища (I и II), любое из которых он может выбрать по своему усмотрению. Условия игры таковы: если $B$ найдет $A$ в том убежище, где $A$ спрятался, то $A$ платит ему штраф 1 руб ; если $B$ не найдет $A$ (т. е. будет искать в другом убежище), то он сам должен заплатить $A$ такой же штаф. Требуется построить платежную матрицу.

Решение. Игра состоит всего из двух ходов, оба - личные. У нас
( $A$ ) две стратегии:

$A_{1}-$ прятаться в убежище 1, $A_{2}$

$A_{2}-$ прятаться в убежище $7 .$
У противника $(B)$ тоже две стратегии:

$B_{1}$ - искать в убежище I,

$B_{2}$ искать в убежище II. Перед нами игра $2 \times 2 .$ Ее матрица имеет вид:
# Юнит-тестирование функции

Выполняя ручное тестирование программы в прошлом уроке, вы наверняка отметили следующее:

-   Даже для такой простой программы как «‎Выбор наименьшей строки» понадобилось шесть наборов тестов. Чем сложнее ваша программа, тем больше тестов придётся делать.
-   Полностью тестировать код вручную после каждого изменения — трудоёмкое занятие. Мотивации оно не прибавит.

Эффективнее провести юнит-тестирование. Это подход в разработке, позволяющий автоматизировать проверку отдельных модулей программы. В роли модулей, как правило, выступают классы и функции.

Тестирование отдельных компонентов программы заключается в том, что дополнительно к основному коду пишут модульные тесты — вспомогательный код, проверяющий поведение классов и функций. Напишете тесты один раз — сможете запускать их регулярно и за доли секунды проверять, как работают модули. Юнит-тесты можно использовать сколько угодно раз и сразу получать обратную связь о том, как изменения в коде программы повлияли на её работу.

Разработаем юнит-тесты для программы «‎Выбор наименьшей строки». Чтобы сделать это, код сначала нужно декомпозировать.

### Декомпозиция

Код программы «‎Выбор наименьшей строки» мы написали в прошлом уроке:

Скопировать кодCPP

`#include <iostream>
#include <string>

using namespace std;

int main() {
    string a, b, c;

    cin >> a >> b >> c;

    if (a <= b && a <= c) {  // Первая строка минимальная?
        cout << a << endl;
    } else if (b <= a && b <= c) {  // Вторая строка минимальная?
        cout << b << endl;
    } else {
        cout << c << endl;
    }
}` 

Её работу можно условно разделить на две части:

1.  Ввод и вывод данных. Этот код разбирает запросы, поступающие со стандартного ввода, и выводит результаты;
2.  Нахождение минимальной из трёх строк.

Мы разграничили пользовательский интерфейс и логику программы. Благодаря этому стало возможным менять интерфейс, не меняя логику. Тестировать код тоже будет проще.

Выполним декомпозицию программы: выделим функцию нахождения минимальной строки:

Скопировать кодCPP

`#include <iostream>
#include <string>

using namespace std;

const string& FindMinStr(const string& a, const string& b, const string& c) {
    if (a <= b && a <= c) {
        return a;
    } else if (b <= a && b <= c) {
        return b;
    }
    return c;
}

int main() {
    string a, b, c;

    cin >> a >> b >> c;

    cout << FindMinStr(a, b, c) << endl;
}` 

Упростился код программы в целом и функции `main` в частности. Код нахождения минимальной строки выделен в функцию с понятным именем.

Предварительная декомпозиция на отдельные классы и функции облегчает не только тестирование, но и читаемость кода. В нашем случае имя функции `FindMinStr` однозначно говорит, что она делает. Поэтому необходимость комментариев сведена к минимуму.

## Пишем первый модульный тест

Теперь напишем для функции модульный тест. Он должен вызывать функцию `FindMinStr` с некоторыми параметрами и сравнивать её результат с ожидаемым значением. Для проверок воспользуемся макросом [assert](https://en.cppreference.com/w/cpp/error/assert).

Макросы — специальные конструкции языка C++. Как `#include`, они выполняются на этапе предварительной обработки исходного текста программы. Макросы позволяют заменить одну последовательность символов исходного кода на другую. Применив макрос `assert`, можем «вставить» в код проверку логического условия. Если во время выполнения программы условие будет истинно, она продолжит работать. Если нет — программа выведет диагностическую информацию и аварийно завершит работу. Макрос `assert` проверяет условия, нарушение которых говорит об ошибках в программе. Подключается он директивой `#include <cassert>`.

Код нашего теста будет размещаться в функции `TestFindMinStr`, вызываемой в начале функции `main`. Тест проверит работу функции `FindMinStr` на тех же классах входных данных, что и при ручном тестировании. Чтобы проконтролировать поведение функции на граничных условиях, добавим дополнительные проверки на пустых строках:

Скопировать кодCPP

`#include <cassert>
#include <iostream>
#include <string>

using namespace std;

const string& FindMinStr(const string& a, const string& b, const string& c) {
    if (a <= b && a <= c) {
        return a;
    } else if (b <= a && b <= c) {
        return b;
    }
    return c;
}

void TestFindMinStr() {
    assert(FindMinStr("alpha"s, "beta"s, "gamma"s) == "alpha"s);
    assert(FindMinStr("beta"s, "alpha"s, "gamma"s) == "alpha"s);
    assert(FindMinStr("gamma"s, "beta"s, "alpha"s) == "alpha"s);

    assert(FindMinStr("alpha"s, "beta"s, "alpha"s) == "alpha"s);
    assert(FindMinStr("beta"s, "alpha"s, "alpha"s) == "alpha"s);
    assert(FindMinStr("alpha"s, "alpha"s, "beta"s) == "alpha"s);

    assert(FindMinStr("alpha"s, "alpha"s, "alpha"s) == "alpha"s);

    assert(FindMinStr(""s, "alpha"s, "beta"s) == ""s);
    assert(FindMinStr("beta"s, ""s, "alpha"s) == ""s);
    assert(FindMinStr("beta"s, "alpha"s, ""s) == ""s);

    cout << "TestFindMinStr is OK"s << endl;
}

int main() {
    TestFindMinStr();

    string a, b, c;

    cin >> a >> b >> c;

    cout << FindMinStr(a, b, c) << endl;
}` 

Скомпилируем и запустим программу. Она выведет сообщение `TestFindMinStr OK` и будет ожидать ввод данных от пользователя. Вывод сообщения показывает, что мы не забыли вызвать тест. Убедившись в этом, можем убрать вывод сообщения и не засорять вывод программы служебными данными. Первый модульный тест прошёл успешно.

Но наибольшую пользу модульные тесты приносят, когда падают, обнаружив ошибку. Воспроизведём эту ситуацию, умышленно изменив `<=` на `<` в условных выражениях:

Скопировать кодCPP

`const string& FindMinStr(const string& a, const string& b, const string& c) {
    if (a < b && a < c) {
        return a;
    } else if (b < a && b < c) {
        return b;
    }
    return c;
}` 

Программа выведет сообщение об ошибке и аварийно завершит работу, так как одна из проверок кончилась неудачей:

Скопировать код

``minstr.cpp:23: void TestFindMinStr(): Assertion `FindMinStr("alpha"s, "alpha"s, "beta"s) == "alpha"s' failed.`` 

Диагностическая информация, выведенная макросом `assert`, содержит имя файла и номер строки с условием, не прошедшим проверку. Также здесь указан фрагмент исходного кода, расположенный внутри параметров макроса. Это поможет проанализировать причины возникновения ошибки и исправить её.

Юнит-тест автоматически проверил работу функции `FindMinStr`. Тестировать её вручную после каждого внесённого изменения уже не нужно.
	
	# Юнит-тестирование класса

В предыдущем уроке вы изучили основы создания юнит-тестов, которые проверяют работу функции. В этом уроке рассмотрим более сложный случай — разработку и юнит-тестирование класса.

В качестве примера выберем программу, решающую задачу «Синонимы».

### Задача «Синонимы»

Разработайте программу, которая реализует работу со словарём синонимов. Со стандартного ввода программе поступают три вида запросов:

-   `ADD word1 word2` — добавить пару слов-синонимов `word1` и `word2`;
-   `COUNT word` — вывести в стандартный вывод количество синонимов для слова “word”;
-   `CHECK word1 word2` — вывести `YES`, если слова `word1` и `word2` в данный момент будут синонимами. Если не будут — вывести `NO`;
-   `EXIT` — завершить работу.

Пример входных и выходных данных:

Скопировать код

`ADD program code
ADD code cipher
COUNT cipher
1
CHECK code program
YES
CHECK program cipher
NO
EXIT` 

Из примера видно, что отношение «‎синонимичности» в этой программе:

-   симметрично: если первое слово — синоним второго, то и второе — синоним первого.
-   нетранзитивно: если A — синоним B, а B — синоним C, то A не будет синонимом C, если их не объявить синонимами явно.

### Анализ условия задачи

Прежде чем писать код, проанализируем условие. Как и в случае с задачей «‎Выбор наименьшей строки», функциональность программы можно условно разделить на две части:

1.  Ввод и вывод данных. Этот код разбирает поступающие запросы и выводит результаты.
    
2.  Работа со словарём синонимов. Этот код реализует логику добавления синонимов, подсчёт их количества, а также проверяет, будут два слова синонимами или нет.
    

### Разработка каркаса программы

Сначала разработаем каркас программы, взаимодействующий с пользователем. Для этого подключим библиотеку `<sstream>`. Классы этой библиотеки позволяют считывать данные из строк и выводить данные в строки. Класс `istringstream` — это строковый поток ввода, а класс `ostringstream` — строковый поток вывода. В коде ниже стандартный класс [`istringstream`](https://en.cppreference.com/w/cpp/io/basic_istringstream) упрощает разбор строки:

Скопировать кодCPP

`#include <iostream>
#include <sstream>
#include <string>

using namespace std;

int main() {
    string line;

    // В случае ошибок чтения из cin произойдёт выход из цикла
    while (getline(cin, line)) {
        istringstream command(line);
        string action;
        command >> action;

        if (action == "ADD"s) {
            // Обработка команды ADD word1 word2
        } else if (action == "COUNT"s) {
            // Обработка команды COUNT word
        } else if (action == "CHECK"s) {
            // Обработка команды CHECK word1 word2
        } else if (action == "EXIT"s) {
            break;
        }
    }
}` 

Класс [`istringstream`](https://en.cppreference.com/w/cpp/io/basic_istringstream) позволяет считывать данные из содержимого строки подобно тому, как объект `cin` делает это со стандартным потоком ввода. То есть сначала считываем строку функцией `getline`, затем создаём новый строковый поток `command`. Он нужен, чтобы разобрать содержимое считанной строки.

Пока единственная команда, которую программа умеет обрабатывать, — `EXIT`. Но этого уже достаточно для проверки её работы.

На следующем шаге добавим разбор параметров остальных команд:

Скопировать кодCPP

`int main() {
    string line;

    // В случае ошибок чтения из cin произойдёт выход из цикла
    while (getline(cin, line)) {
        istringstream command(line);
        string action;
        command >> action;

        if (action == "ADD"s) {
            string first_word, second_word;
            command >> first_word >> second_word;

            // TODO: добавить пару синонимов first_word и second_word

        } else if (action == "COUNT"s) {
            string word;
            command >> word;

            // TODO: вывести количество синонимов word

        } else if (action == "CHECK"s) {
            string first_word, second_word;
            command >> first_word >> second_word;

            // TODO: проверить, являются ли first_word и second_word синонимами
            // и вывести YES либо NO

        } else if (action == "EXIT"s) {
            break;
        }
    }
}` 

Реализуем логику обработки команд `ADD`, `COUNT` и `CHECK`. Для этого создадим класс `Synonyms`. Он инкапсулирует данные, нужные для хранения базы синонимов, и предоставляет методы для выполнения основных операций над синонимами:

Скопировать кодCPP

`class Synonyms {
public:
    void Add(const string& first_word, const string& second_word) {
    }

    size_t GetSynonymCount(const string& word) const {
        return 0;
    }

    bool AreSynonyms(const string& first_word, const string& second_word) const {
        return false;
    }
};` 

Преимущества класса `Synonyms` над отдельными функциями, которые принимают коллекцию синонимов:

-   Класс прячет свои данные в приватной области. Поэтому мы можем изменять структуру данных для хранения синонимов, не влияя на код за пределами класса.
-   Упрощается код тестов: тесты проверяют наблюдаемое поведение класса, доступное благодаря его публичным методам, не привязываясь к деталям реализации.
-   Методы класса обеспечивают целостность данных, защищая их от случайной модификации извне.

Методы `GetSynonymCount` и `AreSynonyms` на этом этапе возвращают жёстко заданные значения для того, чтобы код просто скомпилировался без ошибок.

Подставим класс `Synonyms` в функцию `main`:

Скопировать кодCPP

`int main() {
    Synonyms synonyms;

    string line;
    while (getline(cin, line)) {
        istringstream command(line);
        string action;
        command >> action;

        if (action == "ADD"s) {
            string first_word, second_word;
            command >> first_word >> second_word;
            synonyms.Add(first_word, second_word);
        } else if (action == "COUNT"s) {
            string word;
            command >> word;
            cout << synonyms.GetSynonymCount(word) << endl;
        } else if (action == "CHECK"s) {
            string first_word, second_word;
            command >> first_word >> second_word;
            if (synonyms.AreSynonyms(first_word, second_word)) {
                cout << "YES"s << endl;
            } else {
                cout << "NO"s << endl;
            }
        } else if (action == "EXIT"s) {
            break;
        }
    }
}` 

Убедимся, что программа компилируется без ошибок. Но теперь вместо того, чтобы приняться за реализацию методов класса `Synonyms`, напишем модульный тест ДО написания кода.

Написание теста перед написанием кода называется «‎разработка через тестирование»‎ (test-driven development, TDD). Этот подход заключается в следующем:

-   пишем небольшой тест, предъявляющий к тестируемому классу или функции новые требования;
-   запускаем тест, чтобы убедиться: модуль не проходит. Этот этап показывает, что тест работает и проверяет новый, ещё не реализованный функционал;
-   дорабатываем модуль так, чтобы успешно пройти новый тест и все ранее написанные;
-   пишем новый тест, и процесс начинается сначала.

Такой подход обеспечивает хорошее покрытие тестами, ведь мы создаём код, для которого уже написали «‎падающий»‎ тест. Когда написать тест, который модуль не смог бы пройти, невозможно, разработка останавливается. Тесты как бы ведут разработку за собой. Отсюда и название подхода.

Как и в примере из прошлого урока, тест будет выполнять некоторые операции над экземпляром класса, а затем при помощи макросом `assert` сравнивать состояния класса с ожидаемым.

Напишем первый тест и вызовем его в начале программы. Тест будет проверять, как работает функция добавления синонимов: после вызова метода `Add` должно увеличиться количество синонимов, возвращаемое методом `GetSynonymCount`:

Скопировать кодCPP

`#include <cassert>
#include <iostream>
#include <map>
#include <set>
#include <sstream>
#include <string>

using namespace std;

class Synonyms {
    ...
};

void TestAddingSynonymsIncreasesTheirCount() {
    Synonyms synonyms;
    assert(synonyms.GetSynonymCount("music"s) == 0);
    assert(synonyms.GetSynonymCount("melody"s) == 0);

    synonyms.Add("music"s, "melody"s);
    // Два слова являются синонимами друг друга
    assert(synonyms.GetSynonymCount("music"s) == 1);
    assert(synonyms.GetSynonymCount("melody"s) == 1);

    synonyms.Add("music"s, "tune"s);
    assert(synonyms.GetSynonymCount("music"s) == 2);

    // Отношение синонимичности в нашей постановке задачи не является транзитивным.
    // Поэтому слова "tune" и "melody" синонимами друг друга не являются,
    // несмотря на то что оба они являются синонимами слова "music".
    assert(synonyms.GetSynonymCount("tune"s) == 1);
    assert(synonyms.GetSynonymCount("melody"s) == 1);
}

void TestSynonyms() {
    TestAddingSynonymsIncreasesTheirCount();
}

int main() {
    TestSynonyms();
    ...
}` 

Скомпилируем программу и увидим, что тесты не проходят, ведь нужные изменения в класс `Synonyms` мы ещё не внесли:

Скопировать код

``synonyms.cpp:29: void TestAddingSynonymsIncreasesTheirCount(): Assertion `synonyms.GetSynonymCount("music"s) == 1' failed.`` 

Этот шаг позволяет удостовериться, что тесты вообще запускаются и предъявляют к нашей программе новые требования.

На следующем шаге внесём в тестируемый код изменения, достаточные для прохождения теста. Добавим в класс `Synonyms` поле `synonyms_` типа `map`. Ключами будут слова, а значениями — множества их синонимов. Также внесём изменения в методы `Add` и `GetSynonymCount`:

```cpp

`#include <cassert>
#include <iostream>
#include <map>
#include <set>
#include <sstream>
#include <string>

using namespace std;

class Synonyms {
public:
    void Add(const string& first_word, const string& second_word) {
        synonyms_[first_word].insert(second_word);
    }

    size_t GetSynonymCount(const string& word) const {
        if (synonyms_.count(word) != 0) {
            return synonyms_.at(word).size();
        }
        return 0;
    }

    bool AreSynonyms(const string& first_word, const string& second_word) const {
        return false;
    }

private:
    map<string, set<string>> synonyms_;
};` 
```
Скомпилируем и запустим программу:

Скопировать код

``synonyms.cpp:38: void TestAddingSynonymsIncreasesTheirCount(): Assertion `synonyms.GetSynonymCount("melody"s) == 1' failed.`` 

Она сообщает, что одно из условий не выполняется:



```cpp
	void TestAddingSynonymsIncreasesTheirCount() {
    Synonyms synonyms;
    assert(synonyms.GetSynonymCount("music"s) == 0);
    assert(synonyms.GetSynonymCount("melody"s) == 0);

    synonyms.Add("music"s, "melody"s);
    assert(synonyms.GetSynonymCount("music"s) == 1);
    assert(synonyms.GetSynonymCount("melody"s) == 1);  // <--- это условие не выполнилось

    synonyms.Add("music"s, "tune"s);
    assert(synonyms.GetSynonymCount("music"s) == 2);
    assert(synonyms.GetSynonymCount("tune"s) == 1);
    assert(synonyms.GetSynonymCount("melody"s) == 1);
}
``` 

Так как количество слов первого синонима оказалось верным, а количество синонимов второго слова — неверным, предположим, что ошибка закралась в логику добавления синонимов. Находим ошибку в методе `Add`: второе слово добавляется в качестве синонима первого, а первое слово в качестве синонима второго нет. Исправляем ошибку:

Скопировать кодCPP

`class Synonyms {
public:
    void Add(const string& first_word, const string& second_word) {
        synonyms_[first_word].insert(second_word);
        synonyms_[second_word].insert(first_word);
    }

    
};

Снова скомпилируем и запустим программу. В этот раз тесты отработают успешно. Но это не значит, что программа готова. Мы ещё не реализовали и не протестировали метод `AreSynonyms`. Вы сделаете это самостоятельно в задании.

Юнит-тесты позволяют обнаружить и исправить ошибки на ранних этапах. Такой подход стимулирует декомпозицию программы на независимые функциональные модули — так их легче тестировать.
																															 
# Декомпозиция и отладка кода

Вы научились декомпозировать и тестировать код. В этом уроке вы примените новые навыки для проверки задачи «‎Автобусные остановки». Ниже даны условие и правильное решение, целиком содержащееся внутри функции `main`. Сделайте декомпозицию решения на заранее заданные блоки так, чтобы получившаяся программа корректно решала задачу.

### Условие задачи

Реализуйте систему хранения автобусных маршрутов. Обработайте следующие запросы:

-   **NEW_BUS bus stop_count stop1 stop2** ... — добавить маршрут автобуса с параметрами `bus`, `stop_count` и `stop1`, `stop2`, ... Эти параметры команды **NEW_BUS** задают название маршрута (`bus`), количество остановок (`stop_count`) и их названия. Например: `NEW_BUS golden_ring 4 sergiev_posad rostov ivanovo vladimir` задаёт маршрут с названием `golden_ring` и четырьмя остановками: `sergiev_posad`, `rostov`, `ivanovo`, `vladimir`.
-   **BUSES_FOR_STOP stop** — вывести названия всех маршрутов автобуса, проходящих через остановку `stop`.
-   **STOPS_FOR_BUS bus** — вывести названия всех остановок маршрута `bus` со списком автобусов, куда можно пересесть на каждой из остановок.
-   **ALL_BUSES** — вывести список всех маршрутов с остановками.

### Формат ввода

В первой строке ввода содержится количество запросов Q, затем в Q строках следуют описания запросов.

Гарантируется, что все названия маршрутов и остановок состоят лишь из латинских букв, цифр и знаков подчёркивания.

Для каждого запроса **NEW_BUS bus stop_count stop1 stop2 ...** гарантируется, что маршрут `bus` отсутствует, количество остановок больше нуля, а после числа `stop_count` следует именно такое количество названий остановок, причём все названия в каждом списке различны.

### Формат вывода

Для каждого запроса кроме **NEW_BUS** выведите соответствующий ответ на него:

-   На запрос **BUSES_FOR_STOP stop** выведите через пробел список автобусов, проезжающих через эту остановку, в том порядке, в котором они создавались командами **NEW_BUS**. Если остановка `stop` не существует, выведите `No stop`.
-   На запрос **STOPS_FOR_BUS bus** выведите описания остановок маршрута `bus` в отдельных строках в том порядке, в котором они были заданы в соответствующей команде **NEW_BUS**. Описание каждой остановки `stop` должно иметь вид **Stop stop: bus1 bus2 ...**, где **bus1 bus2 ...** — список автобусов, проезжающих через остановку `stop`. Список должен быть в том порядке, в каком автобусы создавались командами **NEW_BUS**, за исключением исходного маршрута `bus`. Если через остановку `stop` не проезжает ни один автобус кроме `bus`, вместо списка автобусов для неё выведите "no interchange**"**. Если маршрут `bus` не существует, выведите `No bus`.
-   На запрос **ALL_BUSES** выведите описания всех автобусов в алфавитном порядке. Описание каждого маршрута `bus` должно иметь вид **Bus bus: stop1 stop2** ..., где **stop1 stop2 ...** — список остановок автобуса `bus` в том порядке, в каком они были заданы в соответствующей команде **NEW_BUS**. Если автобусы отсутствуют, выведите `No buses`.

### Предупреждение

В условии задачи много важных деталей. Чтобы не упустить ни одной, перечитайте его.

### Примеры

**Ввод**

Скопировать код

`10
ALL_BUSES
BUSES_FOR_STOP Marushkino
STOPS_FOR_BUS 32K
NEW_BUS 32 3 Tolstopaltsevo Marushkino Vnukovo
NEW_BUS 32K 6 Tolstopaltsevo Marushkino Vnukovo Peredelkino Solntsevo Skolkovo
BUSES_FOR_STOP Vnukovo
NEW_BUS 950 6 Kokoshkino Marushkino Vnukovo Peredelkino Solntsevo Troparyovo
NEW_BUS 272 4 Vnukovo Moskovsky Rumyantsevo Troparyovo
STOPS_FOR_BUS 272
ALL_BUSES` 

**Вывод**

Скопировать код

`No buses
No stop
No bus
32 32K
Stop Vnukovo: 32 32K 950
Stop Moskovsky: no interchange
Stop Rumyantsevo: no interchange
Stop Troparyovo: 950
Bus 272: Vnukovo Moskovsky Rumyantsevo Troparyovo
Bus 32: Tolstopaltsevo Marushkino Vnukovo
Bus 32K: Tolstopaltsevo Marushkino Vnukovo Peredelkino Solntsevo Skolkovo
Bus 950: Kokoshkino Marushkino Vnukovo Peredelkino Solntsevo Troparyovo` 

## Исходные файлы

Решение этой задачи:


```cpp
#include <iostream>
#include <map>
#include <string>
#include <vector>

using namespace std;

int main() {
    int q;
    cin >> q;

    map<string, vector<string>> buses_to_stops, stops_to_buses;

    for (int i = 0; i < q; ++i) {
        string operation_code;
        cin >> operation_code;

        if (operation_code == "NEW_BUS"s) {
            string bus;
            cin >> bus;
            int stop_count;
            cin >> stop_count;
            vector<string>& stops = buses_to_stops[bus];
            stops.resize(stop_count);
            for (string& stop : stops) {
                cin >> stop;
                stops_to_buses[stop].push_back(bus);
            }

        } else if (operation_code == "BUSES_FOR_STOP"s) {
            string stop;
            cin >> stop;
            if (stops_to_buses.count(stop) == 0) {
                cout << "No stop"s << endl;
            } else {
                for (const string& bus : stops_to_buses[stop]) {
                    cout << bus << " "s;
                }
                cout << endl;
            }

        } else if (operation_code == "STOPS_FOR_BUS"s) {
            string bus;
            cin >> bus;
            if (buses_to_stops.count(bus) == 0) {
                cout << "No bus"s << endl;
            } else {
                for (const string& stop : buses_to_stops[bus]) {
                    cout << "Stop "s << stop << ": "s;
                    if (stops_to_buses[stop].size() == 1) {
                        cout << "no interchange"s;
                    } else {
                        for (const string& other_bus : stops_to_buses[stop]) {
                            if (bus != other_bus) {
                                cout << other_bus << " "s;
                            }
                        }
                    }
                    cout << endl;
                }
            }

        } else if (operation_code == "ALL_BUSES"s) {
            if (buses_to_stops.empty()) {
                cout << "No buses"s << endl;
            } else {
                for (const auto& bus_item : buses_to_stops) {
                    cout << "Bus "s << bus_item.first << ": "s;
                    for (const string& stop : bus_item.second) {
                        cout << stop << " "s;
                    }
                    cout << endl;
                }
            }
        }
    }

    return 0;
}
```
																															 

### Задание

Перед вами шаблон с заготовками классов и функций. Не меняя его функцию `main`, реализуйте эти классы и функции так, чтобы получившаяся программа решала задачу «Автобусные остановки».

### Как будет тестироваться ваша программа

Автоматическая проверяющая система заменит в вашей программе функцию `main` на ту, которая дана в шаблоне, скомпилирует получившийся файл и прогонит на тестах для задачи «Автобусные остановки».

### Рекомендации

Выполняя декомпозицию программы, пишите модульные тесты на получающиеся классы и функции. Для модульного тестирования операций воспользуйтесь классами `istringstream` и `ostringstream`, как в примере:


```cpp
#include <cassert>
#include <iostream>
#include <sstream>

using namespace std;

struct Point {
    int x = 0;
    int y = 0;
};

ostream& operator<<(ostream& output, Point p) {
    output << p.x << ' ' << p.y;
    return output;
}

istream& operator>>(istream& input, Point& p) {
    input >> p.x >> p.y;
    return input;
}

void TestPointOutput() {
    Point p = {15, -8};
    ostringstream output;
    output << p;
    // Метод str() возвращает строку с содержимым, выведенным в ostringstream
    assert(output.str() == "15 -8"s);
}

void TestPointInput() {
    istringstream input;
    // Метод str(строка) у istringstream позволяет задать содержимое, которое будет считываться из istringstream
    input.str("-9 33"s);

    Point p;
    input >> p;
    assert(p.x == -9);
    assert(p.y == 33);
}

int main() {
    TestPointOutput();
    TestPointInput();
}
```
	
	
	## Задание

Разработайте юнит-тесты для своей поисковой системы. Примените в них макрос `assert`, чтобы проверить работу основных функций, таких как:

-   Добавление документов. Добавленный документ должен находиться по поисковому запросу, который содержит слова из документа.
-   Поддержка стоп-слов. Стоп-слова исключаются из текста документов.
-   Поддержка минус-слов. Документы, содержащие минус-слова поискового запроса, не должны включаться в результаты поиска.
-   Матчинг документов. При матчинге документа по поисковому запросу должны быть возвращены все слова из поискового запроса, присутствующие в документе. Если есть соответствие хотя бы по одному минус-слову, должен возвращаться пустой список слов.
-   Сортировка найденных документов по релевантности. Возвращаемые при поиске документов результаты должны быть отсортированы в порядке убывания релевантности.
-   Вычисление рейтинга документов. Рейтинг добавленного документа равен среднему арифметическому оценок документа.
-   Фильтрация результатов поиска с использованием предиката, задаваемого пользователем.
-   Поиск документов, имеющих заданный статус.
-   Корректное вычисление релевантности найденных документов.

### Как будет происходить проверка этого задания

У разработанных вами тестов должна быть точка входа, заданная функцией `TestSearchServer`. Код поисковой системы должен успешно проходить тесты. Тренажёр проверит работу ваших тестов на нескольких предложенных реализациях класса `SearchServer`. Одна из реализаций будет корректной, в других есть ошибки в логике работы класса. Задача считается решённой при выполнении следующих условий:

-   Корректная реализация класса `SearchServer` успешно проходит разработанные вами тесты.
-   Ваши тесты выявляют не менее 50% некорректных реализаций класса `SearchServer`.

Тренажёр ожидает, что ваша реализация класса `SearchServer` будет содержать следующие публичные методы:

Скопировать кодCPP

`struct Document {
    int id;
    double relevance;
    int rating;
};

enum class DocumentStatus {
    ACTUAL,
    IRRELEVANT,
    BANNED,
    REMOVED,
};

class SearchServer {
public:
    void SetStopWords(const string& text) {
        // Ваша реализация данного метода
    }

    void AddDocument(int document_id, const string& document, DocumentStatus status, const vector<int>& ratings) {
        // Ваша реализация данного метода
    }

    template <typename DocumentPredicate>
    vector<Document> FindTopDocuments(const string& raw_query, DocumentPredicate document_predicate) const {
        // Ваша реализация данного метода
    }

    vector<Document> FindTopDocuments(const string& raw_query, DocumentStatus status) const {
        // Ваша реализация данного метода
    }

    vector<Document> FindTopDocuments(const string& raw_query) const {
        // Ваша реализация данного метода
    }

    int GetDocumentCount() const {
        // Ваша реализация данного метода
    }

    tuple<vector<string>, DocumentStatus> MatchDocument(const string& raw_query, int document_id) const {
        // Ваша реализация данного метода
    }

private:
    // Реализация приватных методов вашей поисковой системы
};` 

Перед вами исходный код с примером теста, который проверяет, что стоп-слова исключаются поисковой системой при добавлении документа.

На проверку отправьте только сами тесты, располагающиеся между комментариями:

`// -------- Начало модульных тестов поисковой системы ----------` и

`// --------- Окончание модульных тестов поисковой системы -----------`.
	
	/*
#include <algorithm>
#include <cmath>
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <utility>
#include <vector>
#include <cassert>
using namespace std;

const int MAX_RESULT_DOCUMENT_COUNT = 5;

string ReadLine() {
  string s;
  getline(cin, s);
  return s;
}

int ReadLineWithNumber() {
  int result;
  cin >> result;
  ReadLine();
  return result;
}

vector<string> SplitIntoWords(const string &text) {
  vector<string> words;
  string word;
  for (const char c : text) {
    if (c == ' ') {
      if (!word.empty()) {
        words.push_back(word);
        word.clear();
      }
    } else {
      word += c;
    }
  }
  if (!word.empty()) {
    words.push_back(word);
  }

  return words;
}

struct Document {
  int id;
  double relevance;
  int rating;
};

enum class DocumentStatus {
  ACTUAL,
  IRRELEVANT,
  BANNED,
  REMOVED,
};

class SearchServer {
public:
  void SetStopWords(const string &text) {
    for (const string &word : SplitIntoWords(text)) {
      stop_words_.insert(word);
    }
  }

  void AddDocument(int document_id, const string &document,
                   DocumentStatus status, const vector<int> &ratings) {
    const vector<string> words = SplitIntoWordsNoStop(document);
    const double inv_word_count = 1.0 / words.size();
    for (const string &word : words) {
      word_to_document_freqs_[word][document_id] += inv_word_count;
    }
    documents_.emplace(document_id,
                       DocumentData{ComputeAverageRating(ratings), status});
  }

  vector<Document> FindTopDocuments(const string &raw_query) const {
    return FindTopDocuments(
        raw_query, []([[maybe_unused]] int document_id,[[maybe_unused]] DocumentStatus status,[[maybe_unused]] int rating) {
          return status == DocumentStatus::ACTUAL;
        });
  }

  vector<Document> FindTopDocuments(const string &raw_query,
                                    DocumentStatus expected_status) const {
    return FindTopDocuments(
        raw_query,
        [expected_status]([[maybe_unused]] int document_id,[[maybe_unused]] DocumentStatus status,[[maybe_unused]] int rating) {
          return status == expected_status;
        });
  }

  template <typename Filter>
  vector<Document> FindTopDocuments(const string &raw_query,
                                    Filter filter) const {
    const Query query = ParseQuery(raw_query);
    auto matched_documents = FindAllDocuments(query, filter);

    sort(matched_documents.begin(), matched_documents.end(),
         [](const Document &lhs, const Document &rhs) {
           if (abs(lhs.relevance - rhs.relevance) < 1e-6) {
             return lhs.rating > rhs.rating;
           } else {
             return lhs.relevance > rhs.relevance;
           }
         });
    if (matched_documents.size() > MAX_RESULT_DOCUMENT_COUNT) {
      matched_documents.resize(MAX_RESULT_DOCUMENT_COUNT);
    }
    return matched_documents;
  }

  int GetDocumentCount() const { return documents_.size(); }

  tuple<vector<string>, DocumentStatus> MatchDocument(const string &raw_query,
                                                      int document_id) const {
    const Query query = ParseQuery(raw_query);
    vector<string> matched_words;
    for (const string &word : query.plus_words) {
      if (word_to_document_freqs_.count(word) == 0) {
        continue;
      }
      if (word_to_document_freqs_.at(word).count(document_id)) {
        matched_words.push_back(word);
      }
    }
    for (const string &word : query.minus_words) {
      if (word_to_document_freqs_.count(word) == 0) {
        continue;
      }
      if (word_to_document_freqs_.at(word).count(document_id)) {
        matched_words.clear();
        break;
      }
    }
    return {matched_words, documents_.at(document_id).status};
  }

private:
  struct DocumentData {
    int rating;
    DocumentStatus status;
  };

  set<string> stop_words_;
  map<string, map<int, double>> word_to_document_freqs_;
  map<int, DocumentData> documents_;

  bool IsStopWord(const string &word) const {
    return stop_words_.count(word) > 0;
  }

  vector<string> SplitIntoWordsNoStop(const string &text) const {
    vector<string> words;
    for (const string &word : SplitIntoWords(text)) {
      if (!IsStopWord(word)) {
        words.push_back(word);
      }
    }
    return words;
  }

  static int ComputeAverageRating(const vector<int> &ratings) {
    if (ratings.empty()) {
      return 0;
    }
    int rating_sum = 0;
    for (const int rating : ratings) {
      rating_sum += rating;
    }
    return rating_sum / static_cast<int>(ratings.size());
  }

  struct QueryWord {
    string data;
    bool is_minus;
    bool is_stop;
  };

  QueryWord ParseQueryWord(string text) const {
    bool is_minus = false;
    // Word shouldn't be empty
    if (text[0] == '-') {
      is_minus = true;
      text = text.substr(1);
    }
    return {text, is_minus, IsStopWord(text)};
  }

  struct Query {
    set<string> plus_words;
    set<string> minus_words;
  };

  Query ParseQuery(const string &text) const {
    Query query;
    for (const string &word : SplitIntoWords(text)) {
      const QueryWord query_word = ParseQueryWord(word);
      if (!query_word.is_stop) {
        if (query_word.is_minus) {
          query.minus_words.insert(query_word.data);
        } else {
          query.plus_words.insert(query_word.data);
        }
      }
    }
    return query;
  }

  // Existence required
  double ComputeWordInverseDocumentFreq(const string &word) const {
    return log(GetDocumentCount() * 1.0 /
               word_to_document_freqs_.at(word).size());
  }

  template <typename Filter>
  vector<Document> FindAllDocuments(const Query &query, Filter filter) const {
    map<int, double> document_to_relevance;
    for (const string &word : query.plus_words) {
      if (word_to_document_freqs_.count(word) == 0) {
        continue;
      }
      const double inverse_document_freq = ComputeWordInverseDocumentFreq(word);
      for (const auto [document_id, term_freq] :
           word_to_document_freqs_.at(word)) {
        const auto document_data = documents_.at(document_id);
        if (filter(document_id, document_data.status, document_data.rating)) {
          document_to_relevance[document_id] +=
              term_freq * inverse_document_freq;
        }
      }
    }

    for (const string &word : query.minus_words) {
      if (word_to_document_freqs_.count(word) == 0) {
        continue;
      }
      for (const auto [document_id, _] : word_to_document_freqs_.at(word)) {
        document_to_relevance.erase(document_id);
      }
    }

    vector<Document> matched_documents;
    for (const auto [document_id, relevance] : document_to_relevance) {
      matched_documents.push_back(
          {document_id, relevance, documents_.at(document_id).rating});
    }
    return matched_documents;
  }
};
*/
/* Подставьте вашу реализацию класса SearchServer сюда */

// -------- Начало модульных тестов поисковой системы ----------

// Тест проверяет, что поисковая система исключает стоп-слова при добавлении документов
void TestExcludeStopWordsFromAddedDocumentContent() {
    const int doc_id = 42;
    const string content = "cat in the city"s;
    const vector<int> ratings = {1, 2, 3};
    // Сначала убеждаемся, что поиск слова, не входящего в список стоп-слов,
    // находит нужный документ
    {
        SearchServer server;
        server.AddDocument(doc_id, content, DocumentStatus::ACTUAL, ratings);
        const auto found_docs = server.FindTopDocuments("in"s);
        assert(found_docs.size() == 1);
        const Document& doc0 = found_docs[0];
        assert(doc0.id == doc_id);
    }

    // Затем убеждаемся, что поиск этого же слова, входящего в список стоп-слов,
    // возвращает пустой результат
    {
        SearchServer server;
        server.SetStopWords("in the"s);
        server.AddDocument(doc_id, content, DocumentStatus::ACTUAL, ratings);
        assert(server.FindTopDocuments("in"s).empty());
    }
}

/*
Разместите код остальных тестов здесь
*/

void TestRelevanceSort() {
    SearchServer server;
    server.AddDocument(11, "one two  four five", DocumentStatus::ACTUAL, { 10 });
    server.AddDocument(12, "one three five seven", DocumentStatus::ACTUAL, { 20 });
    server.AddDocument(13, "one two", DocumentStatus::ACTUAL, { 30 });
    server.AddDocument(14, "one two four five", DocumentStatus::ACTUAL, { 5 });
    server.AddDocument(15, "one one two two  ", DocumentStatus::ACTUAL, { 15 });
    server.AddDocument(16, "one two four five", DocumentStatus::ACTUAL, { 25 });
 
    vector<Document>res = server.FindTopDocuments("two");
    if (res.size() > 0) {
        for (int i = 0; i < res.size() - 1; ++i) {
            if (abs(res[i].relevance - res[i + 1].relevance) < 1e-6)
                assert(res[i].rating > res[i + 1].rating);
            else
                assert(res[i].relevance > res[i + 1].relevance);
        }
    }
 
    vector<Document>res2 = server.FindTopDocuments("three");
    if (res2.size() > 0) {
        for (int i = 0; i < res2.size() - 1; ++i) {
            if (abs(res2[i].relevance - res2[i + 1].relevance) < 1e-6)
                assert(res2[i].rating > res2[i + 1].rating);
            else
                assert(res2[i].relevance > res2[i + 1].relevance);
        }
    }
}
 
// Фильтрация результатов поиска с использованием предиката, задаваемого пользователем
void TestPredId() {
    SearchServer server;
 
    server.AddDocument(0, "one one two two three three", DocumentStatus::ACTUAL, { 0 });
    server.AddDocument(1, "two three", DocumentStatus::ACTUAL, { 2,4 });
    server.AddDocument(2, "one two three four five six", DocumentStatus::BANNED, { -5 });
    server.AddDocument(3, " two  four five six", DocumentStatus::BANNED, { -5,10,5 });
    server.AddDocument(4, "one three five", DocumentStatus::IRRELEVANT, { 5 });
    server.AddDocument(5, "one two five six", DocumentStatus::REMOVED, { 20 });
 
    auto found1 = server.FindTopDocuments("one", []([[maybe_unused]] int document_id,[[maybe_unused]] DocumentStatus status,[[maybe_unused]] int rating) {
        return document_id % 2 == 0; });
    for (auto doc : found1) {
        assert(doc.id % 2 == 0);
        }
 
    auto found2 = server.FindTopDocuments("two", []([[maybe_unused]] int  document_id,[[maybe_unused]] DocumentStatus status,[[maybe_unused]] int rating) {
        return status == DocumentStatus::BANNED; });
    for (auto doc : found2) {
        assert(doc.id == 2 || doc.id == 3);
    }
 
    auto found3 = server.FindTopDocuments("three", []([[maybe_unused]] int document_id,[[maybe_unused]] DocumentStatus status,[[maybe_unused]] int rating) {
        return rating > 0; });
    for (auto doc : found3) {
        assert(doc.rating > 0);
    }
}


// Функция TestSearchServer является точкой входа для запуска тестов
void TestSearchServer() {
    TestExcludeStopWordsFromAddedDocumentContent();
    TestRelevanceSort();
    TestPredId();
    // Не забудьте вызывать остальные тесты здесь
}

// --------- Окончание модульных тестов поисковой системы -----------

int main() {
    TestSearchServer();
    // Если вы видите эту строку, значит все тесты прошли успешно
    cout << "Search server testing finished"s << endl;
}
	
	# Используем макросы и улучшаем фреймворк

Вы начали разрабатывать собственный фреймворк для юнит-тестирования:

-   написали шаблонную функцию `AssertEqual`. Она даёт возможность проверять на равенство значения в коде и выводить диагностическую информацию, когда проверка не сработала.
-   написали функцию `Assert`. Ей удобно проверять значения типа `bool`.

Но во фреймворке есть недостатки:

-   Функции `AssertEqual` и `Assert`, в отличие от стандартного макроса `assert`, не выводят название файла и номер строки, где произошла ошибка. Временное решение проблемы — добавить дополнительный параметр `hint`. Он выводит сообщение с подсказкой.
-   Подсказку нужно писать. Без него найти проблему в коде сложно, а писать текст подсказки при каждой проверке — трудоёмко.

В этом уроке вы научите свой фреймворк выводить диагностическую информацию и внесёте в него другие улучшения.

## Узнаём, где проверка не сработала

В C++ перед компиляцией происходит препроцессинг — обработка исходного кода. На этом этапе макросы заменяются на соответствующие им значения. Некоторые макросы, например `assert`, объявлены в стандартной библиотеке, другие встроены напрямую в компилятор. Сейчас нас интересуют встроенные:

-   `__FILE__` — вместо него препроцессор вставляет в текст программы имя текущего файла исходного кода;
-   `__LINE__` — вместо него препроцессор вставляет номер текущей строки;
-   `__FUNCTION__` — препроцессор заменяет его на имя текущей функции.

Эти макросы улучшат фреймворк. Вот как они работают:

Скопировать кодCPP

`#include <iostream>
#include <string>

using namespace std;

void PrintDiagnosticInformation() {
    cout << "Function name: "s << __FUNCTION__ << endl;
    cout << "File name: "s << __FILE__ << endl;
    cout << "Line number: "s << __LINE__ << endl;
    cout << "Line number: "s << __LINE__ << endl;
}

int main() {
    PrintDiagnosticInformation();
}` 

Препроцессор обнаружит макрос `__FUNCTION__` и заменит его на строку `"PrintDiagnosticInformation"`, которая задаёт имя текущей функции. Макрос `__FILE__` будет заменён на имя текущего файла исходного кода, а `__LINE__` — на номер текущей строки. В результате на этап компиляции будет передан видоизменённый исходный код:

Скопировать кодCPP

`#include <iostream>
#include <string>

using namespace std;

void PrintDiagnosticInformation() {
    cout << "Function name: "s << "PrintDiagnosticInformation" << endl;
    cout << "File name: "s << "macro_0_0.cpp" << endl; // У вас может быть другое имя файла
    cout << "Line number: "s << 9 << endl;
    cout << "Line number: "s << 10 << endl;
}

int main() {
    PrintDiagnosticInformation();
}` 

Программа выведет диагностическую информацию:

Скопировать код

`Function name: PrintDiagnosticInformation
File name: macro_0_0.cpp
Line number: 9
Line number: 10` 

## Применяем макросы, которые меняют текст

Вывести диагностическую информацию можно иначе — применить макросы, меняющие одну последовательность символов на другую. Для объявления такого макроса используют директиву `#define`:

Скопировать кодCPP

`#include <iostream>

using namespace std;

// При помощи директивы #define объявляется макрос GREETING
#define GREETING cout << "Hello, friend"s << endl

int main() {
    // Вместо GREETING в код программы будет cout << "Hello, friend"s << endl
    GREETING;

    // Внутри строковых литералов и комментариев подстановка макроса не происходит
    cout << "GREETING"s << endl;
}` 

Макрос `GREETING` на этапе препроцессинга будет заменён на код вывода строки "Hello, friend". То есть одна последовательность символов сменится на другую. Этот пример наглядно показывает работу макросов, но в реальности для решения такой задачи больше подходит функция.

Чтобы отличать макросы от функций, будем и дальше использовать `UPPER_SNAKE_CASE` для их именования. Макрос может иметь один или несколько параметров, передаваемых в скобках. При обработке макроса фактические значения его параметров вставляются в исходный код:

Скопировать кодCPP

`#include <iostream>

using namespace std;

// Директивой #define объявляем макрос GREETING параметрами s1 и s2
#define GREETING(s1, s2) cout << "Hello, "s << (s1) << " and "s << (s2) << endl

int main() {
    // Будет заменено на:
    // cout << "Hello, "s << ("Ivan"s) << " and "s << ("Maria"s) << endl;
    GREETING("Ivan"s, "Maria"s);

    // Будет заменено на:
    // cout << "Hello, "s << (5 + 5) << " and "s << (42) << endl;
    GREETING(5 + 5, 42);
}` 

Написанный в скобках параметр `5 + 5` будет подставлен в исходный код в виде текста. Заключать параметры макроса в скобки — это важно. Разберёмся почему:

Скопировать кодCPP

`#include <iostream>

using namespace std;

// Без заключения параметров в скобки
#define MULTIPLY(a, b) a * b

int main() {
    // Макрос MULTIPLY будет раскрыт как 2 + 3 * 5, а не 5 * 5, так как
    // параметры макроса подставляются такими, какие они есть
    cout << MULTIPLY(2 + 3, 5) << endl;
}` 

После раскрытия макроса `MULTIPLY` в исходный код будет вставлен текст `2 + 3 * 5`. Результатом этого выражения будет число 17, хотя от выражения `MULTIPLY(2 + 3, 5)` ожидаем получить число 25.

Если в теле макроса перед именем параметра поставить символ `#`, при раскрытии макроса вместо параметра появится строка, которая содержит его исходный код:

Скопировать кодCPP

`#include <iostream>

using namespace std;

// #<имя параметра> подставляет строковое представление параметра макроса
#define PrintExpression(expr) cout << (#expr) << " = "s << (expr) << endl

int main() {
    PrintExpression((8 + 15) * 3);
}` 

Программа выведет:

Скопировать код

`(8 + 15) * 3 = 69` 

Такие особенности макросов можно использовать для вывода диагностической информации. Объявим функцию `LogImpl`, которая принимает выводимую строку, имя функции, имя файла и номер строки исходного кода. Применение функции без макроса сделает код громоздким. Компактности можно добиться макросом `LOG`. Он автоматически подставит имя функции, имя файла и номер строки на место своего использования:

Скопировать кодCPP

`#include <iostream>
#include <string>

using namespace std;

// Функция LogImpl выполняет основную работу
void LogImpl(const string& str, const string& func_name, const string& file_name, int line_number) {
    cout << file_name << "("s << line_number << "): "s;
    cout << func_name << ": "s << str << endl;
}

// Макрос LOG используется для удобного вызова функции LogImpl
#define LOG(expr) LogImpl(#expr, __FUNCTION__, __FILE__, __LINE__)

int main() {
    // Функцию LogImpl можно вызывать напрямую, но это не очень удобно
    LogImpl("12345"s, __FUNCTION__, __FILE__, __LINE__);

    // Макрос LOG раскрывается в вызов функции LogImpl более удобно
    LOG(12345);
    LOG("hello"s);
    LOG(1 + 10);
}` 

Код выведет:

Скопировать код

`macro_4.cpp(17): main: 12345
macro_4.cpp(20): main: 12345
macro_4.cpp(21): main: "hello"s
macro_4.cpp(22): main: 1 + 10` 

В повседневной разработке на C++ макросы нужны редко. На этапе препроцессинга они заменяют исходный код на новый. Разница между новым и исходным кодом может затруднить отладку. Иногда макросы действительно позволяют решить задачу более эффективно. Но часто лучше использовать сочетание макросов и функций, в том числе шаблонных.

## Улучшаем функцию AssertEqual

Теперь понятно, как научить функцию `AssertEqual` выводить диагностическую информацию. Преобразуем `AssertEqual` в функцию `AssertEqualImpl` и добавим макросы `ASSERT_EQUAL` и `ASSERT_EQUAL_HINT`. Они упрощают передачу вспомогательных данных в эту функцию:

Скопировать кодCPP
```cpp
template <typename T, typename U>
void AssertEqualImpl(const T& t, const U& u, const string& t_str, const string& u_str, const string& file,
                     const string& func, unsigned line, const string& hint) {
    if (t != u) {
        cout << boolalpha;
        cout << file << "("s << line << "): "s << func << ": "s;
        cout << "ASSERT_EQUAL("s << t_str << ", "s << u_str << ") failed: "s;
        cout << t << " != "s << u << "."s;
        if (!hint.empty()) {
            cout << " Hint: "s << hint;
        }
        cout << endl;
        abort();
    }
}

#define ASSERT_EQUAL(a, b) AssertEqualImpl((a), (b), #a, #b, __FILE__, __FUNCTION__, __LINE__, ""s)

#define ASSERT_EQUAL_HINT(a, b, hint) AssertEqualImpl((a), (b), #a, #b, __FILE__, __FUNCTION__, __LINE__, (hint))

int Sum(int a, int b) {
    // Ошибка допущена намеренно, чтобы продемонстрировать вывод информации об ошибке
    return a + b + 1;
}

int main() {
    string hello = "hello"s;
    ASSERT_EQUAL(hello.length(), 5);

    // Эта проверка не пройдёт
    ASSERT_EQUAL_HINT(Sum(2, 2), 4, "Sum() must be correct"s);
}` 
```
При срабатывании макроса будет выведена диагностическая информация, которая облегчит обнаружение и исправление ошибок:

Скопировать код

```cpp
assert_3.cpp(38): main: ASSERT_EQUAL_HINT(Sum(2, 2), 4) failed: 5 != 4. Hint: Sum() must be correct` 
```
В задании вы аналогичным способом улучшите работу функции `Assert`.
	
	## Задание

Усовершенствуйте фреймворк. Реализуйте макросы `ASSERT` и `ASSERT_HINT`. Пусть в случае их срабатывания выводится информация об имени файла, номере строки и функции, где макрос сработал.

# Учим фреймворк проверять элементы контейнеров

В предыдущем уроке вы познакомились с возможностями макросов и применили их, чтобы улучшить фреймворк. Теперь он выводит подробную диагностическую информацию. В этом уроке научим ваш фреймворк проверять содержимое элементов контейнера.

Пока он этого делать не умеет. Рассмотрим тестирований функций `TakePositives` и `TakeEvens`, которые возвращают `vector`:

-   `TakeEvens` — возвращает чётные элементы массива;
-   `TakePositives` — возвращает положительные элементы переданного ей массива.

Скопировать кодCPP

```cpp
`vector<int> TakeEvens(const vector<int>& numbers) {
    vector<int> evens;
    for (int x : numbers) {
        if (x % 2 == 0) {
            evens.push_back(x);
        }
    }
    return evens;
}
```


```cpp
vector<int> TakePositives(const vector<int>& numbers) {
    vector<int> positives;
    for (int x : numbers) {
        // Ошибка допущена намеренно, чтобы продемонстрировать вывод при несработавшем AssertEqual
        if (x >= 0) {
            positives.push_back(x);
        }
    }
    return positives;
}
```


```cpp
int main() {
    const vector<int> numbers = {1, 0, 2, -3, 6, 2, 4, 3};
    const vector<int> expected_evens = {0, 2, 6, 2, 4};
    ASSERT_EQUAL(TakeEvens(numbers), expected_evens);

    const vector<int> expected_positives = {1, 2, 6, 2, 4, 3};
    ASSERT_EQUAL(TakePositives(numbers), expected_positives);
}` 
```


Попытаемся скомпилировать код и увидим ошибку. Компилятор не знает, как вывести вектор целых чисел, передаваемый в функцию `AssertEqualImpl`:

Скопировать кодCPP

```cpp
`template <typename T, typename U>
void AssertEqualImpl(const T& t, const U& u, const string& t_str, const string& u_str, const string& file,
                     const string& func, unsigned line, const string& hint) {
    if (t != u) {
        ...
        **cout << t << " != "s << u << "."s;**
        ...
    }
}` 
```


Чтобы устранить ошибку компиляции, научите компилятор выводить в поток элементы контейнеров `vector`, `set` и `map` с содержимым произвольного типа.

# Работаем с cerr

Когда юнит-тесты написаны, важно знать, что они выполняются. Для этого добавим в код вывод сообщения об успешном завершении очередного теста:

Скопировать кодCPP
```cpp

`void TestAddingSynonymsIncreasesTheirCount() {
    ...
    cout << "TestAddingSynonymsIncreasesTheirCount OK"s << endl;
}

void TestAreSynonyms() {
    ...
    cout << "TestAreSynonyms OK"s << endl;
}

void TestSynonyms() {
    TestAddingSynonymsIncreasesTheirCount();
    TestAreSynonyms();
}

int main() {
    TestSynonyms();
    ...
}` 
```


Запустим программу и увидим: она вывела названия выполненных тестов и ожидает пользовательский ввод:

Скопировать код

`TestAddingSynonymsIncreasesTheirCount OK
TestAreSynonyms OK` 

Если отправим программу в таком виде в тестирующую систему, она не пройдёт автоматические проверки. Ведь вывод программы перемешался с выводом тестов, и выходные данные программы не совпадут с ожидаемыми. Можно всякий раз комментировать вывод названий тестов или убрать его совсем. Но есть способ лучше: мы можем доработать тесты так, чтобы диагностическая информация выводилась не в стандартный поток вывода, а в стандартный поток ошибок `cerr`.

`cerr` — один из трёх стандартных потоков. Он предназначен для вывода диагностической информации. Работа с `cerr` идентична работе с объектом `cout`.

По умолчанию поток `cerr` связан с выводом в консоль, но во время проверки приложения тестирующая система будет игнорировать вывод в поток ошибок.

Чтобы выводить диагностические сообщения в поток ошибок, заменим `cout` на `cerr` в функциях `AssertEqualImpl` и `AssertImpl`, а также в тестирующих функциях:

Скопировать кодCPP

```cpp
`template <typename T, typename U>
void AssertEqualImpl(const T& t, const U& u, const string& t_str, const string& u_str, const string& file,
                     const string& func, unsigned line, const string& hint) {
    if (t != u) {
        cerr << boolalpha;
        cerr << file << "("s << line << "): "s << func << ": "s;
        cerr << "ASSERT_EQUAL("s << t_str << ", "s << u_str << ") failed: "s;
        cerr << t << " != "s << u << "."s;
        if (!hint.empty()) {
            cerr << " Hint: "s << hint;
        }
        cerr << endl;
        abort();
    }
}` 
```


Скопировать кодCPP

```cpp
`void AssertImpl(bool value, const string& expr_str, const string& file, const string& func, unsigned line,
                const string& hint) {
    if (!value) {
        cerr << file << "("s << line << "): "s << func << ": "s;
        cerr << "Assert("s << expr_str << ") failed."s;
        if (!hint.empty()) {
            cerr << " Hint: "s << hint;
        }
        cerr << endl;
        abort();
    }
}` 
```


Скопировать кодCPP

```cpp
`void TestAddingSynonymsIncreasesTheirCount() {
    ...

    cerr << "TestAddingSynonymsIncreasesTheirCount OK"s << endl;
}

void TestAreSynonyms() {
    ...

    cerr << "TestAreSynonyms OK"s << endl;
}` 
```


Теперь диагностическая информация будет выводиться в поток ошибок.

Посмотрите на код, который выводит названия успешно пройденных тестов. Сразу бросается в глаза дублирование. Во-первых, в каждом тесте приходится писать однотипный код. Во-вторых, надо следить, чтобы выводимое имя теста совпадало с именем тестирующей функции. В задании вы разработаете шаблонную функцию и макрос и исправите недостатки.