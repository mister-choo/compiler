  
# Зачем сбрасывать буфер

Вместо того чтобы просто написать `\n` в конце литерала, для перевода строки используют `endl`. Разберёмся почему.


```cpp

#include <fstream>
#include <string>

using namespace std;

int main() {
    ofstream out_file("ballad.txt"s);
    for (int i = 0; i < 10; ++i) {
        out_file << "С любимыми не расставайтесь\n"s;
    }

    throw;
} 
```


Обратите внимание на `throw` в последней строке `main`. Эта конструкция вызывает аварийное завершение программы, которое сразу прекратит её выполнение, не дав выполнить код деинициализации. По идее, `throw` происходит уже после записи в файл, значит, повлиять на содержимое файла не может.

Запустим программу. Файл оказался пуст. Дело в том, что поток вывода оптимизирован: он использует тот факт, что 10 раз записать по одному символу на диск значительно медленнее, чем один раз записать 10 символов. Поэтому выведенный в поток текст вместо немедленной записи сохраняется в некоторое промежуточное хранилище и сбрасывается на диск только по мере наполнения этого хранилища либо в случае явной команды `flush`. Такая оптимизация называется буферизацией, а промежуточное хранилище — буфером.

Проверим на примере. Если увеличить количество строк с 10 до 10000, то буфера точно не хватит, и что-нибудь всё-таки попадёт в файл:

Скопировать код

`0001 С любимыми не расставайтесь
0002 С любимыми не расставайтесь
...
9924 С любимыми не расставайтесь
9925 С любимыми не расставайте` 

Если результат работы программы выглядит подобным образом, значит, гипотеза оказалась верна: в некоторый момент данные сбросились в файл, но часть всё равно оказалась незаписанной. А теперь заменим `\n` на `endl`:
```cpp
#include <fstream>
#include <string>

using namespace std;

int main() {
    ofstream out_file("ballad.txt"s);
    for (int i = 0; i < 10; ++i) {
        out_file << "С любимыми не расставайтесь"s << endl;
    }

    throw;
} 
```


Предположим, ваша задача — перевозить уголь из одного места в другое. Уголь поступает разными порциями — бывает и один уголёк, и целая тонна за раз. При поступлении каждой порции вы можете сразу опломбировать груз, вызвать локомотив и отправить вагон, а можете подождать, пока он наполнится, и только потом отправить. Вызов локомотива требует времени, и если делать это сразу, перевозка угля может затянуться. В итоге вы отправите 100 составов, перевозящих по одному угольку: 100 раз потратите время на пломбировку, прицепку вагона, хотя могли бы подождать, пока вагон наполнится, и сделать это только один раз. Потоки в C++ по умолчанию ждут, пока буфер — то есть вагон — наполнится, чтобы отправить сразу большое количество данных.

Сбрасывать буфер можно не в начале новой строки, а просто по желанию. Для этого используют манипулятор `std::flush` и функцию потока `flush`:


```cpp

#include <fstream>
#include <string>

using namespace std;

int main() {
    ofstream out_file("ballad.txt"s);
    for (int i = 0; i < 10; ++i) {
        // такой же эффект, как если бы мы написали endl
        out_file << "С любимыми не расставайтесь\n"s << flush;
    }

    throw;
} 

```

Как видим, `endl` — это вывод конца строки с одновременным сбросом буфера. Однако за всё нужно платить: сброс буфера снижает эффективность программы. Лучше избегать его, когда интерактивность вывода не требуется, но важна производительность.

Используйте `endl` при отладке или профилировке, если есть риск, что программа упадёт и не успеет выдать нужную информацию. В остальном `endl` и `\n` работают одинаково — ваша задача найти баланс между эффективностью и удобством.


# Связь потоков: в поисках оптимального ввода и вывода

В прошлом уроке вы узнали, что замена `endl` на `\n` улучшает эффективность. Посмотрим, всегда ли это происходит. Рассмотрим программу для возведения в квадрат чисел, прочитанных из стандартного ввода:


```cpp

#include <iostream>
#include <string>

#include "log_duration.h"

using namespace std;

// main с аргументами означает, что программа принимает аргументы командной строки,
// при запуске из консоли их количество будет сохранено в переменную argc,
// а значения — в argv.
// Тип const char** будет обсуждаться позже в курсе, работать с ним можно
// отчасти как с вектором: argv[0] — нулевой аргумент, argv[1] — первый. 
// argv[i] можно конвертировать в string
int main(int argc, const char** argv) {
    // Нулевой аргумент — это всегда имя программы,
    // поэтому нам нужен первый
    int arg = stoi(argv[1]);

    if (arg == 1) {
        LOG_DURATION("endl"s);
        int i;
        while (cin >> i) {
            cout << i * i << endl;
        }
    }

    if (arg == 2) {
        // Чтобы "\n" воспринималось не как перевод строки, а как 
        // слеш и буква 'n', добавим перед ним ещё один слеш:
        // два слеша в строковом (и символьном) литерале воспринимаются
        // как один (\) 
        LOG_DURATION("\\n"s);
        int i;
        while (cin >> i) {
            cout << i * i << "\n"s;
        }
    }
} 
```


Эта программа принимает один аргумент: число один или два. Она читает числа из стандартного ввода и выдаёт их квадраты в стандартный вывод, замеряя время. Причём метод завершения строки — `\n` или `endl` — можно менять, используя аргумент командной строки. Скомпилируем программу, назвав исполняемый файл `sqnums`. Запустим её так:
```bash

$ sqnums 1 

```

Она будет радостно выводить квадраты всех введённых чисел до тех пор, пока вы не введёте символ конца файла. Затем выведет общее время работы и при этом будет использовать `endl`. Запустим программу иначе:

```bash

$ sqnums 2 

```

Тут вместо `endl` будет простой `\n`.

Для запуска программы возьмём файл numbers.txt, который содержит 50000 чисел от 0 до 100. Запускать будем, перенаправляя стандартный ввод и вывод:
```bash

$ sqnums 1 >numbers2.txt <numbers.txt 

```

Перенаправление символами `>` и `<` позволяет проассоциировать потоки `cin` и `cout` с файлами. Так программа будет читать из `cin`, а на самом деле получать данные из файла `numbers.txt`. Благодаря `>` данные из `cout` пойдут в файл `numbers2.txt`, а не в окно консоли. Если хотим использовать `\n`, меняем параметр `1` на `2`:

```bash

$ sqnums 2 >numbers2.txt <numbers.txt 

```

Смотрим на результаты:

```bash

$ sqnums 1 <numbers.txt >numbers2.txt
endl: 410 ms
$ sqnums 2 <numbers.txt >numbers2.txt
\n: 408 ms 
```


Не столь впечатляюще. Раньше мы наблюдали чуть не десятикратное различие, а теперь оно едва заметно. Чтобы понять причину этого, обратимся к другой программе:


```cpp

#include <iostream>

using namespace std;

int main() {
    cout << "Enter x and y: "s;
    cin >> x >> y;
    cout << x + y << endl;
} 
```


Совсем не очевидно, но чтение из `cin` заставляет буфер `cout` и `cerr` опустошаться, как если бы мы добавили `cout.flush()` перед ним. В этом причина медленной работы программы с `\n`. К счастью, есть способ исправить ситуацию, отвязав `cin` от `cout` так: `cin.tie(nullptr);`.

Дополним программу ещё одной веткой и протестируем скорость:



```cpp
#include <iostream>
#include <string>

#include "log_duration.h"

using namespace std;

int main(int argc, const char** argv) {
    // не забываем, что один аргумент — это название программы,
    // поэтому argc должно быть как минимум 2
    if (argc < 2) {
        cerr << "Пожалуйста, задайте как минимум 1 аргумент"s << endl;
        return 1;
    }

    int arg = std::stoi(argv[1]);

    if (arg == 1) {
        LOG_DURATION("endl"s);
        int i;
        while (cin >> i) {
            cout << i * i << endl;
        }
    }

    if (arg == 2) {
        LOG_DURATION("\\n"s);
        int i;
        while (cin >> i) {
            cout << i * i << "\n"s;
        }
    }

    if (arg == 3) {
        LOG_DURATION("\\n with tie"s);
        cin.tie(nullptr);
        int i;
        while (cin >> i) {
            cout << i * i << "\n"s;
        }
    }
} 
```


Запускаем:

```bash

$ test-stream.exe 3 <numbers.txt >numbers2.txt
\n with tie: 89 ms 

```

Совсем другое дело! Однако будьте осторожны, потому что отвязывание `cin` от `cout` повлияет на всё последующее выполнение. Если разрабатываете основную функцию программы, это не так важно. Но если подобное происходит в функции библиотеки, которая будет применяться в разных программах, такой побочный эффект крайне нежелателен. Избежать его просто — в конце работы привяжите обратно:


```cpp

...
if (arg == 3) {
    LOG_DURATION("\\n with tie"s);
    auto tied_before = cin.tie(nullptr);

    int i;
    while (cin >> i) {
        cout << i * i << "\n"s;
    }

    cin.tie(tied_before);
}
... 
```


Чтобы избежать возможных нюансов, используйте для этих целей класс с конструктором и деструктором для выполнения парных действий. В прошлой теме вы так измеряли время.

В этом уроке вы убедились: замена `endl` на `\n` серьёзно ускоряет использование потоков, если это критичное место вашей программы.

Ещё сильнее ускорить ввод и вывод в `cin` и `cout` может магическая команда `ios_base::sync_with_stdio(false)`, с которой хорошо знакомы участники соревнований по программированию. Использовать её следует осторожно. Эта команда способна помешать работе при подключении сторонних библиотек, выводящих информацию в стандартный вывод, и при многопоточной работе, с которой вы ещё познакомитесь.

Команда `sync_with_stdio` отключает синхронизацию между стандартными потоками C и C++, сохраняя ресурсы, а также между разными потоками выполнения.

Не путайте потоки ввода и вывода `stream` и потоки выполнения `thread`:

-   потоки ввода и вывода передают данные между произвольным источником `source` и потребителем `sink`;
-   потоки выполнения служат для одновременного выполнения нескольких операций в программе либо для ускорения задачи за счёт выполнения на разных ядрах процессора. Термины «многопоточный», «потокобезопасный» относятся всегда к потокам выполнения.









