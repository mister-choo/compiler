# Логические операции: сравнение

Сравнение — простейшая логическая операция. Так называют операции, результат которых равен `true` или `false`.

Чтобы сравнить целые числа, в C++ применяют операторы:

-   `==` (равно),
-   `!=` (неравно),
-   `<` (меньше),
-   `<=` (меньше или равно),
-   `>` (больше),
-   `>=` (больше или равно).

Например, эта программа сравнивает переменные `a` и `b`:

Скопировать кодCPP

`#include <iostream>
using namespace std;

int main() {
    int a = 3;
    int b = 5;
    if (a < b) {
        cout << "a is less than b"s << endl;
    }
}` 

Целые числа можно сравнивать с вещественными:

Скопировать кодCPP

`int x = 1;
double y = 1.2;
x < 1;
y >= 2.5;
x == y; // сравнить int и double — не проблема` 

Сравнивать строки сложнее. Укажите, что переменные `a` и `b` относятся к типу `string`. Запишите в переменную `a` слово “fire”, а в переменную `b` — “water”:

Скопировать кодCPP

`#include <iostream>
#include <string>
using namespace std;

int main() {
    string a = "fire"s;
    string b = "water"s;
    if (a < b) {
        cout << "a is less than b"s << endl;
    }
}` 

На экране появится сообщение “`a` is less than `b`”. Дело в том, что строки в C++ сравниваются лексикографически. То есть строка `a` меньше строки `b`, потому что буква “f“ стоит в английском алфавите раньше буквы “w“.

Если в переменную `b` зашифровать слово “fog”, строка `a` всё равно будет меньше строки `b`. Первые буквы в словах “fire” и “fog” совпадают. Значит, нужно смотреть на вторые: буква “i” в алфавите опережает “o”.

Операторами сравнения сравнивают все встроенные типы С++. Никакие специальные функции не нужны. Посмотрите на пример выше: и строки, и числа сравнивает оператор `<`, хотя строки — более сложные объекты.

Главное, не забывать писать строковые литералы в формате `"fire"s`. Например, понятно, чего ждать от такого кода:

Скопировать кодCPP

`if ("fire"s < "bar"s) {
    // никогда не выполнится
}` 

А у такого результат непредсказуем и зависит от компилятора:

Скопировать кодCPP

`if ("fire" < "bar") {
    // может выполниться, а может и нет
}` 

Результат сравнения и других логических операций относят к типу данных `bool`. Этот тип ещё называется логическим или булевым. У переменных типа `bool` два возможных значения — `true` и `false`. Например, логическая операция `a < b` сравнивает две переменные и возвращает `true`, если `a` меньше `b`.

Булевые переменные объявляют так:

Скопировать кодCPP

`double x;
int y;
cin >> x >> y;
bool lt = (x < y);` 

Литералы `bool` — это `true` или `false`.

Тройных сравнений в C++ не бывает. Например, в таком выражении будут происходить очень странные дела:

Скопировать кодCPP

`5 > 4 > 3; // (5 > 4) > 3, т.е. true > 3, т.е. 1 > 3, т.е. false` 

Зато выражения типа `bool` сравнивают между собой и с числами.

Булевые значения обрабатываются в виде целых чисел и выводятся на экран цифрами. Вместо `false` выводится ноль, а вместо `true` — единица:

Скопировать кодCPP

`cout << true << endl // 1
     << false << endl; // 0` 

Если всё же хотите вывести значение словами, включите режим `boolalpha`. Чтобы отключить `boolalpha`, напишите `noboolalpha`:

Скопировать кодCPP

`cout << boolalpha
     << true << endl // true
     << false << endl // false
     << noboolalpha
     << true << endl // 1
     << false << endl; // 0` 

Ввод работает аналогично:

Скопировать кодCPP

`bool x, y;
cin >> boolalpha
    >> x // принимает true или false
    >> noboolalpha // режим по умолчанию
    >> y; // принимает любое число, считает его true, если оно не равно нулю` 

Но если оператору `cin` попались символы, которые он не может превратить в `bool`, он останавливает считывание и записывает в переменную ноль, то есть `false`.

Из-за того, что `false` обрабатывается как ноль, а `true` как единица, для логических выражений действует неявное преобразование типов:

Скопировать кодCPP

`int x = true; // 1
bool y = 0.0; // false`