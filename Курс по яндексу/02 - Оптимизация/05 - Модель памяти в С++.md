# Хранение объектов в памяти

C++ — язык программирования высокого уровня, позволяющий создавать программы для разных программно-аппаратных платформ — от микроконтроллеров и мобильных телефонов до суперкомпьютеров.

Архитектурные различия между этими платформами значительны: набор инструкций процессора, устройство памяти, организация ввода-вывода с внешними устройствами. Компилятор берёт на себя заботу о том, как преобразовать программу в машинный код для целевой платформы, а стандартная библиотека предоставляет надёжные компоненты, подходящие для решения повседневных задач.

Сильная сторона C++ в том, что, когда стандартные решения не подходят, язык даёт вам возможность «спуститься» на более низкий уровень, ближе к железу, чтобы оптимально распорядиться ресурсами компьютера.

### Модель памяти C++

Один из таких ресурсов — память, которая используется для хранения кода программы и обработки её данных. Чтобы код на C++ мог выполняться на разных программно-аппаратных платформах, язык предоставляет программисту модель памяти __**__— абстракцию, скрывающую особенности работы с памятью на конкретной платформе.

С точки зрения C++ память компьютера состоит из одной или нескольких непрерывных последовательностей ячеек. Эти ячейки называются байтами.

Байт — минимальная адресуемая единица памяти. В большинстве современных компьютеров каждый байт состоит из восьми двоичных разрядов, называемых битами, что позволяет ему принимать 2^8=25628=256 различных значений. Каждый байт в памяти имеет уникальный адрес — числовое значение, задающее его местоположение в памяти.

![image](https://pictures.s3.yandex.net/resources/address_space_1_1623162607.png)_Схематичное представление памяти программы. В ячейке с адресом `0x400018` находится байт со значением `42`. Значения остальных ячеек памяти для примера не важны, поэтому на рисунке их нет_

Префикс `0x` говорит о том, что целое число записано в шестнадцатеричной системе счисления. Эта система счисления часто используется для записи адресов, так как «круглые» числа в ней — это степени числа 16, которые также можно представить как степени двойки.

### Объекты в памяти

Программы на C++ не манипулируют содержимым ячеек памяти напрямую. Вместо этого они работают с объектами — создают, разрушают их, считывают и модифицируют состояние объектов. В данной теме под термином «объект» будем по умолчанию подразумевать понятие не из объектно-ориентированного программирования, а более абстрактное. Объектом _**_в C++ называется регион в памяти, который обладает такими свойствами:

-   **Размер в байтах**. Типы `char`, `unsigned char`, `int8_t`, `uint8_t` и `std::byte` занимают ровно один байт памяти, а другие типы могут требовать несколько байтов. Например, значение типа `int` в программах, компилируемых для 32-разрядных процессоров, может занимать в памяти четыре байта, а для 16-разрядных — два. Узнать, сколько байтов занимает тип или переменная, позволяет операция `sizeof`.
-   **Требования к выравниванию в памяти**. Выравнивание — степень двойки, число, равное количеству байтов между адресами, по которым могут размещаться объекты данного типа. Операция `alignof` возвращает значение выравнивания для заданного типа на целевой платформе. В общем случае оно может отличаться от размера объекта, возвращаемого `sizeof` как в меньшую, так и в большую сторону.
-   **Тип**. Позволяет программе правильно работать с областью памяти, которую объект занимает. Например, несмотря на то, что размеры типов `float` и `int` могут совпадать, для работы с ними компилятор генерирует различающийся машинный код.
-   **Значение**, которое определяется содержимым области памяти, занимаемой объектом. Значение может быть неопределённым — например, при объявлении неинициализированной локальной переменной примитивного типа данных, такого как `int` или `char`.
-   **Продолжительность времени жизни**. Например, время жизни локальных переменных ограничено блоком, внутри которого они объявлены, а глобальных переменных — продолжительностью работы программы.
-   Опциональное **имя**. Имя позволяет обращаться к объекту в программе. Простейший пример — имя переменной. Имя может отсутствовать у временного объекта, который создают как промежуточный результат вычислений. Один объект может быть доступен по нескольким именам. Так, например, ссылка создаст ещё одно имя для уже существующего объекта.

На рисунке ниже — четыре объекта в памяти программы: переменная `p` типа `Point`, целое число `age`, переменная `weight` типа `double` и неинициализированная переменная `year` типа `int16_t`. Ссылка на объект `p` позволяет обратиться к нему по альтернативному имени `p_ref`.

![image](https://pictures.s3.yandex.net/resources/objects_in_memory_2_1623162685.png)_Пример расположения объектов различных типов в памяти. Ссылка `p_ref` указывает на объект переменной `p`_

Каждый из этих объектов имеет представление в памяти, специфичное для некоторой платформы. Компилятор отвечает за корректное чтение и запись значений объектов в память.

Посмотрите на иллюстрацию и определите, какие данные располагаются по адресу 0x0000000000400028.

Целое число 12, четыре байта.

Целое число 18, четыре байта.

Целое число 18, восемь байт.

Число с плавающей точкой 75.3, четыре байта.

Число с плавающей точкой 75.3, восемь байт.

Никакие — пустое пространство.

Следующая программа выводит размеры и величину выравнивания для некоторых стандартных и пользовательских типов на целевой платформе:


```cpp

#include <cstddef>  // cstddef необходим для использования std::byte
#include <cstdint>  // cstdint необходим для использования uint32_t и int64_t
#include <iostream>

using namespace std;

struct Sportsman {
    int id;
    double height;
};

int main() {
    cout << "char: size="s << sizeof(char) << ", alignment="s << alignof(char) << endl;
    cout << "int: size="s << sizeof(int) << ", alignment="s << alignof(int) << endl;
    cout << "double: size="s << sizeof(double) << ", alignment="s << alignof(double) << endl;
    cout << "Sportsman: size="s << sizeof(Sportsman) << ", alignment="s << alignof(Sportsman) << endl;

    return 0;
} 

```

На разных платформах размеры и требования к выравниванию данных могут отличаться. Например, скомпилированная для 64-разрядной ОС Windows программа выводит следующие значения:
```cpp



char: size=1, alignment=1
int: size=4, alignment=4
double: size=8, alignment=8
Sportsman: size=16, alignment=8 

```

Размер структуры `Sportsman` получился больше суммарного размера её полей — компилятор добавил пустое пространство внутри структуры, чтобы её поля располагались по выровненным адресам, а размер структуры был кратен величине её выравнивания.

Сколько объектов создаётся внутри функции `main` этой программы? Выберите один верный ответ.


```cpp

int main() {
    int x = 0;
    double n = 5;
    int& r = x;
} 

```

Один

Новые объекты создаёт объявление переменных `x` и `y`. А вот ссылка `r` этого не делает, она лишь альтернативный способ доступа к значению переменной `x`.

Два

Верно. Объявление переменных `x` и `n` создаёт новые объекты. Ссылка `r` этого не делает, она лишь альтернативный способ доступа к значению переменной `x`.

Три

Только объявление переменных `x` и `n` создаёт новые объекты. Ссылка `r` этого не делает, она лишь альтернативный способ доступа к значению переменной `x`.

Ни одного

Объекты здесь есть, они создаются при объявлении переменных `x` и `n`.

Модель памяти — абстракция. C++ вводит её, чтобы описать действия оперативной памяти без привязки к конкретной программно-аппаратной платформе.

Данные, с которыми работает программа, представляются в виде объектов — областей памяти компьютера. У этих областей есть тип, значение, размер и требования к выравниванию.

В следующем уроке вы познакомитесь с указателями — ключиком, открывающим вам низкоуровневый доступ к памяти компьютера.

# Указатели. Открываем доступ к памяти

В прошлом уроке вы узнали об устройстве памяти компьютера и о том, как в ней представляются объекты, с которыми работает ваша программа. Сегодня познакомитесь с указателями — средством языка, открывающим доступ к памяти компьютера.

Указатель — переменная, которая хранит адрес объекта в памяти программы. Это как лист бумаги с адресом. Зная адрес своего друга, вы можете его навестить. Точно так же можно обратиться к объекту при наличии указателя на него.

Указатели объявляются подобно обычным переменным, только с использованием символа «звёздочка» `*` после типа. Например, так выглядит указатель, способный хранить адрес объекта типа `int`:


```cpp

int* p; 

```

Переменная `p` может хранить адрес целого числа. Так как переменная-указатель `p` не инициализирована, использовать её для доступа к объекту нельзя. Объявление указателя выделяет память для хранения адреса, но не инициализирует эту область памяти.

Размер указателей равен размеру адреса на конкретной платформе и не зависит от размера самих объектов. Рассмотрим пример:


```cpp

#include <iostream>
#include <map>
#include <string>

struct Vector3D {
    double x;
    double y;
    double z;
};

int main() {
    using namespace std;

    map<string, string>* string_to_string;

    cout << "char*: size:"s << sizeof(char*) << endl;
    cout << "int*: size:"s << sizeof(int*) << endl;
    cout << "double*: size:"s << sizeof(double*) << endl;
    cout << "Vector3D*: size:"s << sizeof(Vector3D*) << endl;
    cout << "map<string, string>*: size:"s << sizeof(string_to_string) << endl;
} 

```

Типичный размер и выравнивание указателя на 32-битной платформе равны четырём байтам, а на 64-разрядной — восьми. Вывод программы на 64-битной платформе:


```cpp

char*: size:8
int*: size:8
double*: size:8
Vector3D*: size:8
map<string, string>*: size:8 


```


Вывод программы на 32-битной платформе:

```cpp


char*: size:4
int*: size:4
double*: size:4
Vector3D*: size:4
map<string, string>*: size:4 

```

### Инициализация указателя и получение адреса объекта

Чтобы использовать указатель, нужно присвоить ему адрес существующего объекта. Для получения адреса есть специальная унарная операция — `&`. Её называют операцией взятия адреса. Она применяется к объекту, адрес которого вы хотите получить, и возвращает адрес этого объекта:


```cpp

int value = 42;
int* value_ptr;  // Указатель value_ptr ещё не инициализирован 
value_ptr = &value;
// Теперь в value_ptr хранится адрес переменной value 

```

Если присвоить указателю `value_ptr` результат выражения `&value`, указатель будет содержать адрес ячейки памяти, где располагается переменная `value`.

![image](https://pictures.s3.yandex.net/resources/pointer_declaration_1623765171.png)_Так можно представить в памяти переменную `value` и указатель `value_ptr`. Адреса ячеек памяти приведены для примера._

Указателю можно присвоить только адрес объекта совместимого типа. Так, присвоить адрес переменной типа `double` указателю на тип `int` нельзя:


```cpp

int int_value = 42;
double double_value = 1.2345;

int* ptr;
// Следующая строка не скомпилируется,
// так как по адресу &double_value располагается объект типа double
ptr = &double_value; // error: cannot convert 'double*' to 'int*' in assignment 

```

Объявление указателя лучше объединить с его инициализацией — так запись короче, и неинициализированных указателей в программе не будет:


```cpp

int value = 42;
int* value_ptr = &value; 

```

Операцию взятия адреса можно применять не только к отдельным переменным, но и к полям структур и классов:


```cpp

#include <string>

using namespace std;

struct Point {
    double x;
    double y;
};

int main() {
    Point p;
    // y_ptr хранит адрес координаты Y точки p
    double* y_ptr = &p.y;
} 

```

Указатель `y_ptr` имеет тип `double*` и ссылается на поле `y` точки `p`:

![image](https://pictures.s3.yandex.net/resources/pointer_to_objects_1623765234.png)

В C++ ссылки — не объекты. Они вводят новое имя для доступа к уже существующему объекту. Поэтому оператор `&`, применённый к ссылке, возвращает не указатель на ссылку, а указатель на сам объект:


```cpp

int main() {
    int answer = 42;
    int& answer_ref = answer;

    // answer_ptr хранит адрес переменной answer
    int* answer_ptr = &answer_ref;
} 

```

И переменная `answer`, и ссылка `answer_ref` относятся к одному и тому же объекту. Поэтому взятие адреса ссылки равнозначно взятию адреса объекта:

![image](https://pictures.s3.yandex.net/resources/pointer_to_reference_1623765530.png)_Указатель `answer_ptr` хранит адрес переменной answer. На `answer` также ссылается ссылка `answer_ref`_

### Вывод указателя в поток

Операция `<<` может вывести в поток значение указателя.


```cpp

#include <iostream>
#include <string>

using namespace std;

int main() {
    int value = 42;
    int* value_ptr = &value;
    cout << "value_ptr: "s << value_ptr << endl;
} 
```


Формат вывода адреса зависит от компилятора и платформы. Примеры:

-   Linux для архитектуры x64, компилятор GCC

```cpp


value_ptr: 0x7ffd6596006c 

```

-   Windows для архитектуры x86, компилятор Microsoft Visual C++ 2019


```cpp

value_ptr: 00EFF930 

```

### Нулевой указатель

Неинициализированный указатель содержит неопределённое значение. Использовать такой указатель для доступа к объекту нельзя, поведение программы будет неопределённым, как и значение указателя. Также нет смысла сравнивать этот указатель с другими — в общем случае отличить значение неинициализированного указателя от инициализированного невозможно.

Инициализируйте указатель при его объявлении: присвойте ему адрес существующего объекта совместимого типа или специальное значение `nullptr` — нулевой указатель.

Нулевой указатель хранит значение `nullptr`. C++ гарантирует, что по адресу `nullptr` не будет размещаться ни один объект программы. Поэтому перед использованием указателя вы сможете определить, есть ли в нём адрес существующего объекта. Для этого сравните указатель со значением `nullptr`:


```cpp

#include <cassert>
#include <iostream>

int main() {
    using namespace std;

    int* p = nullptr;

    //------
    // Пример кода, который может записать в p адрес существующего объекта,
    // или оставить указатель равным nullptr
    int value = 0;
    cin >> value;
    if (value >= 0) {
        p = &value;
    }
    //------

    cout << "p: "s << p << endl;

    if (p != nullptr) {
        assert(p == &value);
        cout << "p is not nullptr"s << endl;
        // Можно использовать указатель p для доступа к объекту
    }

    // Аналогично условию p != nullptr
    if (p) {
        assert(p != nullptr);

        // Можно использовать указатель p для доступа к объекту
    }

    if (!p) {
        assert(p == nullptr);
        cout << "p is nullptr"s << endl;
        // Указатель p равен nullptr. Использовать его для доступа к объекту нельзя
    }
} 

```

Как видно из примера, условие `p != nullptr` можно сократить до `p`, а `p == nullptr` до `!p`. Так указатели конвертируются в `bool`.

💡 Указатели разных типов нельзя сравнивать между собой. Исключение — указатель типа `void*`, который ничего не говорит о данных, расположенных по адресу, который он хранит. Также любой указатель можно сравнивать с `nullptr`. Это допустимо благодаря тому, что `nullptr` — не указатель, он имеет специальный тип — `nullptr_t`.

### Разыменование указателя

Чтобы получить доступ к объекту в C++, используют унарную операцию разыменования указателя. Она обозначается символом `*`. Эта операция выполняет обратное действие. Если её применить к указателю, она вернёт ссылку на объект, адрес которого хранит указатель. Доступ к объекту посредством указателя ещё называют косвенным доступом. Рассмотрим, как указатели дают доступ к переменной:


```cpp

#include <cassert>

using namespace std;

int main() {
    int value = 1;

    // Указатель value_ptr1, ссылающийся на переменную value
    int* value_ptr1 = &value;
    // Указатель value_ptr2, копия указателя value_ptr1, также ссылается на переменную value
    int* value_ptr2 = value_ptr1;

    // Значения указателей на один и тот же объект будут равны
    assert(value_ptr1 == value_ptr2);

    // Значение объекта value, полученное напрямую и через указатель на него, будет одно и то же
    assert(*value_ptr1 == value && *value_ptr2 == value);

    // Изменение value видно через указатели на него
    value = 2;
    assert(*value_ptr1 == value && *value_ptr2 == value);

    // Изменяем значение value через указатель
    *value_ptr2 = 3;

    // Ожидаемо изменённое значение будет видно как при прямом доступе к объекту по его имени,
    // так и при косвенном обращении через указатель value_ptr1
    assert(*value_ptr1 == value && *value_ptr2 == value);
} 

```

В программе создаются переменная `value` и два указателя `value_ptr1` и `value_ptr2`, ссылающиеся на неё. Доступ к значению `value` можно получить как напрямую по имени самой переменной, так и косвенно — разыменовать любой из указателей на неё.

![image](https://pictures.s3.yandex.net/resources/pointer_dereference_1623765587.png)_Значение `value` можно получить, разыменовав любой из указателей `value_ptr1` и `value_ptr2`_

Если у вас есть указатель на объект класса или структуры, можно обратиться к его полям и методам через операцию `->`. Она автоматически разыменовывает указатель:


```cpp

#include <cassert>
#include <string>

int main() {
    using namespace std;

    string practicum = "Practicum"s;

    string* paracticum_ptr = &practicum;

    // Прежде чем обратиться к методу length, разыменуем указатель
    assert((*paracticum_ptr).length() == 9);

    // Также обращение к полям и методам структур и классов
    // доступно при помощи операции ->
    assert(paracticum_ptr->substr(2, 3) == "act"s);
} 

```

Операцию разыменования `*` и операцию доступа к полям и методов `->` можно применять только к указателям, которые хранят адрес существующего объекта в памяти. Использовать их с неинициализированным или нулевым указателем нельзя — это приведёт к неопределённому поведению. Прежде чем применять указатель, который может потенциально иметь нулевое значение, сделайте проверку на равенство `nullptr`:


```cpp

#include <cassert>
#include <iostream>

int main() {
    using namespace std;

    int* p = nullptr;

    //------
    int value = 0;
    cin >> value;
    if (value >= 0) {
        p = &value;
    }
    //------

    if (p != nullptr) {
        // Использовать p можно
        cout << *p << endl;
    }
} 

```

В этом уроке вы познакомились с указателями — объектами, способными хранить адреса других объектов. Избегайте неинициализированных указателей. Они — источник трудноуловимых ошибок.


# Указатели и константность

В прошлом уроке вы познакомились с указателями — переменными, хранящими адреса объектов в памяти. Операция `&` позволяет взять адрес объекта и сохранить его в переменную-указатель. В нужный момент вы разыменовываете этот указатель операцией `*`, чтобы прочитать или изменить состояние объекта.

Переменные в C++ можно объявить константными, чтобы защитить их значения от непреднамеренной модификации. При попытке изменить константную переменную компилятор выдаст ошибку.

### Указатель на константу

Свойство константности сохраняется и при взятии адреса объекта. Операция `&` возвращает указатель на константный объект — его ещё называют указателем на константу. Такой указатель разрешает читать значение объекта, но не модифицировать его:


```cpp

#include <cassert>

int main() {
    const int value = 42;

    // Ошибка: неконстантная ссылка не может ссылаться на константный объект
    // int& value_ref = value;

    // А вот так можно
    const int& const_value_ref = value;
    
    // Ошибка: указатель на неконстантное значение не может хранить адрес константного объекта
    // int* value_ptr = &value;

    // Указатель на константу типа int.
    const int* const_value_ptr = &value;
    // можно также объявить как int const* - это одно и то же

    // Указатель на константу можно использовать только для чтения значения объекта
    assert(*const_value_ptr == 42);
    // Выполнить модификацию объекта с его помощью нельзя.
    // Следующая строка не скомпилируется:
    // *const_value_ptr = 43;
} 

```

Здесь компилятор не разрешает задать указателю типа `int*` значение адреса константного объекта. Такой указатель позволил бы изменить состояние объекта. В этом плане указатели на константу похожи на константные ссылки.

![image](https://pictures.s3.yandex.net/resources/pointer_to_const_1_1628261029.png)_Указатель на неизменяемое значение типа `const int`_

Указатель на константу может хранить адрес неконстантного объекта и таким образом предоставить доступ к объекту только для чтения. В этом случае указатель на константу ведёт себя подобно константой ссылке.

Константные ссылки и указатели на константу запрещают модифицировать объект, только если вы используете именно их. Изменять значение объекта иным способом можно.


```cpp

#include <cassert>

int main() {
    int value = 42;

    // Указатель на константу может хранить адрес неконстантного объекта
    const int* const_value_ptr = &value;

    // Константная ссылка может ссылаться на неконстантный объект
    const int& const_value_ref = value;

    value = 43;

    // Константные ссылки и указатели на константу означают, что
    // через них нельзя изменить значение объекта. Само значение 
    // может быть изменено иным способом.
    assert(const_value_ref == 43);
    assert(*const_value_ptr == 43);
} 

```

В этой программе доступ к переменной `value` через указатель `const_value_ptr` разрешается только для чтения. Саму переменную `value` можно изменять как обычно.

![image](https://pictures.s3.yandex.net/resources/pointer_to_const_2_1628261032.png)_Указатель типа `const int`_`*` указывает на изменяемое значение типа `int`. Изменение через указатель невозможно*

### Изменение значения указателя

В отличие от ссылок, указатели могут в процессе жизни менять своё значение, храня в разные моменты времени адреса разных объектов. Простейший способ изменить значение указателя — присвоить ему адрес другого объекта:


```cpp

#include <cassert>
#include <iostream>
#include <string>

using namespace std;

int main() {
    int value = 1;

    // Сначала value_ptr ссылается на value
    int* value_ptr = &value;

    cout << "&value: "s << &value << endl;
    cout << "value_ptr: "s << value_ptr << endl;
    assert(*value_ptr == 1);

    int another_value = 2;
    // Затем ссылается на another_value
    value_ptr = &another_value;

    cout << "&another_value: "s << &another_value << endl;
    cout << "value_ptr: "s << value_ptr << endl;
    assert(*value_ptr == 2);
} 

```

Возможный вывод этой программы:


```cpp

&value: 00000031D55AFC20
value_ptr: 00000031D55AFC20
&another_value: 00000031D55AFC24
value_ptr: 00000031D55AFC24 

```

Указатель на константу сам константой не будет и может в любой момент начать ссылаться на другой объект:


```cpp

#include <cassert>
#include <iostream>
#include <string>

using namespace std;

int main() {
    int value = 1;

    // Указатель на константу. Само значение указателя константным не является.
    const int* value_ptr = &value;
    assert(*value_ptr == 1);

    int another_value = 2;

    // Можно присвоить указателю адрес другого объекта.
    value_ptr = &another_value;
    assert(*value_ptr == 2);
} 

```

![image](https://pictures.s3.yandex.net/resources/pointer_to_const_3_1628261034.png)_Два значения типа `int` и указатель типа `const int`_`*`, указывающий на одно из них*

### Константные указатели

Константным может быть не только объект, на который ссылается указатель, но и сам указатель. Значение константного указателя нельзя изменить после инициализации. Чтобы объявить такой указатель, поставьте `const` справа от знака `*`. Как и обычная константа, константный указатель должен быть инициализирован при объявлении:


```cpp

int value = 42;
int* const const_ptr_to_value = &value;

int another_value = 5;
// Ошибка: нельзя изменить значение константного указателя
// const_ptr_to_value = &another_value; 

```

![image](https://pictures.s3.yandex.net/resources/pointer_to_const_4_1628261037.png)_Неизменяемый указатель, указывающий на изменяемое значение_

### Константные указатели на константу

Как вы могли догадаться, константными могут быть как сам указатель, так и данные, на которые он ссылается. В этом случае разместите ключевое слово `const` с обеих сторон от символа `*`:


```cpp

int value = 42;
const int* const const_ptr_to_const_value = &value;

int another_value = 5;
// Ошибка: нельзя изменить значение константного указателя:
// const_ptr_to_const_value = &another_value;

// Ошибка: нельзя изменить значение данных через указатель:
// *const_ptr_to_const_value = 0; 

```

![image](https://pictures.s3.yandex.net/resources/pointer_to_const_5_1628261040.png)_Неизменяемый указатель, указывающий на неизменяемое значение_

📖 В типе `int*` слово `const` можно написать не в двух, а в трёх местах: `const int*`, `int* const` и `int const *`. Первый и последний вариант эквивалентны — это указатели на тип `const int`, который допустимо записывать как `int const`. Мы будем пользоваться только первым вариантом, но при чтении чужого кода может встретиться и второй.

### Определение типа указателя

Есть простое мнемоническое правило, которое позволяет запомнить, к чему относится `const` в типе указателя. Для этого прочитайте объявление указателя **справа налево**, заменяя символ `*` на слово «указатель». Например:

### Указатели и константность — итоги

Указатели на константу нужны, чтобы хранить адрес константного объекта и ограничивать доступ к неконстантным объектам. Сам указатель также может быть константным — в этом случае адрес, хранящийся в нём, нельзя менять после инициализации.


# Статическое и автоматическое размещение объектов в памяти

Память для программ на языке C++ можно разделить на несколько независимых областей:

-   для объектов со статическим временем жизни;
-   для объектов с автоматическим временем жизни;
-   для объектов с динамическим временем жизни;
-   для объектов в локальной памяти потока. В рамках этой темы память потока рассматривать не будем.

Как правило, объекты с разным временем жизни размещаются в разных частях адресного пространства. Такой подход помогает эффективнее использовать доступную память. Вы указываете, как должен храниться объект, а компилятор и среда выполнения отвечают за его размещение в памяти.

![image](https://pictures.s3.yandex.net/resources/Object_layouts_in_memory_1_1623162795.png)_Один из способов распределить адресное пространство программы_

Области памяти для объектов с автоматическим и динамическим временем жизни «растут» навстречу друг другу, а размер области для объектов со статическим временем жизни остаётся постоянным.

### Память для объектов со статическим временем жизни

Статическим временем жизни обладают глобальные переменные и локальные статические переменные функций. Область памяти для их хранения выделяется при старте программы и освобождается при её завершении:


```cpp

#include <iostream>

using namespace std;

int value = 0;

void Fn() {
    // Глобальная переменная value существует в единственном экземпляре.
    // Адрес переменной value будет тот же, какой был получен в функции main
    cout << "Fn(): &value="s << &value << endl;
    value = 1;
}

int main() {
    cout << "main(): &value="s << &value << endl;
    cout << "value="s << value << endl;
    Fn();
    // Функция Fn изменила значение переменной value. Это изменение будет
    // видно и в функции main
    cout << "value="s << value << endl;
} 

```

Скопируйте код в свою IDE и запустите. Возможный вывод программы:


```cpp

main(): &value=00007FF68C874150
value=0
Fn(): &value=00007FF68C874150
value=1 

```

Так как переменная `value` — глобальная, её адрес остаётся неизменным на протяжении всей работы программы. Любая функция может изменить значение `value` и повлиять тем самым на работу остальных функций, которые используют эту глобальную переменную.

### Автоматическое выделение памяти для хранения объектов

Память для хранения объекта автоматически выделяется при входе в блок, где этот объект объявлен, и освобождается при выходе из блока. Такой способ выделения памяти используют локальные переменные и аргументы функций.

Стандарт C++ не оговаривает, как должно происходить автоматическое выделение памяти для локальных переменных. Распространённые компиляторы хранят локальные переменные в области памяти, где располагается стек вызовов функций.

При входе в функцию программа выделяет кадр стека — блок памяти, способный вместить все локальные переменные текущей функции. При выходе из функции этот кадр удаляется.

![image](https://pictures.s3.yandex.net/resources/Object_layouts_in_memory_2_1623162869.png)_Кадры стека вызовов функций `main`→`Func1`→`Func2`_

Работу автоматического выделения памяти можно увидеть на примере функции `Factorial` для рекурсивного вычисления факториала. При каждом вызове она выводит адрес параметра `n`. Параметры функции выделяются в автоматической области памяти. Так вы можете проследить адрес этой области при каждом вызове функции:


```cpp

#include <iostream>

using namespace std;

// Функция для рекурсивного вычисления факториала:
// 0! = 1
// n! = n*(n-1)!
int Factorial(int n) {
    cout << "  Factorial("s << n << "): &n="s << &n << endl;
    return n > 0 ? n * Factorial(n - 1) : 1;
}

int main() {
    for (int i = 0; i < 4; ++i) {
        cout << "=== Calculating factorial of "s << i << " ==="s << endl;
        int f = Factorial(i);
        cout << "Result is: "s << f << endl << endl;
    }
} 
```


Скопируйте код себе. Скомпилируйте и запустите его. Цифры зависят от вашего компилятора и операционной системы, поэтому могут получиться иными. Они даже могут различаться при каждом запуске. Важно просто обратить внимание на закономерности в адресах:


```cpp

=== Calculating factorial of 0 ===
  Factorial(0): &n=0000005D1D0FF9B0
Result is: 1

=== Calculating factorial of 1 ===
  Factorial(1): &n=0000005D1D0FF9B0
  Factorial(0): &n=0000005D1D0FF8E0
Result is: 1

=== Calculating factorial of 2 ===
  Factorial(2): &n=0000005D1D0FF9B0
  Factorial(1): &n=0000005D1D0FF8E0
  Factorial(0): &n=0000005D1D0FF810
Result is: 2

=== Calculating factorial of 3 ===
  Factorial(3): &n=0000005D1D0FF9B0
  Factorial(2): &n=0000005D1D0FF8E0
  Factorial(1): &n=0000005D1D0FF810
  Factorial(0): &n=0000005D1D0FF740
Result is: 6 

```

При первом входе в функцию `Factorial` адрес, по которому расположена переменная `n`, всегда один и тот же — `0000005D1D0FF9B0`. С каждым следующим рекурсивным вызовом переменная `n` размещается по адресу, меньшему на `0xD0` — 208 в десятичной системе.

Можно сделать вывод, что размер кадра стека функции `Factorial` равен 208 байтам. Стек на платформе x86/x64 «растёт» сверху вниз. Этим объясняется уменьшение адреса размещения локальных переменных при вложенных вызовах функции.

![image](https://pictures.s3.yandex.net/resources/Object_layouts_in_memory_3_1_1623162908.png)_Кадры стека при вычислении `Factorial(2)` и `Factorial(3)`_

Дан текст программы:


```cpp

int speed = 12;

int Run(int time) {
    int distance = speed * time;
    speed /= 2;
    return distance;
}

int main() {
    int distance = Run(10) + Run(10) + Run(10);
} 

```

Чему будет равно значение переменной `distance` перед выходом из функции `main`?

210 

Функция `Run` три раза вызывается с одним и тем же значением `time`. Однако скорость перемещения после каждого забега уменьшается вдвое. В результате пройденное расстояние будет равно 12*10 + 6*10 + 3*10 = 21012∗10+6∗10+3∗10=210. Вот так глобальные переменные неочевидным образом усложняют анализ работы программы.

Что выведет в `output` эта программа? Введите ответ в одну строку без пробелов.

```cpp

#include <iostream>

using namespace std;

struct Log {
    explicit Log(int id)
        : id_(id) 
    {
        cout << id_;
    }

    ~Log() {
        cout << "-" << id_;
    }

private:
    int id_;
};

void One() {
    Log local1{1};
}

void Two() {
    Log local2{2};
    One();
    Log local3{3};
}

Log global1{4};

int main() {
    Two();
}

Log global2{5}; 

```

4521-13-3-2-5-4

-   До выполнения функции `main` конструкторы глобальных переменных `global1` и `global2` выведут `45`.
-   Функция `main` вызовет функцию `Two`, где конструктор переменной `local2` выведет `2`.
-   Функция `Two` вызовет функцию `One`, где конструктор переменной `local1` выведет `1`, а её деструктор выведет `-1`. Произойдёт возврат в функцию `Two`.
-   Конструктор переменной `local3` внутри функции `Two` выведет `3`. Следом деструкторы `local3` и `local2` выведут `-3-2`. Произойдёт выход в функцию `main`.
-   После выхода из `main` запустится процесс разрушения переменных со статическим временем жизни в порядке, обратном их конструированию в текущем .cpp файле. Сначала деструктор переменной `global2` выведет `-5`, а затем деструктор переменной `global1` выведет `-4`.

В этом уроке вы узнали о статическом и автоматическом размещении объектов в памяти программы. Время жизни таких объектов строго детерминировано и за его соблюдением следит компилятор.

За простоту статического и автоматического хранения приходится платить ограниченными функциональными возможностями. Для хранения локальных переменных при каждом вызове функции выделяется кадр стека фиксированного размера. Объекты со статическим размещением существуют в программе в единственном экземпляре.

Динамическое размещение памяти позволяет программе создавать столько объектов, сколько нужно для решения задачи, а потом удалять эти объекты, когда задача решена. В следующем уроке познакомитесь с динамической памятью.


# Динамическое размещение объектов в памяти

В прошлом уроке вы узнали о статическом и автоматическом размещении объектов в памяти. Этих двух способов достаточно для решения задач, где объём обрабатываемых данных известен заранее. Но сегодня такие задачи — скорее исключение, чем правило.

Часто до запуска программы неизвестно, какой объём памяти ей понадобится. В вашу поисковую систему можно добавить несколько сотен и даже тысяч документов. В ней сведения о документах содержатся в стандартных контейнерах, таких как `vector`, `map`, `set`. Они хранят свои элементы в куче — области, предназначенной для динамического выделения и освобождения памяти по запросу программы.

Работу с этой областью памяти легко сравнить с арендой земельных участков в утопическом государстве. Каждый житель может взять в аренду участок нужного размера и использовать по своему усмотрению — например, для выращивания пшеницы. Собрав урожай, житель возвращает участок государству, чтобы эту землю могли использовать другие. Скажем, построить на ней завод. Если страна большая, и арендаторы не забывают возвращать землю государству, все довольны.

Чтобы создать объект в куче, используют операцию `new`. Она выделяет в куче память нужного размера, конструирует в ней объект и возвращает указатель на него.

Удалить ненужный объект можно операцией `delete`. Она принимает указатель на объект, который создан операцией `new`, и выполняет следующие действия:

-   удаляет объект, вызывая его деструктор,
-   освобождает память — возвращает её в кучу:


```cpp

int main() {
    // В куче создаётся объект типа int. Адрес этого объекта сохраняется в value_ptr.
    int* value_ptr = new int;
    
    // Используем созданный объект по указателю на него
    *value_ptr = 42;

    // Удаляем объект и возвращаем занимаемый им блок памяти обратно в кучу
    delete value_ptr;
} 

```

Операции `delete` можно безопасно передавать указатель, равный `nullptr`, — в этом случае она ничего не делает. Поэтому проверка указателя на `nullptr` перед вызовом `delete` избыточна. Зато после вызова `delete` указатель на удалённый объект лучше обнулить, если ещё планируете использовать этот указатель:


```cpp

#include <cstdlib>
#include <ctime>
#include <iostream>

using namespace std;

int main() {
    int* value_ptr = new int;

    // *value_ptr принимает случайное значение (для примера)
    srand(time(0));
    *value_ptr = rand();

    if (bool delete_now = (*value_ptr % 2) == 0;  // Этот код будет выполнен только для чётных значений *value_ptr
        delete_now) {
        // Эта проверка на нулевой указатель перед вызовом delete является избыточной.
        // Оператор delete ничего не делает, если вызвать его с нулевым указателем
        if (value_ptr) {
            delete value_ptr;

            // А вот обнулить указатель после удаления объекта имеет смысл, если
            // этот указатель потенциально может ещё использоваться
            value_ptr = nullptr;
        }
    }

    // Указатель мог ранее обнулиться, поэтому здесь его следует проверить
    if (value_ptr) {
        cout << *value_ptr << endl;
    }

    // Удаляем объект, на который ссылается value_ptr. 
    // Проверку на nullptr перед удалением объекта смело пропускаем
    delete value_ptr;
    // value_ptr = nullptr;
    // Обнуление указателя на удалённый объект перед выходом избыточно, если
    // этот указатель далее по коду не используется - 
    // всё равно что помыть пол в доме перед сносом.
} 

```

Операция `new` позволяет передать параметры конструктору создаваемого объекта. Рассмотрим это на примере. Заодно используем класс `LifetimeLogger`, чтобы сравнить время жизни обычных локальных переменных и объектов в динамической памяти:


```cpp

#include <iostream>
#include <string>

using namespace std;

// Уведомляет о своём создании и разрушении
class LifetimeLogger {
public:
    explicit LifetimeLogger(int id)
        : id_(id)  // Сохраняем идентификатор
    {
        cout << "LifetimeLogger "s << id_ << " created"s << endl;
    }

    ~LifetimeLogger() {
        cout << "LifetimeLogger "s << id_ << " destroyed"s << endl;
    }

private:
    int id_;
};

int main() {
    // Создаём LifetimeLogger в куче, передавая его конструктору параметр 1
    LifetimeLogger* logger1 = new LifetimeLogger(1);

    LifetimeLogger logger2(2);

    cout << "Delete logger 1"s << endl;
    delete logger1;

    cout << "Exit main"s << endl;
} 

```

Скомпилируем и запустим программу:

Скопировать код

`LifetimeLogger 1 created
LifetimeLogger 2 created
Delete logger 1
LifetimeLogger 1 destroyed
Exit main
LifetimeLogger 2 destroyed` 

Сначала в динамической памяти создаётся объект `LifetimeLogger(1)`, а следом за ним — `LifetimeLogger(2)`. Время жизни `LifetimeLogger(1)` заканчивается при выполнении операции `delete`: вызывается деструктор, который выводит сообщение “LifetimeLogger 1 destroyed”, и освобождается память. `LifetimeLogger(2)` удаляется автоматически после вывода “Exit main”.

Вы могли обратить внимание, что в этой программе не соблюдается правило «объекты уничтожаются в порядке, обратном порядку их конструирования»‎. Это нормально, так как время жизни объектов в куче контролирует программист, а не компилятор.

Забота программиста — удалять созданные в куче объекты, когда в них нет необходимости. Память, как и любой ресурс, ограничена. Когда в куче нет свободного места для создания объекта, оператор `new` выбрасывает исключение `std::bad_alloc`. Поймав это исключение, программа может сообщить пользователю о нехватке памяти, предложить выйти из программы или сохранить данные на диск.

Рассмотрим эту ситуацию на примере маленькой, но жадной программы. Она моделирует ситуацию, когда «‎арендатор», получив земельный участок, «теряет» документы на него. Так как без документов вернуть участок невозможно, все государственные земли быстро станут считаться занятыми, и арендовать будет нечего. Экономика страны продемонстрирует стабильный отрицательный рост с последующей сменой политического режима:



```cpp
#include <iostream>
#include <new>
#include <string>

using namespace std;

int main() {
    size_t n = 0;
    try {
        // Так создаётся бесконечный цикл.
        for (;;) {
            // Внимание! Эта программа ведёт себя некорректно в иллюстративных целях.
            // Указатель на выделенную в куче строку никуда не сохраняется, что
            // приводит к утечке памяти.
            new string(100'000'000, ' ');
            ++n;
        }
    } catch (const bad_alloc&) {
        // Рано или поздно доступная программе память закончится,
        // и оператор new выбросит исключение bad_alloc
        cout << "bad_alloc after "s << n << " allocations"s << endl;
    }
} 

```

Вступаем в зону экстремального обучения. Скопируйте код выше в свою IDE. Перед запуском программы сохраните данные в открытых приложениях. Во время её работы системе будет не хватать памяти, что потенциально может негативно повлиять на работу других процессов.

Скомпилируйте и запустите программу. В зависимости от размера памяти на вашем компьютере она проработает от нескольких секунд до нескольких минут и сообщит о пойманном исключении:


```cpp

bad_alloc after 206 allocations 

```

Запустите диспетчер задач и понаблюдайте за изменением объёма памяти. Программа быстро займёт доступную физическую память и сможет проработать ещё некоторое время, используя виртуальную память, которую ей выделяет операционная система. Затем программа столкнётся с нехваткой памяти и закончит работу.

![image](https://pictures.s3.yandex.net/resources/task_manager_1_1623765676.png)_График использования памяти компьютера во время работы «жадной» программы_

Такие ошибки программы называются «утечки памяти». Они возникают, когда:

-   программист не удалил объект после использования;
-   указателю, ссылающемуся на объект в куче, присвоили новое значение, и других указателей на этот объект нет. Объект становится недоступным из кода, хотя продолжает занимать память.

В итоге приложение исчерпает доступный лимит памяти и завершится с ошибкой. Поэтому вовремя удаляйте ненужные объекты. Особенно в программах, которые должны работать долго и бесперебойно.

Чтобы исправить программу, добавьте вызов `delete` у указателя на строку в динамической памяти:


```cpp

#include <iostream>
#include <new>
#include <string>

using namespace std;

int main() {
    size_t n = 0;
    try {
        for (; n != 300; ++n) {
            string* p = new string(100'000'000, ' ');
            // Утечка памяти исправлена - объект в куче своевременно удаляется
            delete p;
        }
        cout << "Program completed successfully"s;
    } catch (const bad_alloc&) {
        // Сюда программа, скорее всего, не попадёт,
        // если объём свободной памяти в куче будет больше 100 мегабайт
        cout << "bad_alloc after "s << n << " allocations"s << endl;
    }
} 

```

Запустите программу и убедитесь, что потребление памяти пришло в норму. Теперь программа использует немногим более сотни мегабайт памяти для хранения символов строки.

В программах на C++ применяют объекты с разным временем жизни. Долгоживущие объекты создаются в статической памяти и существуют на протяжении всей работы программы. Локальные переменные с автоматическим временем жизни наиболее просты в использовании — за их своевременным удалением следит компилятор.

Программа может обрабатывать произвольные объёмы данных, при необходимости создавая и удаляя объекты в динамической памяти. Чтобы работать с ними напрямую, нужно хорошо понимать возможные пути выполнения программы, в том числе при выбрасывании исключений.

Как правило, код, который использует низкоуровневые операции с динамической памятью, располагают внутри библиотечных классов и функций. Это позволяет при решении прикладных задач концентрироваться на бизнес-логике, а не на ручном управлении динамической памятью.

В следующих уроках вы научитесь созданию простых в использовании классов, скрывающих трудности работы с динамической памятью.


Вы ведущий программист в команде, разрабатывающей софт для роботов-осьминогов. Один из джуниор-разработчиков прислал вам на ревью код, моделирующий осьминога:


```cpp

#include <iostream>
#include <string>
#include <vector>

using namespace std;

// Щупальце
class Tentacle {
public:
    explicit Tentacle(int id)
        : id_(id) {
    }

    int GetId() const {
        return id_;
    }

private:
    int id_ = 0;
};

// Осьминог
class Octopus {
public:
    Octopus() {
        for (int i = 1; i <= 8; ++i) {
            tentacles_.push_back(new Tentacle(i));
        }
    }

private:
    vector<Tentacle*> tentacles_;
};

int main() {
    Octopus octopus;
} 

```

Взглянув на программу, вы сразу обнаруживаете в ней несколько утечек памяти и отправляете код на доработку. Какое исправление должен сделать программист, чтобы устранить найденные вами проблемы? Выберите один верный ответ. Предлагаемые исправления заключены между комментариями:

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

// Щупальце
class Tentacle {
public:
    explicit Tentacle(int id)
        : id_(id) {
    }

    int GetId() const {
        return id_;
    }

private:
    int id_ = 0;
};

// Осьминог
class Octopus {
public:
    Octopus() {
        // <--- Тело конструктора обновлено
        Tentacle* t = nullptr;
        try {
            for (int i = 1; i <= 8; ++i) {
                t = new Tentacle(i);
                tentacles_.push_back(t);
                t = nullptr;
            }
        } catch (const bad_alloc&) {
            Cleanup();
            delete t;
            throw bad_alloc();
        }
        // --->
    }

    // <--- Добавлен деструктор
    ~Octopus() {
        Cleanup();
    }
    // --->

private:
    // <--- Добавлен метод Cleanup
    void Cleanup() {
        for (Tentacle* t : tentacles_) {
            delete t;
        }
        tentacles_.clear();
    }
    // --->

    vector<Tentacle*> tentacles_;
};

int main() {
    Octopus octopus;
}
```
Великолепно! В деструкторе класса `Octopus` вызов метода `Cleanup` удаляет созданные в динамической памяти щупальца. В конструкторе `Octopus` исключение `bad_alloc` может быть выброшено как в операции `new`, так и в методе `push_back` класса `vector`. Обработчик исключения учитывает обе ситуации, удаляя сконструированные щупальца, а потом пробрасывает исключение дальше, чтобы отменить конструирование осьминога.
