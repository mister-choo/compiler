# Вещественные числа

Разобравшись с целочисленным типом данных `int`, можно перейти к вещественным числам. Их представляет тип данных `double`:



```cpp
#include <iostream>

using namespace std;

int main() {
    double pi = 3.14;
}
```

Арифметические операции над вещественными числами производят так же, как над целыми:



```cpp
#include <iostream>

using namespace std;

int main() {
    double x = 1;
    double y = 3;
    cout << x + y << endl // 4
         << x - y << endl // -2
         << x * y << endl // 3
         << x / y << endl; // 0.333333
}
```

Здесь C++ немного врёт: он выводит не больше шести знаков после запятой у последнего числа, хотя на самом деле значащих цифр больше. Например, `0.333333` не равен `0.3333333`. Заставить C++ выводить все значащие цифры можно, но код будет сложнее читать. Поэтому по умолчанию они не выводятся.

Взгляните на код снова. Переменной `x` типа `double` присвоен литерал 1 типа `int`. Это не ошибка. C++ умеет неявно преобразовывать численные типы друг к другу:



```cpp
#include <iostream>

using namespace std;

int main() {
    int x = 42;
    double y = x; // 42.0
    double z = -(x + y + 0.8); // -84.8
    int w = z; // -84, округление в сторону нуля, дробная часть отбрасывается
}
```

Если нужен именно литерал типа `double`, пишут не 1, а 1.0. Но обычно это не требуется.

Преобразовать `double` к `int` можно явно. Для этого есть операция `static_cast`. Она применяется так:



```cpp
#include <iostream>

using namespace std;

int main() {
    int x;
    cin >> x;
    // результат выражения (x + 0.5) будет неявно приведён к double,
    // затем static_cast<int>(...) явно приведёт его к int — отбросит дробную часть
    cout << static_cast<int>(x + 0.5) << endl;
}
``` 

Явное приведение `int` к `double` нужно редко. Обычно оно происходит само при арифметических операциях. Но способы есть:

-   операция `static_cast<double>(/*выражение*/)`. Она попытается преобразовать выражение из скобок к типу `double`. Для целого числа такое преобразование существует, и изменение типа пройдёт успешно. Если выражение было бы, например, строковым литералом, возникла бы ошибка. `static_cast` не умеет преобразовывать строки в числа.
-   трюк — прибавить к числу 0.0 или умножить его на 1.0. Например, так:



```cpp
#include <iostream>

using namespace std;

int main() {
    int x = 1;
    int y = 2;
    // деление двух чисел типа int. Результат типа int и равен 0.
    cout << x / y << endl;

    // после приведения типа к double, результат будет вычислен в типе double и равен 0.5
    cout << x / (y + 0.0) << endl;
}
```