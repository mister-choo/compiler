
# Копирование объектов

В своих предыдущих программах вы, сами того не подозревая, хранили данные в динамической памяти, когда использовали строки и контейнеры `vector`, `map` и `set`. Эти стандартные классы размещают элементы в куче, а пользователю предоставляют простые и удобные операции вроде вставки и удаления элементов. Благодаря им вы концентрируетесь на прикладных задачах вроде поисковой системы и не отвлекаетесь на преодоление трудностей, которые возникают при работе с динамической памятью.

Когда дело касается объектов, хранящих данные в динамической памяти, многие привычные вещи вроде копирования становятся сложнее в реализации. Вспомним класс «Осьминог» из предыдущего урока.

![image](https://pictures.s3.yandex.net/resources/octopus_1640268425.png)_Представление экземпляра класса `Octopus` в памяти_

В классе «Осьминог» задача искусственно усложнена тем, что в векторе `tentacles_` не сами щупальца, а указатели на них. Это сделано намеренно. Так вы увидите трудности, с которыми сталкиваются программисты классов, работающих с динамической памятью.

Чтобы устранить утечки памяти, потребовалось не только добавить деструктор, удаляющий щупальца осьминога, но и обработать возможное исключение `bad_alloc` в конструкторе класса. Однако в классе `Octopus` осталась ошибка, которая может проявлять себя очень странно. Создадим в программе ещё одного осьминога, проинициализировав его значением первого:

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

// Щупальце
class Tentacle {
public:
    explicit Tentacle(int id)
        : id_(id) {
    }

    int GetId() const {
        return id_;
    }

private:
    int id_ = 0;
};

// Осьминог
class Octopus {
public:
    Octopus() {
        Tentacle* t = nullptr;
        try {
            for (int i = 1; i <= 8; ++i) {
                t = new Tentacle(i);      // Может выбросить исключение bad_alloc
                tentacles_.push_back(t);  // Может выбросить исключение bad_alloc

                // Обнуляем указатель на щупальце, которое уже добавили в tentacles_,
                // чтобы не удалить его в обработчике catch повторно
                t = nullptr;
            }
        } catch (const bad_alloc&) {
            // Удаляем щупальца, которые успели попасть в контейнер tentacles_
            Cleanup();
            // Удаляем щупальце, которое создали, но не добавили в tentacles_
            delete t;
            // Конструктор не смог создать осьминога с восемью щупальцами,
            // поэтому выбрасываем исключение, чтобы сообщить вызывающему коду об ошибке
            // throw без параметров внутри catch выполняет ПЕРЕВЫБРОС пойманного исключения
            throw;
        }
    }

    const Tentacle& GetTentacle(int index) const {
        if (index < 0 || static_cast<size_t>(index) >= tentacles_.size()) {
            throw out_of_range("Invalid tentacle index"s);
        }
        // Чтобы превратить указатель в ссылку, разыменовываем его
        return *tentacles_[index];
    }

    ~Octopus() {
        // Осьминог владеет объектами в динамической памяти (щупальца),
        // которые должны быть удалены при его разрушении.
        // Деструктор - лучшее место, чтобы прибраться за собой.
        Cleanup();
    }

private:
    void Cleanup() {
        // Удаляем щупальца осьминога из динамической памяти
        for (Tentacle* t : tentacles_) {
            delete t;
        }
        // Очищаем массив указателей на щупальца
        tentacles_.clear();
    }

    // Вектор хранит указатели на щупальца. Сами объекты щупалец находятся в куче
    vector<Tentacle*> tentacles_;
};

int main() {
    {
        Octopus octopus;
        // Мы просто хотели ещё одного осьминога
        Octopus octopus1 = octopus;
        // Всё было хорошо и не предвещало беды...
        // ... до этого момента
    }
    cout << "Congratulations. Everything is OK!"s << endl;
} 

```

Скопируйте код в свою IDE и запустите. В зависимости от настроек компилятора и ОС программа может вести себя по-разному. Например, так:


```cpp

Segmentation fault 

```

Или не вывести ничего:

Скопировать код

Внесите изменения в функцию `main` и снова запустите программу:


```cpp

int main() {
    {
        Octopus octopus;
        // Мы просто хотели ещё одного осьминога
        Octopus octopus1 = octopus;
        cout << "Tentacle id="s << octopus1.GetTentacle(3).GetId() << endl;
    }
    cout << "OK"s << endl;
} 

```

Возможный и ожидаемый вывод программы:


```cpp

Tentacle id=4
OK 

```

Но вывод может быть другим:


```cpp

Tentacle id=4 

```

Ситуацию, которая возникает в программе, называется «**неопределённое поведение**». То есть программа может вести себя как угодно: упасть, выдать ожидаемый результат или отправить в прошлое Терминатора, чтобы убить Сару Коннор. Но сейчас нас интересует не то, что программа может сделать, а причины, которые к этому привели.

Данную программу от ранее работавшей отличает создание копии осьминога:


```cpp

int main() {
    // Оригинальный осьминог
    Octopus octopus;
    // Копия первого осьминога
    Octopus octopus1 = octopus;
} 

```

Первый осьминог инициализируется конструктором по умолчанию. Для инициализации второго осьминога использован копирующий конструктор. Его ещё называют конструктором копирования.

Копирующий конструктор создаёт новый объект на основе существующего. В качестве своего параметра этот конструктор принимает константную ссылку на объект того же типа:


```cpp

#include <string>

using namespace std;

class Object {
public:
    // Явно заданный конструктор копирования.
    // Ожидается, что копия будет идентична оригиналу,
    // поэтому поля копии инициализируем значением полей оригинала
    Object(const Object& other)
        : id_(other.id_)
        , name_(other.name_) {
    }

    // ...

private:
    int id_;
    string name_;
}; 

```

Вызов копирующего конструктора может быть явным, как у нашего осьминога, и неявным — например, при передаче параметра в функцию по значению или при возврате объекта из функции:


```cpp

void PlayWithOctopus(Octopus o) {
    cout << "tentacle:"s << o.GetTentacle(1).GetId() << endl;
}

int main() {
    Octopus o1;

    // В функцию PlayWithOctopus будет неявно передана копия объекта o1
    PlayWithOctopus(o1);
    cout << "OK"s << endl;
} 

```

Компилятор может сгенерировать не только конструктор по умолчанию, но и копирующий конструктор. В этом случае для инициализации каждого поля объекта будет вызван его копирующий конструктор. В классе `Octopus` компилятор сгенерирует конструктор копирования, который создаст копию массива указателей на щупальца осьминога:


```cpp

#include <vector>

using namespace std;

// Щупальце
class Tentacle {
    // ...
};

// Осьминог
class Octopus {
public:
    // ...

    // Сгенерированный компилятором конструктор копирования
    // копирует массив указателей на щупальца
    Octopus(const Octopus& other)
        : tentacles_(tentales) {
    }

    // ...

private:
    // ...

    // Вектор хранит указатели на щупальца. Сами объекты щупалец находятся в куче
    vector<Tentacle*> tentacles_;
}; 

```

Получим ситуацию, изображённую на этом рисунке:

![image](https://pictures.s3.yandex.net/resources/octopus_2_1640268600.png)_Копия осьминога будет ссылаться на те же щупальца, что и оригинал_

Когда на один объект ссылаются несколько указателей — это нормально.

![image](https://pictures.s3.yandex.net/resources/Untitled_Artwork_128_1640268704.png)

Проблемы начинаются при выходе из блока, где объявлены переменные `octopus` и `octopus1`. Сначала будет вызван деструктор `octopus1`. Он удалит щупальца осьминога:

![image](https://pictures.s3.yandex.net/resources/octopus_3_1640268771.png)_Деструктор `octopus1` удалит щупальца осьминога_

После удаления `octopus1` указатели, которые хранятся в массиве щупалец осьминога `octopus`, станут невалидными — они более не ссылаются на существующие объекты. Такие указатели нельзя использовать для доступа к объекту. Нельзя даже вызвать операцию `delete`. Все эти действия приведут к неопределённому поведению при удалении осьминога `octopus`: в своём деструкторе он передаст в оператор `delete` невалидный указатель.

Вы познакомились с копирующим конструктором. Он инициализирует экземпляр класса, копируя уже имеющийся. Этот конструктор принимает константную ссылку на копируемый объект. Всякий раз, когда в программе явно или неявно создаётся копия существующего объекта, используется копирующий конструктор.

Сгенерированный компилятором конструктор копирования создаёт копию объекта, копируя все поля оригинала. Это поведение хорошо работает для классов и структур, хранящих объекты-значения, но плохо для копирования классов, которые содержат данные в динамической памяти. В нашем случае проблема возникла при копировании осьминога. Копия осьминога должна иметь собственный набор щупалец, а не пользоваться щупальцами оригинала.

Когда сгенерированный компилятором конструктор копирования не подходит, вы можете написать его вручную, реализовав желаемую семантику копирования объектов. Этим вы займётесь в следующих уроках. А в задании этого урока вам предстоит поэкспериментировать с неопределённым поведением.

Из предыдущего урока вы узнали о трудностях копирования объектов, содержащих указатели на динамическую память. Когда процесс не сводится к простому копированию полей объекта, программисту нужно создать копирующий конструктор для правильного выполнения этой операции.

### Выбираем способ хранить щупальца

Код осьминога из предыдущего урока был искусственно усложнён тем, что щупальца хранились в динамической памяти. Так вы смогли увидеть трудности своими глазами. Если бы в `tentacles_` хранились сами щупальца, а не указатели на них, проблем при копировании осьминога не возникло бы — все его щупальца скопировались бы автоматически.

Чтобы хранение указателей на щупальца вместо самих щупалец было более обоснованным, немного усложним задачу:

-   щупальце может прицепляться к произвольному щупальцу любого осьминога и отцепляться от него;
-   осьминог при создании может иметь произвольное количество щупалец. По умолчанию их восемь;
-   разрешается добавлять осьминогу новые щупальца, используя метод `AddTentacle`.


```cpp

class Tentacle {
public:
    explicit Tentacle(int id) noexcept;
    int GetId() const noexcept;

    Tentacle* GetLinkedTentacle() const noexcept {
        return linked_tentacle_;
    }
    void LinkTo(Tentacle& tentacle) noexcept {
        linked_tentacle_ = &tentacle;
    }
    void Unlink() noexcept {
        linked_tentacle_ = nullptr;
    }

private:
    int id_ = 0;
    Tentacle* linked_tentacle_ = nullptr;
};

class Octopus {
public:
    Octopus();
    explicit Octopus(int num_tentacles);

    void AddTentacle();
    size_t GetTentacleCount() const noexcept;
    const Tentacle& GetTentacle(size_t index) const;
    Tentacle& GetTentacle(size_t index);

    ~Octopus();

private:
    void Cleanup() noexcept;

    vector<Tentacle*> tentacles_;
};

int main() {
    Octopus octopus1;
    Octopus octopus2;

    // Два осьминога прицепляются друг к другу щупальцами
    octopus1.GetTentacle(1).LinkTo(octopus2.GetTentacle(3));
    octopus2.AddTentacle();
    octopus2.GetTentacle(octopus2.GetTentacleCount() - 1).LinkTo(octopus1.GetTentacle(0));
} 

```

📖 В коде использован спецификатор `noexcept`, означающий, что метод или функция не выбрасывает исключений. Он помогает компилятору сгенерировать более быстрый код, а программисту гарантирует, что при вызове метода или функции исключений не будет.

Из-за возможности добавлять осьминогу новые щупальца, а щупальцам — ссылаться друг на друга, хранение щупалец в векторе становится затруднительным:

-   При добавлении нового щупальца ранее существовавшие ссылки на щупальца станут невалидны из-за особенностей реализации вектора. Почему так происходит, вы узнаете через несколько уроков.
-   Другие контейнеры могли сохранить валидность ссылок при вставке и удалении элементов, но не справились бы с неожиданным требованием разрешить осьминогам обмениваться щупальцами.

Храня щупальца в динамической памяти, делаем их более независимыми: их адрес не изменится ни при модификации контейнера, ни при передаче другому осьминогу. На практике такая задача может возникать регулярно — например, папки хранят наборы файлов, а гостиницы — наборы постояльцев.

### Анализируем код конструктора по умолчанию

Прежде чем начать писать конструктор копирования класса «‎Осьминог», взгляните на конструктор по умолчанию в классе `Octopus`:


```cpp

class Octopus {
public:
    Octopus() {
        Tentacle* t = nullptr;
        try {
            for (int i = 1; i <= 8; ++i) {
                t = new Tentacle(i);      // Может выбросить исключение bad_alloc
                tentacles_.push_back(t);  // Может выбросить исключение bad_alloc

                // Обнуляем указатель на щупальце, которое уже добавили в tentacles_,
                // чтобы не удалить его в обработчике catch повторно
                t = nullptr;
            }
        } catch (const bad_alloc&) {
            // Удаляем щупальца, которые успели попасть в контейнер tentacles_
            Cleanup();
            // Удаляем щупальце, которое создали, но не добавили в tentacles_
            delete t;
            // Конструктор не смог создать осьминога с восемью щупальцами,
            // поэтому выбрасываем исключение, чтобы сообщить вызывающему коду об ошибке
            // throw без параметров внутри catch выполняет ПЕРЕВЫБРОС пойманного исключения
            throw;
        }
    }
    ...
}; 

```

Код конструктора получился довольно сложным, так как нужно обработать исключение `bad_alloc`. Оно может возникнуть при создании щупальца в динамической памяти.

Обработчик исключения должен удалить объекты, на которые ссылаются указатели в векторе `tentacles_`. Удалить нужно и щупальце по адресу в переменной `t`. Оно ещё не успело попасть в контейнер `tentacles_`.

Если в таком же стиле написать конструктор копирования, он будет не менее сложным. Вот был бы способ автоматически удалять объект из динамической памяти, когда указатель, хранящий его адрес, выходит из своей области видимости!

В C++ эту задачу решают умные указатели — классы, которые благодаря перегрузке операций ведут себя как указатели. Они предоставляют операцию разыменования `*` и доступа к членам класса `->`. В отличие от обычных указателей, которые ещё называют «сырыми»‎, умные указатели реализуют семантику владения объектом, то есть автоматически удаляют объект при наступлении определённых условий. Умные указатели также определяют, что должно происходить при копировании указателя. Как правило, умные указатели делают шаблонными, чтобы использовать с объектами разных типов.

В стандартной библиотеке есть классы умных указателей, которые упростили бы решение задачи. Вы обязательно с ними познакомитесь в следующих спринтах. В этом уроке вы создадите свой умный указатель, чтобы потом упростить класс `Octopus`.

Умный указатель в качестве одного из своих полей хранит обычный указатель, а «‎умное поведение»‎ реализуется за счёт конструктора, деструктора и специфичных для указателя операций.

Ваш указатель `ScopedPtr` будет владеть объектом, созданным в куче, и гарантировать, что объект автоматически удалится при выходе из области видимости указателя.

В повседневной разработке вам вряд ли понадобится писать собственные умные указатели и вручную вызывать `new`/`delete`. Скорее всего, использовать вы будете стандартные. Но задания позволят разобраться, как удобные стандартные классы устроены на самом деле, и чего от них ожидать.

Вы создали свой первый умный указатель `ScopedPtr`, который позволил сохранить объект в динамической памяти и автоматически контролировать время его жизни. У `ScopedPtr` есть и другие полезные свойства:

-   Исключает неинициализированное состояние. Он либо пустой, либо хранит адрес существующего объекта;
-   Запрещает копирование указателя. Тем самым исключает ситуацию, когда два указателя одновременно владеют одним объектом;
-   Вместо неопределённого поведения при разыменовании нулевого указателя `ScopedPtr` выбрасывает исключение `logic_error`, которое можно поймать и обработать приложением.

Эти свойства указателя позволяют сделать управление объектами в динамической памяти проще. Вместо такого:


```cpp

int main() {
    vector<Object*> objects;
    Object* ptr = nullptr;
    try {
        for (int i = 0; i < 5; ++i) {
            ptr = new Object();
            objects.push_back(ptr);
            // Обнуляем ptr (этот указатель уже скопирован в objects)
            ptr = nullptr;
        }
    } catch (...) {
        delete ptr;
    }
    // Удаляем объекты из массива указателей
    for (Object* obj_ptr : objects) {
        delete obj_ptr;
    }
} 

```

Можно написать лаконичнее:


```cpp

int main() {
    vector<Object*> objects;
    try {
        for (int i = 0; i < 5; ++i) {
            // Пока указатель не добавлен в контейнер objects, им владеет умный указатель
            ScopedPtr<Object> ptr(new Object());
            objects.push_back(ptr.GetRawPtr());

            // Вызываем Release, чтобы указатель не удалил объект, уже 
            // вставленный в вектор.
            ptr.Release();
        }
    } catch (...) {
    }
    for (Object* obj_ptr : objects) {
        delete obj_ptr;
    }
} 

```

Тем не менее удалять объекты, на которые ссылаются указатели внутри вектора, всё ещё приходится вручную. Чтобы автоматизировать процесс, разработаем класс-обёртку `PtrVector` — вектор указателей. Он автоматически удаляет объекты в своём деструкторе. Код станет ещё проще:


```cpp

int main() {
    PtrVector<Object> objects;
    for (int i = 0; i < 3; ++i) {
        ScopedPtr<Object> ptr(new Object());
        objects.GetItems().push_back(ptr.GetRawPtr());
        ptr.Release();
    }

    cout << "PtrVector copy has been destroyed"s << endl;

    // Деструктор PtrVector автоматически удалит объекты, на которые
    // ссылаются хранящиеся внутри него указатели
} 
```


Также `PtrVector` будет допускать копирование:


```cpp

PtrVector<Object> objects;

// ...

PtrVector<Object> objects_copy(objects); 

```

Во время этого он создаст копии всех объектов, указатели на которые содержатся в `objects`.

# Присваивание объектов

В прошлых уроках вы научились копировать объекты, содержащие указатели на подобъекты в динамической памяти. Вы разработали умный указатель `ScopedPtr`, который реализует семантику владения объектом в динамической памяти, и класс `PtrVector`, автоматизирующий удаление и копирование объектов внутри вектора указателей. Так вы сделали копирование осьминогов не только надёжным, но и простым. В реальных задачах умные указатели и «‎обёртки»‎ тоже упрощают написание надёжного кода.

> Надёжные дома создаются из качественных кирпичей.

В этом уроке вы научитесь правильно реализовывать присваивание объектов. Присваивание — одна из специальных операций C++. Для пользовательских типов компилятор может реализовать её автоматически. Поэтому вам не приходилось беспокоиться о ней, когда вы присваивали один объект другому:


```cpp

#include <cassert>
#include <string>

using namespace std;

struct Cat {
    string name;
    int age = 0;
};

int main() {
    Cat cat1{"Tom"s, 3};
    Cat cat2;

    // Сгенерированный компилятором метод operator= выполнит 
    // присваивание соответствующих полей класса Cat.
    cat2 = cat1;

    assert(cat1.name == cat2.name);
    assert(cat1.age == cat2.age);
} 

```

Операция `=`, которую сгенерировал компилятор, присваивает значения полей одного объекта соответствующим полям другого. В большинстве случаев это именно то, что нужно!

Но, как вы уже знаете, привычные вещи становятся труднее в реализации, когда объект владеет другими объектами в динамической памяти или иными ресурсами.

В классе `Octopus` сгенерированная операция `=` присвоит массив щупалец одного осьминога другому:


```cpp

int main() {
    {
        Octopus octopus1(3);
        octopus.GetTentacle(1).LinkTo(octopus.GetTentacle(2));
        Octopus octopus2;

        octopus2 = octopus1;
        // Этот assert выстрелит, так как операция присваивания присвоит массив 
        // указателей на щупальца первого осьминога второму, и осьминоги будут 
        // использовать один и тот же набор щупалец.
        assert(&octopus2.GetTentacle(1) != &octopus1.GetTentacle(1));
        assert(octopus2.GetTentacle(1).GetLinkedTentacle() == &octopus1.GetTentacle(2));

        // После присваивания оба осьминога будут ссылаться на одни и те же щупальца

        // Деструктор octopus2 удалит щупальца, на которые ссылается octopus1,
        // и все указатели octopus1 станут невалидными.

        // Деструктор octopus1 выполнит удаление щупальцев с невалидными указателями,
        // что приведёт к неопределёному поведению.
    }
    cout << "OK"s << endl;
} 

```

В результате оба осьминога будут использовать одни и те же объекты щупалец в динамической памяти.

![image](https://pictures.s3.yandex.net/resources/Group_1103_1_1643312894.png)

Программа вновь поведёт себя непредсказуемо.

Когда у класса с пользовательским конструктором копирования используется неявно сгенерированная операция присваивания, компилятор может об этом предупредить:


```cpp

prog.cc:162:20: warning: implicitly-declared 'Octopus& Octopus::operator=(const Octopus&)' is deprecated [-Wdeprecated-copy]
  162 |         octopus1 = octopus;
      |                    ^~~~~~~
prog.cc:125:5: note: because 'Octopus' has user-provided 'Octopus::Octopus(const Octopus&)'
  125 |     Octopus(const Octopus& other) {
      |     ^~~~~~~ 

```

Чтобы решить проблему, переопределите эту операцию и реализуйте в ней присваивание значений объектов, а не указателей.

В С++ операцию присваивания можно переопределить только внутри класса в виде метода с именем `operator=`. Левым аргументом операции присваивания выступает текущий экземпляр класса, а правый аргумент передаётся через её единственный параметр. Тип правого аргумента операции может быть любым, а самих операций присваивания может быть определено несколько. Как правило, операция присваивания возвращает ссылку на свой левый аргумент. Это позволяет использовать результат операции в составе выражений, например `x = y = z`.

В С++ действует эмпирическое «Правило трёх». Если класс или структура объявляют один из следующих методов, скорее всего, они должны объявить все три:

-   деструктор,
-   конструктор копирования,
-   операция присваивания.

Эти особые функции класса может сгенерировать компилятор. Если программист переопределил одну из них, значит, сгенерированная компилятором версия не удовлетворяет потребностям класса в одном случае, и, вероятно, не удовлетворит в остальных.

Для структуры `Cat` операция присваивания, аналогичная сгенерированному компилятором, выглядит так:


```cpp

struct Cat {
    string name;
    int age = 0;

    Cat& operator=(const Cat& rhs) {
        // оптимизация самоприсваивания
        if (this != &rhs) {
            name = rhs.name;
            age = rhs.age;
        }

        // this - указатель на текущий экземпляр класса.
        // В операции присваивания он ссылается на левый аргумент операции.
        return *this; // возвращаем ссылку на левый аргумент операции присваивания
    }
}; 
```


Обратите внимание на защиту от присваивания объекта самому себе. Это идиоматичный способ избежать лишних действий и некорректной работы при самоприсваивании объекта.

Без этой проверки в структуре `Cat` самоприсваивание приведёт в худшем случае к замедлению программы. А вот для класса `PtrVector` может привести к некорректной работе:


```cpp

#include <cassert>
#include <vector>

using namespace std;

template <typename T>
class PtrVector {
public:
    ...
    // Внутри шаблона класса можно ссылаться на собственный тип, используя краткую запись:
    // PtrVector вместо PtrVector<T>

    PtrVector& operator=(const PtrVector& rhs) {
        // При присваивании PtrVector самому себе произойдёт удаление не только
        // своих элементов, но и элементов rhs.
        for (auto p : items_) {
            delete p;
        }
        items_.clear();

        items_.reserve(rhs.items_.size());
        for (T* p : rhs.items_) {
            items_.push_back(p ? new T(*p) : nullptr);
        }
        return *this;
    }
private:
    vector<T*> items_;
};

int main() {
    PtrVector<int> v;
    v.GetItems().push_back(new int(1));
    v.GetItems().push_back(new int(2));

    v = v;

    // Этот assert выстрелит, так как элементы v удалятся при самоприсваивании
    assert(v.GetItems().size() == 2);
} 

```

Другая проблема: если при копировании элементов операция `new` выбросит исключение, `PtrVector` окажется в промежуточном состоянии. Прежнее содержимое потеряется, а новые элементы до конца скопированы не будут.

Удобнее, когда методы класса обеспечивают строгую гарантию безопасности исключений: операция либо завершается успешно, либо происходит выбрасывание исключения и состояние объекта останется прежним. Такая семантика выполнения также называется “commit or rollback”.

Обеспечить строгую гарантию безопасности исключений в пользовательской операции присваивания можно, применив идиому “copy-and-swap”. В ней операция присваивания переиспользует функционал конструктора копирования.

-   Чтобы создать временную копию присваиваемого объекта, примените конструктор копирования. Если во время создания копии будет выброшено исключение, оно повлияет на временную копию, а не на текущий экземпляр класса.
-   Обменяйте текущее состояние объекта и временной копии. Эта операция не должна выбрасывать исключений. При выходе из операции присваивания прежнее состояние будет разрушено, а текущее состояние будет равно состоянию правого аргумента.

Применим copy-and-swap и реализуем операцию присваивания:

```cpp
class Object {
public:
    // копирующий конструктор
    Object(const Object& other);

    // копирующая операция присваивания
    Object& operator=(const Object& rhs) {
        if (this != &rhs) {
            // Реализация операции присваивания с помощью идиомы Copy-and-swap.
            // Если исключение будет выброшено, то на текущий объект оно не повлияет.
            auto rhs_copy(rhs);

            // rhs_copy содержит копию правого аргумента.
            // Обмениваемся с ним данными.
            swap(rhs_copy);

            // Теперь текущий объект содержит копию правого аргумента,
            // а rhs_copy - прежнее состояние текущего объекта, которое при выходе
            // из блока будет разрушено.
        }

        return *this;
    }

    // обменивает состояние текущего объекта с other без выбрасывания исключений
    void swap(Object& other) noexcept;

    ~Object();
}; 


```

## Задание 2

Добавьте реализацию класса`Octopus` с присваиванием, обеспечивающим строгую гарантию безопасности исключений. Проверьте, что класс работает корректно, используя следующую функцию `main`:


```cpp

int main() {
    // Проверка присваивания осьминогов
    {
        Octopus octopus1(3);

        // Настраиваем состояние исходного осьминога
        octopus1.GetTentacle(2).LinkTo(octopus1.GetTentacle(1));

        // До присваивания octopus2 имеет своё собственное состояние
        Octopus octopus2(10);

        octopus2 = octopus1;

        // После присваивания осьминогов щупальца копии имеют то же состояние,
        // что и щупальца присваиваемого объекта
        assert(octopus2.GetTentacleCount() == octopus1.GetTentacleCount());
        for (int i = 0; i < octopus2.GetTentacleCount(); ++i) {
            auto& tentacle1 = octopus1.GetTentacle(i);
            auto& tentacle2 = octopus2.GetTentacle(i);
            assert(&tentacle2 != &tentacle1);
            assert(tentacle2.GetId() == tentacle1.GetId());
            assert(tentacle2.GetLinkedTentacle() == tentacle1.GetLinkedTentacle());
        }
    }

    // Проверка самоприсваивания осьминогов
    {
        Octopus octopus(3);

        // Настраиваем состояние осьминога
        octopus.GetTentacle(0).LinkTo(octopus.GetTentacle(1));

        vector<pair<Tentacle*, Tentacle*>> tentacles;
        // Сохраняем информацию о щупальцах осьминога и его копии
        for (int i = 0; i < octopus.GetTentacleCount(); ++i) {
            tentacles.push_back({&octopus.GetTentacle(i), octopus.GetTentacle(i).GetLinkedTentacle()});
        }

        // Выполняем самоприсваивание
        octopus = octopus;

        // После самоприсваивания состояние осьминога не должно измениться
        assert(octopus.GetTentacleCount() == static_cast<int>(tentacles.size()));
        for (int i = 0; i < octopus.GetTentacleCount(); ++i) {
            auto& tentacle_with_link = tentacles.at(i);
            assert(&octopus.GetTentacle(i) == tentacle_with_link.first);
            assert(octopus.GetTentacle(i).GetLinkedTentacle() == tentacle_with_link.second);
        }
    }
} 

```

Классы `Octopus` и `Tentacle` возьмите из своего решения задачи предыдущего урока.

### Ограничения

Сохраните сигнатуры всех публичных методов классов `Octopus` и `Tentacle` неизменными, чтобы код скомпилировался без ошибок.

### Что отправлять на проверку

Решение должно включать исходный код класса `Octopus` и используемых им классов, а также необходимые для компиляции директивы `#include`. Функция `main` учитываться не будет.

### Как будет тестироваться ваш код

Гарантируется, что количество щупалец, передаваемое в параметризованный конструктор класса `Octopus`, неотрицательное. Проверять их количество в конструкторе необязательно. Максимальное количество щупалец, которое будет иметь осьминог, не превышает нескольких десятков

### Подсказка

Используйте обновлённый класс `PtrVector`, где корректно реализована операция присваивания. В класс `Octopus` вносить изменения не нужно. Помните: надёжный дом создаётся из надёжных кирпичей.