# Перегрузка операторов ввода-вывода

Начав использовать в коде собственные типы данных, вы быстро поймёте, что надо вводить и выводить классы и структуры, которые позволяют программе оперировать такими типами. Для этого используют перегрузку.

Перегрузка операторов позволяет нескольким вариантам использования оператора одновременно существовать в одной области видимости. Имя у вариантов одинаковое, а типы параметров, к которым они применяются, — разные.

Термин «перегрузка» — не слишком удачная калька с [overloading](https://en.cppreference.com/w/cpp/language/operators). Перегружая операторы, мы не взваливаем на них непосильную ношу. Это просто способ объявить в одной области видимости операции с одинаковыми названиями.

Но с перегрузкой нужно обращаться осторожно. Используйте её, только если она не усложнит чтение программы. Ваш код должен быть понятен другим разработчикам, и на это несколько причин:

-   Скорее всего, вы будете трудиться в команде;
-   Вы или ваши коллеги не раз станете рефакторить код;
-   Вы можете захотеть поделиться своей программой в GitHub.

Перегрузка предназначена для пользовательских типов и классов.

В прошлых уроках вы познакомились с перегрузкой операций вывода для контейнеров `vector`, `set` и `map`. Аналогично можно перегрузить оператор `<<` для ваших собственных классов, структур и перечислимых типов.

Оператор вывода в поток `<<` принимает два аргумента:

-   Ссылку на поток вывода `ostream`. Буква "o" в имени означает output.
-   Объект, выводимый в поток. Легковесные объекты передавайте по значению, а тяжеловесные — по константной ссылке.

Оператор `<<` должен возвращать ссылку на переданный ему поток, чтобы вывод нескольких объектов можно было объединять в цепочки вида `cout << value1 << value2`:

```cpp


ostream& operator<<(ostream& output, MyValue value) {
    /* Выводим содержимое объекта value в output */

    // Оператор должен вернуть ссылку на переданный поток вывода
    return output;
} 

```

Оператор чтения из потока `>>` также принимает два аргумента:

-   Ссылку на поток ввода `istream`. Буква `i` в имени означает input.
-   Ссылку на объект, считываемый из потока.

Оператор `>>` должен возвращать ссылку на переданный ему поток для объединения чтения нескольких объектов в цепочку: `cin >> value1 >> value2`:


```cpp

istream& operator>>(istream& input, MyValue& value) {
    /* Считываем из потока input значение объекта value */

    // Оператор должен вернуть ссылку на переданный поток ввода
    return input;
} 

```

Рассмотрим перегрузку операций ввода и вывода для структуры `Point`. Чтобы упростить код, обработка ошибок опущена:


```cpp

struct Point {
    int x;
    int y;
};

// вывод
ostream& operator<<(ostream& output, Point point) {
    output << point.x << ","s << point.y;
    return output;
}

// ввод
istream& operator>>(istream& input, Point& point) {
    int x, y;
    char comma; // переменная для считывания запятой
    input >> x >> comma >> y;
    point = Point{x, y};
    return input;
} 

```

Теперь вы можете справиться с печально известными `<<` и `>>` языка С++.


# Перегрузка арифметических операций

Перегрузка операций — мощное средство C++. Перегрузка позволяет выполнять арифметические и другие операции над пользовательскими типами данных естественным образом — то есть так же, как над встроенными типами.

Встроенные в язык типы, операторы, языковые конструкции — это атомы, из которых можно создать более крупные и абстрактные сущности — молекулы и организмы. Например, координаты точки на плоскости можно описать двумя переменными `x` и `y`, имеющими тип `double`. Но это будут разные переменные. На их связь с точкой будут указывать в лучшем случае комментарии в коде, а в худшем — только знания в голове программиста. Улучшить ситуацию можно. Используем класс и структуру и зададим новый тип данных «‎точка»‎:


```cpp

struct Point { 
double x, y; 
}; 

```

Теперь объявлять точку можем этим пользовательским типом:


```cpp
// объявляем точки p1 и p2
Point p1, p2; 

```


У нас появилась собранная из атомов молекула. В этой структуре можно написать методы, перегрузить операции. Тогда молекула будет обладать ещё и поведением. Во вселенной программы появится некоторое подобие законов физики. Всё новые и новые молекулы позволят программировать поведение сложной системы, такой как графический редактор, браузер, поисковая или операционная система.

Пользовательские типы — это классы, структуры, перечислимые типы и пока не знакомые вам объединения (`union`). При объявлении новых типов данных в коде появляются новые сущности из предметной области, где работает программа. Предметная область — часть реального или нереального мира, которую программа моделирует. Её ещё можно назвать контекстом.

У каждой предметной области свои особенности. Например, если создаём программу для работы с дробями, она должна подчиняться правилам арифметики. А предметная область бухгалтерской программы содержит термины вроде «счёт», «накладная», «контрагент».

В некоторой предметной области над вводимыми сущностями могут выполняться операции: сложение векторов, умножение матриц, арифметические операции над дробями. Применив перегрузку, вы сможете объявить в программе собственные операции над введёнными вами типами. Например, сложить дроби можно операцией сложения `number1 + number2` вместо многословной функции `AddRationals(number1, number2)`. Такой код быстрее писать и легче читать.

При правильном использовании перегрузка операций повысит выразительность вашего кода. Но в работе с таким инструментом есть ограничения:

-   Когда реализуете перегрузку операции, следите за тем, чтобы это органично вписывалось в программу, соответствовало предметной области и не вызывали вопросов у других разработчиков. Например, не стоит определять операцию сложения дроби со строкой. Если язык позволяет сделать что-то, не означает, что это нужно делать.
-   Перегрузка операций в C++ не изменяет размерность операций и их приоритет. Как и со встроенными типами данных, у операций умножения и деления над пользовательскими типами данных будет приоритет над операциями сложения и вычитания. Бинарные операции останутся бинарными, унарные — унарными.

Разработанный вами класс `Rational` позволяет хранить рациональные дроби в нормализованном виде, вводить и выводить их в потоки стандартной библиотеки. Чтобы работать с этим классом, как со встроенными числами, освоим перегрузку арифметических операций `+`, `-`, `*`, `/`.

### Арифметические операции с одинаковыми типами аргументов

Перегрузка арифметических операций `+`, `-`, `*`, `/` позволит выполнять арифметические операции над дробями естественным образом, как над целыми и вещественными числами:


```cpp

int main() {
    Rational r1{1, 6};
    Rational r2{1, 3};
    Rational sum = (r1 + r2) * r1;
    cout << sum << endl; // Выведет 1/12
} 

```

При перегрузке операторов в первую очередь руководствуйтесь предметной областью. Она накладывает ограничения на набор операций над типами и их семантику.

Арифметические операции `+`, `-`, `*`, `/` над типом `Rational` — это бинарные операции, принимающие два аргумента типа `Rational`. Результат — новое значение, также имеющее тип `Rational`. Эти операции не изменяют значения ни левого, ни правого аргументов.

Результатом сложения двух обыкновенных дробей, будет обыкновенная дробь, равная:

![image](https://pictures.s3.yandex.net/resources/Untitled_3_1600879129.png)

Чтобы задать операцию сложения, объявим функцию со специальным именем `operator+`, принимающую два рациональных числа и возвращающую результат типа `Rational`:



```cpp
Rational operator+(Rational left, Rational right) {
    const int numerator = left.Numerator() * right.Denominator() 
                  + right.Numerator() * left.Denominator();
    const int denominator = left.Denominator() * right.Denominator();

    return {numerator, denominator};
} 
```


Объекты `Rational` хранят два целых числа и считаются легковесными. Вот почему мы передаём дроби в функцию `operator+` по значению. Более тяжелые для копирования классы принимайте по константной ссылке, если функция или операция их не модифицирует.

Убедимся, что добавленная операция работает:


```cpp

int main() {
    Rational r1, r2;

    cout << "Введите первую дробь: "s;
    cin >> r1;

    cout << "Введите вторую дробь: "s;
    cin >> r2;

    cout << "Их сумма равна: "s << r1 + r2 << endl;
} 

```

Запустив программу, увидим:

`Введите первую дробь: 1/3
Введите вторую дробь: 1/6
Их сумма равна: 1/2` 

Но в классе `Rational` есть ещё один параметризованный конструктор, принимающий тип `int`:

```cpp


class Rational {
public:
    Rational(int value)
}; 

```

С этим конструктором мы можем складывать дроби не только между собой, но и с целыми числами. И наоборот:


```cpp

int main() {
    cout << "Введите первую дробь: "s;
    Rational rational;
    cin >> rational;

    cout << "Введите целое число: "s;
    int integer;
    cin >> integer;

    cout << "Их сумма равна: "s << rational + integer << endl;
} 

```

Здесь компилятор обнаружит выражение `rational + integer` и будет искать версию `operator+`, принимающую типы `Rational` и `int`. Но мы её не написали. Поэтому не найдёт и попытается преобразовать типы аргументов под имеющиеся операции. Увидев оператор сложения двух аргументов `Rational`, компилятор превратит второй параметр из `int` в `Rational`. Для этого неявно вызовется конвертирующий конструктор, как если бы мы написали:


```cpp

cout << "Их сумма равна: "s << rational + Rational{integer} << endl; 

```

### Арифметические операции с разными типами аргументов

Типы аргументов бинарной арифметической операции не обязательно должны быть одинаковыми. Правила определяются особенностями предметной области.

Рассмотрим операцию умножения двухмерного вектора и скаляра. В результате операции получается новый отмасштабированный двухмерный вектор. При этом умножать можно не только вектор на скаляр, но и скаляр на вектор. Для этого реализуем две версии операции умножения — `vector*scalar` и `scalar*vector`:


```cpp

// Здесь мы объявляем структуру, а не класс, так как поля структуры 
// могут принимать произвольные значения
struct Vector2D {
    // Такая запись сообщает компилятору, чтобы он сгенерировал конструктор по умолчанию,
    // в котором поля x и y проинициализировал значениями, заданными при их объявлении
    Vector2D() = default;

    Vector2D(double x0, double y0)
        : x(x0), y(y0) {
    }

    // Задаем значения по умолчанию для полей структуры
    double x = 0.0;
    double y = 0.0;
};

// Операция умножения вектора на скаляр
Vector2D operator*(Vector2D vector, double scalar) {
    return {vector.x * scalar, vector.y * scalar};
}

// Операция умножения скаляра на вектор
Vector2D operator*(double scalar, Vector2D vector) {
    // Благодаря коммутативности операции умножения, мы можем выразить 
    // умножение скаляра на вектор через операцию умножения вектора на скаляр
    return vector * scalar;
} 

```

Аргументы бинарной операции могут быть одного типа или разных. При этом может понадобиться реализовать для них две перегрузки в зависимости от порядка операндов или только одну. Всё определяется предметной областью. Например, операция деления вектора на скаляр существует, а обратная операция деления скаляра на вектор — нет.

### Перегрузка унарного плюса и минуса

Для дробей и векторов помимо бинарных арифметических операций, существуют операции унарного плюса и минуса. Они используются в выражениях вроде:

```cpp


int main() {
    const Vector2D v1{1, 7}
    const Vector2D minus_v1 = -v1; // вызов унарного минуса
    const Vector2D plus_v1 = +v1;  // вызов унарного плюса
} 

```

Чтобы перегрузить унарный плюс и минус, задают операции `operator+` и `operator-` с единственным аргументом. Унарный плюс должен возвращать копию своего аргумента, а унарный минус — противоположное по знаку значение. Например, для типа `Vector2D` операции унарного плюса и минуса можно задать так:

```cpp


// Операция унарного плюса возвращает копию переданного вектора
Vector2D operator+(Vector2D v) {
    return v;
}

// Операция унарного минуса возвращает вектор с противоположным направлением
Vector2D operator-(Vector2D v) {
    return {-v.x, -v.y};
} 

```

Уметь работать с унарными операциями — значит эффективно использовать средства языка. В любой нетривиальной программе вы не раз будете самостоятельно реализовать хотя бы некоторые из таких операций, либо использовать написанные коллегами.

# Перегрузка операций присваивания

Вы уже знаете, что несмотря на суровость C++, в нём есть синтаксический сахар. К синтаксическому сахару относятся, например, лямбда-функции и краткая форма операций присваивания, таких как `+=`, `-=`, `*=` и `/=`.

`a += b` — лаконичная запись арифметического выражения `a = a + b`.

`a -= b` — лаконичная запись арифметического выражения `a = a - b`.

`a *= b` — лаконичная запись арифметического выражения `a = a * b`.

`a /= b` — лаконичная запись арифметического выражения `a = a / b`.

Эти операции можно задать и для пользовательских типов.

В C++ операции присваивания объявляются внутри класса, подобно методам. Левым аргументом такой операции будет текущий объект, а правый передаётся как единственный параметр операции.

Для примера рассмотрим перегрузку операции `+=` в структуре `Vector2D`:


```cpp
struct Vector2D {
    Vector2D() = default;

    Vector2D(double x0, double y0)
        : x(x0), y(y0) {
    }

    // левый аргумент операции += — это текущий экземпляр класса,
    // а правый передаётся в виде параметра операции
    Vector2D& operator+=(Vector2D right) {
        // Результат операции сохраняется в текущем экземпляре класса
        x += right.x;
        y += right.y;
        
        // return *this позволяет вернуть ссылку на текущий объект
        return *this;
    }

    double x = 0.0;
    double y = 0.0;
}; 
```

В отличие от операции сложения, `+=` не возвращает новый вектор, а записывает результат в текущий объект и возвращает ссылку на него командой `return *this`.

В C++ присваивающие выражения для встроенных типов и большинства классов стандартной библиотеки модифицируют левый аргумент операции и возвращают ссылку на него. Так на основе операций присваивания можно компактно реализовать соответствующие бинарные операции вроде `+`, `-` , `*` и `/`.

Например, задав `+=`, реализуем операцию сложения буквально в одну строку кода:


```cpp
Vector2D operator+(Vector2D left, Vector2D right) {
    // аргумент left принят по значению; можно спокойно модифицировать
    // это значение внутри операции и вернуть в виде результата
    return left += right;
} 
```

Левый аргумент операции `+` здесь передаётся по значению. Это позволяет кратко записать тело оператора и помогает компилятору оптимизировать цепочку вызовов вида `a + b + c`.

Пример использования:


```cpp
int main() {
    Vector2D v1{1, 2};
    Vector2D v2{6, 1};

    // Сначала вычислится выражение в скобках (v1 += v2), в результате чего 
    //   v1 примет значение {13, 2}, а само выражение вернёт ссылку на v1.
    // Затем вычислится выражение v2 + v1, в результате чего 
    //   в переменную v3 будет записано значение {25, 2}.
    // Переменная v2 своего значения не изменит
    Vector2D v3 = v2 + (v1 += v2);

    cout << v1.x << ","s << v1.y << endl; // Выведет 13,2
    cout << v2.x << ","s << v2.y << endl; // Выведет 6,1
    cout << v3.x << ","s << v3.y << endl; // Выведет 25,2
}
```
# Перегрузка операций сравнения

Над пользовательскими типами данных проводят не только арифметические операции или операции ввода и вывода. Любой нетривиальный алгоритм использует ветвления и циклы, в которых часто задействованы операции сравнения.

Операции сравнения `==`, `!=`, `<`, `>`, `<=`, `>=` для пользовательских типов данных в С++ можно задать так же, как арифметические. Перегружать все операции сравнения или только часть, решают исходя из предметной области. Например, для дробей имеет смысл задать все операции, а чтобы сравнить векторы на плоскости или комплексные числа нужны только `==` и `!=`, потому что для векторов и комплексных чисел операции `<`, `>`, `≤` и `≥` в математике не определены.

Реализуем для класса `Rational` операцию `operator==`. Здесь пригодится то, что дроби мы храним в нормализованном виде. Чтобы проверить их на равенство, достаточно сравнить их числители и знаменатели:


```cpp
bool operator==(Rational left, Rational right) {
    return left.Numerator() == right.Numerator() && 
           left.Denominator() == right.Denominator();
} 
```

Операции сравнения возвращают результат типа `bool` и не изменяют значения своих аргументов. Чтобы избежать глубокого копирования тяжеловесных типов данных, передавайте их в операцию сравнения по константной ссылке. Легковесные типы данных такие как `Rational` можно передавать по значению.

На основе операции `==` легко реализовать `!=`:

```cpp

bool operator!=(Rational left, Rational right) {
    return !(left == right);
} 
```

Теперь благодаря конструктору, создающему дробь из целого числа, можно сравнивать дроби на равенство между собой и с целыми числами:

```cpp
int main() {
    cout << "Введите две обыкновенные дроби в формате x/y:"s << endl;
    Rational a, b;
    cin >> a >> b;

    // Аналогично if (b != Rational{0})
    if (b != 0) {
        cout << "Их частное равно "s << a / b << endl;
    } else {
        cout << "Невозможно найти частное, так как делитель равен 0"s << endl;
    }
}

```
