### Задание

Это задание выполните и протестируйте в своей IDE. Сохраните решение. Оно понадобится вам для итогового проекта пятого спринта.

Внесите небольшую модификацию в свой поисковый сервер. Пусть он выводит время выполнения запросов `FindTopDocuments` и `MatchDocuments` в `cout`. Для этого расширьте класс `LogDuration` так, чтобы его конструктор принимал второй аргумент типа `ostream&`, по умолчанию равный `cerr` — потоку, в который он будет выводить свой вердикт. Добавьте макрос `LOG_DURATION_STREAM`. Использовать это нужно так:


```cpp

...
// без макроса
{
    LogDuration guard("Long task", cout);
    PerformLongTask();
}

// с макросом
{
    LOG_DURATION_STREAM("Long task", cout);
    PerformLongTask();
}
... 

```

Диагностика, выводимая в `cout`, должна называться `Operation time`. Допустим, в `main` документы ищутся так:


```cpp

MatchDocuments(search_server, "пушистый -пёс"s);
...
FindTopDocuments(search_server, "пушистый -кот"s); 

```

Тогда вы должны увидеть примерно такой вывод:


```cpp

Матчинг документов по запросу: пушистый -пёс
{ document_id = 1, status = 0, words = пушистый}
...
{ document_id = 4, status = 0, words =}
Operation time: 15 ms
...
Результаты поиска по запросу: пушистый -кот
{ document_id = 1, relevance = 0.143844, rating = 5 }
...
{ document_id = 17, relevance = 0.143844, rating = 5 }
Operation time: 76 ms 

```

Не забудьте сохранить своё решение.




## Задание

Это задание — итоговый проект пятого спринта. Вы будете сдавать его на проверку через репозиторий на GitHub. Не забудьте сохранить верное решение.

Расширьте поисковый сервер, добавив в него дополнительные методы.

1.  Откажитесь от метода `GetDocumentId(int index)` и вместо него определите методы `begin` и `end`. Они вернут итераторы. Итератор даст доступ к id всех документов, хранящихся в поисковом сервере. Вы можете не разрабатывать собственный итератор, а применить готовый константный итератор удобного контейнера.
    
    Если `begin` и `end` определены корректно, появится возможность использовать упрощённую форму `for` с поисковым сервером:
    
	```cpp
     SearchServer search_server;
    
     for (const int document_id : search_server) {
         // ...
     }
    ```
	
2.  Разработайте метод получения частот слов по id документа:
    
```cpp   
const map<string, double>& GetWordFrequencies(int document_id) const;` 
    
    Если документа не существует, возвратите ссылку на пустой `map`.
```
    
3.  Разработайте метод удаления документов из поискового сервера
    
```cpp
 
void RemoveDocument(int document_id); 
    
```

4.  Вне класса сервера разработайте функцию поиска и удаления дубликатов:
   
    ```cpp
     void RemoveDuplicates(SearchServer& search_server);
    ```
    Дубликатами считаются документы, у которых наборы встречающихся слов совпадают. Совпадение частот необязательно. Порядок слов неважен, а стоп-слова игнорируются. Функция должна использовать только доступные к этому моменту методы поискового сервера.
    
    При обнаружении дублирующихся документов функция должна удалить документ с большим id из поискового сервера, и при этом сообщить id удалённого документа в соответствии с форматом выходных данных, приведённым ниже.
    

Будьте аккуратны, если функция `RemoveDuplicates` проходит циклом по поисковому серверу так:


```cpp

void RemoveDuplicates(SearchServer& search_server) {
    ...
    for (const int document_id : search_server) {
        ...
    }
    ...
} 

```

В подобном случае удалять документы внутри цикла нельзя — это может привести к невалидности внутреннего итератора.

Все реализации должны быть эффективными. Если N— общее количество документов, а W — количество слов во всех документах, то:

-   сложность `GetWordFrequencies` должна быть $O(\log N)$;
-   сложность `RemoveDocument` должна быть $O(w(\log N+\log W))$, где w — количество слов в удаляемом документе;
-   сложность `begin` и `end` —$O(1)$;
-   сложность `RemoveDuplicates` должна быть $O(wN(\log N+\log W))$, где w — максимальное количество слов в документе.

В этом задании может потребоваться рефакторинг вашего кода. Например, замена одного вида контейнера на другой или введение нового индекса.

Вам предстоит оценить сложность разрабатываемых алгоритмов, чтобы знать, что они достаточно быстрые.

### Формат выходных данных

Функция `RemoveDuplicates` должна для каждого удаляемого документа вывести в `cout` сообщение в формате `Found duplicate document id N`, где вместо `N` следует подставить id удаляемого документа.

### Ограничения

Сохраните корректную и быструю работу всех методов кроме `GetDocumentId`.

### Что отправлять на проверку

Загрузите полный код поискового сервера и вспомогательных функций. Код нужно разбить на файлы. Функция `main` при проверке будет игнорироваться.

### Пример использования

```cpp


int main() {
    SearchServer search_server("and with"s);

    AddDocument(search_server, 1, "funny pet and nasty rat"s, DocumentStatus::ACTUAL, {7, 2, 7});
    AddDocument(search_server, 2, "funny pet with curly hair"s, DocumentStatus::ACTUAL, {1, 2});

    // дубликат документа 2, будет удалён
    AddDocument(search_server, 3, "funny pet with curly hair"s, DocumentStatus::ACTUAL, {1, 2});

    // отличие только в стоп-словах, считаем дубликатом
    AddDocument(search_server, 4, "funny pet and curly hair"s, DocumentStatus::ACTUAL, {1, 2});

    // множество слов такое же, считаем дубликатом документа 1
    AddDocument(search_server, 5, "funny funny pet and nasty nasty rat"s, DocumentStatus::ACTUAL, {1, 2});

    // добавились новые слова, дубликатом не является
    AddDocument(search_server, 6, "funny pet and not very nasty rat"s, DocumentStatus::ACTUAL, {1, 2});

    // множество слов такое же, как в id 6, несмотря на другой порядок, считаем дубликатом
    AddDocument(search_server, 7, "very nasty rat and not very funny pet"s, DocumentStatus::ACTUAL, {1, 2});

    // есть не все слова, не является дубликатом
    AddDocument(search_server, 8, "pet with rat and rat and rat"s, DocumentStatus::ACTUAL, {1, 2});

    // слова из разных документов, не является дубликатом
    AddDocument(search_server, 9, "nasty rat with curly hair"s, DocumentStatus::ACTUAL, {1, 2});
    
    cout << "Before duplicates removed: "s << search_server.GetDocumentCount() << endl;
    RemoveDuplicates(search_server);
    cout << "After duplicates removed: "s << search_server.GetDocumentCount() << endl;
} 

```

Ожидаемый вывод этой программы:


```cpp

Before duplicates removed: 9
Found duplicate document id 3
Found duplicate document id 4
Found duplicate document id 5
Found duplicate document id 7
After duplicates removed: 5
```


# 5_4

## Задание

Попрактикуйтесь использовать константные указатели на примере программы, которая ведёт учёт кошек. В ней кошки представлены структурой `Cat`, задающей имя, пол, породу и возраст:


```cpp

// Породы кошек
enum class CatBreed {
    Bengal,
    Balinese,
    Persian,
    Siamese,
    Siberian,
    Sphynx,
};

// Пол
enum class Gender {
    Male,
    Female,
};

struct Cat {
    string name;
    Gender gender;
    CatBreed breed;
    int age;
}; 

```

Для хранения кошек используется контейнер `vector`:


```cpp

int main() {
    const vector<Cat> cats = {
        {"Tom"s, Gender::Male, CatBreed::Bengal, 2},
        {"Leo"s, Gender::Male, CatBreed::Siberian, 3},
        {"Luna"s, Gender::Female, CatBreed::Siamese, 1},
        {"Charlie"s, Gender::Male, CatBreed::Balinese, 7},
        {"Ginger"s, Gender::Female, CatBreed::Sphynx, 5},
        {"Tom"s, Gender::Male, CatBreed::Siamese, 2},
    };
    ...
} 
```


Требуется создать в программе несколько одновременно существующих представлений этой коллекции, отсортированных по разным критериям:

1.  По породе и имени. Кошки одинаковой породы сортируются по имени.
2.  По полу и породе.

Простейшее решение — создать несколько копий вектора кошек и отсортировать их по заданным критериям. Основной недостаток решения — избыточное потребление памяти. Каждая кошка будет храниться в нескольких экземплярах со всеми своими данными. Представьте, что вам пришлось бы клонировать оригинальный набор кошек, а потом отсортировать копию каждого набора. Слишком много кошек!

Более эффективно хранить каждую кошку в единственном экземпляре в контейнере `cats`. Отсортированное представление контейнера `cats` можно задать в виде вектора указателей, которые ссылаются на кошек из `cats` и отсортированы как надо. Для хранения указателя нужно в несколько раз меньше памяти, чем для хранения данных о кошке. Такое решение аналогично сортировке листков бумаги с адресами этих замечательных животных.

![image](https://pictures.s3.yandex.net/resources/pointer_to_const_6_2_1643278635.png)_Два индекса используют одни и те же данные_

### Требования

Напишите

-   шаблонную функцию `GetSortedCats`, которая принимает константную ссылку на массив кошек,
-   функцию-компаратор, которая проверяет кошек на упорядоченность.

`GetSortedCats` должна вернуть контейнер `vector<const Cat*>`, содержащий указатели на элементы вектора кошек. Для сортировки указателей используйте переданную функцию-компаратор:


```cpp

// Возвращает массив указателей на элементы вектора cats, отсортированные с использованием
// компаратора comp. Компаратор comp - функция, принимающая два аргумента типа const Cat&
// и возвращающая true, если значения упорядочены, и false в ином случае
template <typename Comparator>
vector<const Cat*> GetSortedCats(const vector<Cat>& cats, const Comparator& comp) {
    ...
}

int main() {
    const vector<Cat> cats = { ... };

    auto sorted_cats = GetSortedCats(cats, [](const Cat& lhs, const Cat& rhs) {
        // Сравниваем кошек по породе и имени
        return tie(lhs.breed, lhs.name) < tie(rhs.breed, rhs.name);
    });
    // sorted_cats - вектор указателей на кошек, отсортированных по кличке и имени
    ...
} 

```

Чтобы вывести информацию о кошках из массива указателей, напишите функцию `PrintCatPointerValues`:


```cpp

// Выводит в поток out кошек, на которых ссылаются указатели вектора cat_pointers.
// Пример вывода:
// {{Tom, male, breed: Bengal, age:2}, {Charlie, male, breed: Balinese, age:7}}
void PrintCatPointerValues(const vector<const Cat*>& cat_pointers, ostream& out) {
    ...
}

int main() {
    ...
    auto sorted_cats = GetSortedCats(...);
    PrintCatPointerValues(sorted_cats, cout);
    ...
} 

```

В заготовке кода есть готовые операции вывода кошек в поток.

### Ограничения

Вектор кошек, передаваемый в функцию `GetSortedCats`, может содержать от 0 до 1000000 кошек. Клички кошек могут содержать буквы английского алфавита в разном регистре и пробелы, например: “Cat in Boots”.

### Что отправлять на проверку

Загрузите в тренажёр код программы без функции `main`. Функция `main`, если она будет загружена в тренажёр, будет заменена на версию из тренажёра.


### Подсказка

Чтобы получить отсортированное представление, создайте вектор указателей, ссылающихся на элементы оригинального контейнера кошек. Затем отсортируйте этот вектор как нужно. Программа должна сортировать указатели, сравнивая их значения, а не их адреса. Пример:


```cpp

#include <algorithm>
#include <cassert>
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> items = {5, 2, 3, 4};
    vector<const int*> item_pointers;
    // Перебирать элементы вектора здесь следует по константной ссылке,
    // а не по значению.
    // В противном случае item_pointers будут хранить адреса объектов,
    // область видимости которых ограничена телом цикла
    for (const int& item : items) {
        item_pointers.push_back(&item);
    }

    // сортируем указатели в порядке убывания чисел, на которые они ссылаются.
    sort(item_pointers.begin(), item_pointers.end(), [](const int* lhs, const int* rhs) {
        // Чтобы сравнить значения, надо разыменовать указатели
        return *lhs > *rhs;
    });

    for (const int* item_ptr : item_pointers) {
        cout << *item_ptr << ", "s;
    }
}
```
# 5_8

## Задание 1

У вас есть каркас шаблонного класса `ScopedPtr`. Это умный указатель, в котором частично реализован такой функционал:

-   Конструктор по умолчанию инициализирует указатель нулевым значением;
-   Заготовка метода `GetRawPtr`. Метод возвращает адрес объекта, на который ссылается умный указатель;
-   Заготовка конвертирующего конструктора для создания `ScopedPtr` из сырого указателя;
-   Удалённый конструктор копирования. В этом случае создать копию умного указателя будет нельзя. Как следствие, не будет проблем, когда два умных указателя владеют одним объектом.


```cpp

template <typename T>
class ScopedPtr {
public:
    ScopedPtr() = default;
    explicit ScopedPtr(T* raw_ptr) noexcept {...}
    ScopedPtr(const ScopedPtr&) = delete;
    ~ScopedPtr() {...}
    T* GetRawPtr() const noexcept {...}
    T* Release() noexcept {...}

private:
    T* ptr_ = nullptr;
}; 

```

Объект класса `ScopedPtr<T>` может находиться в двух состояниях: владеть объектом типа `T` или не владеть. При этом должны выполняться следующие правила:

-   Конструктор без параметров создаёт умный указатель, не владеющий объектом.
-   Конструктор `ScopedPtr(T* raw_ptr)` создаёт умный указатель, который владеет объектом, если и только если переданный указатель не был равен `nullptr`.
-   Метод `GetRawPtr` не влияет на владение.
-   Метод `Release` отменяет владение, если оно было.

Цель умного указателя — удалить объект, которым он владеет. Он должен делать это в своём деструкторе, который вам предстоит реализовать вместе с недостающими методами.

Проверки в заготовке кода упростят реализацию конструкторов и деструкторов.

### Требования

Реализуйте недостающие методы класса `ScopedPtr`:

-   Недостающий код конструктора `ScopedPtr` из «сырого»‎ указателя на объект в динамической памяти. Созданный `ScopedPtr` должен владеть переданным объектом. Допустимо значение указателя `nullptr`. В этом случае владения не возникает.
-   Тело метода `GetRawPtr`.
-   Удаление объекта, которым владеет `ScopedPtr`, в деструкторе.
-   Тело метода `Release`.

### Ограничения

Сохраните сигнатуры всех публичных методов класса `ScopedPtr` неизменными, чтобы код скомпилировался без ошибок.

### Что отправлять на проверку

Загрузите в тренажёр только код с шаблоном класса `ScopedPtr` и нужными для его работы директивами `#include`. Функция `main` при проверке учитываться не будет.

### Подсказка

-   Используйте проверки в функции `main` из заготовки кода.
-   В конвертирующем конструкторе сохраните переданный «‎сырой»‎ указатель в поле `ptr_`.
-   В методе `GetRawPtr` верните текущее значение `ptr_`.
-   Удалите объект, на который ссылается поле `ptr_` в деструкторе.
-   В методе `Release` обнулите поле `ptr_`, не удаляя сам объект, и верните прежнее значение поля.

## Задание 2

Вы сделали класс `ScopedPtr` умным. Осталось превратить его в указатель.

Переопределите операции разыменования `*` и доступа к полям класса `->`. При попытке вызвать их у нулевого указателя эти операции должны выбрасывать исключение `std::logic_error`, а не приводить к неопределённому поведению. Всё-таки это умный указатель. Перегруженная операция приведения к типу `bool` облегчает проверку на `nullptr`.

В заготовке кода — ваше решение предыдущей задачи. На его основе реализуйте недостающие операции.

Сигнатура новых операций умного указателя:


```cpp

// Умный указатель, удаляющий связанный объект при своём разрушении.
// Параметр шаблона T задаёт тип объекта, на который ссылается указатель
template <typename T>
class ScopedPtr {
public:
    //...

    // Оператор приведения к типу bool позволяет узнать, ссылается ли умный указатель
    // на какой-либо объект
    explicit operator bool() const noexcept {
        // Реализуйте самостоятельно
    }

    // Оператор разыменования возвращает ссылку на объект
    // Выбрасывает исключение std::logic_error, если указатель нулевой
    T& operator*() const {
        // Реализуйте самостоятельно
    }

    // Оператор -> должен возвращать указатель на объект
    // Выбрасывает исключение std::logic_error, если указатель нулевой
    T* operator->() const {
        // Реализуйте самостоятельно
    }

    // ...

private:
    T* ptr_ = nullptr;
}; 

```

Оператор преобразования к типу `bool` объявлен `explicit`, чтобы запретить неявное преобразование указателя в `bool`, которое практически всегда нежелательно. На проверке указателя в условии `if` это не отразится.


```cpp

void Fn(int i);

int main() {
    ScopedPtr<Object> p(new Object());
    Fn(p); // Когда operator bool объявлен explicit, здесь будет ошибка компиляции
           // Без explicit в Fn будет передано значение 1
} 

```

Пример использования `ScopedPtr` и тесты, которые помогут вам решить задачу, даны ниже.


```cpp

#include <cassert>

// Умный указатель, удаляющий связанный объект при своём разрушении.
// Параметр шаблона T задаёт тип объекта, на который ссылается указатель
template <typename T>
class ScopedPtr {
    ...
};

// Этот main тестирует класс ScopedPtr
int main() {
    // Проверка работы оператора приведения к типу bool
    {
        // Для нулевого указателя приведение к типу bool возвращает false
        const ScopedPtr<int> empty_ptr;
        assert(!empty_ptr);

        // Для ненулевого указателя приведение к типу bool возвращает true
        const ScopedPtr<int> ptr_to_existing_object(new int(0));
        assert(ptr_to_existing_object);

        static_assert(noexcept(static_cast<bool>(ptr_to_existing_object)));
    }

    // Проверка работы оператора разыменования *
    {
        string* raw_ptr = new string("hello");
        ScopedPtr<string> smart_ptr(raw_ptr);
        // Ссылка, возвращаемая оператором разыменования, должна ссылаться на объект,
        // на который указывает умный указатель
        assert(&*smart_ptr == raw_ptr);

        try {
            ScopedPtr<int> empty_ptr;
            // При попытке разыменовать пустой указатель должно быть выброшено
            // исключение logic_error
            *empty_ptr;
            // Сюда попасть мы не должны
            assert(false);
        } catch (const logic_error&) {
            // мы там, где нужно
        } catch (...) {
            // Других исключений выбрасываться не должно
            assert(false);
        }
    }

    // Проверка работы оператора ->
    {
        string* raw_ptr = new string("hello");
        ScopedPtr<string> smart_ptr(raw_ptr);
        // Доступ к членам класса через умный указатель должен быть аналогичен
        // доступу через "сырой" указатель
        assert(smart_ptr->data() == raw_ptr->data());

        try {
            ScopedPtr<string> empty_ptr;
            // При попытке разыменовать пустой указатель должно быть выброшено
            // исключение logic_error
            empty_ptr->clear();
            // Сюда попасть мы не должны
            assert(false);
        } catch (const logic_error&) {
            // мы там, где нужно
        } catch (...) {
            // Других исключений выбрасываться не должно
            assert(false);
        }
    }

    // Пример использования
    {
        // На этой структуре будет проверяться работа умного указателя
        struct Object {
            Object() {
                cout << "Object is default constructed"s << endl;
            }
            void DoSomething() {
                cout << "Doing something"s << endl;
            }
            ~Object() {
                cout << "Object is destroyed"s << endl;
            }
        };

        // Сконструированный по умолчанию указатель ссылается на nullptr
        ScopedPtr<Object> empty_smart_ptr;
        // Перегруженный оператор приведения к типу bool вернёт false для пустого указателя
        assert(!empty_smart_ptr);

        ScopedPtr<Object> smart_ptr(new Object());
        // Перегруженный оператор bool вернёт true для указателя, ссылающегося на объект
        assert(smart_ptr);

        // Проверка оператора разыменования
        (*smart_ptr).DoSomething();
        // Проверка оператора доступа к членам класса
        smart_ptr->DoSomething();
    }
} 

```

### Ограничения

Указатели, передаваемые в методы класса, либо ссылаются на объект, созданный в куче при помощи операции `new`, либо равны `nullptr`.

### Как и что отправлять на проверку

Только код с шаблоном класса `ScopedPtr` и необходимыми для его работы директивами `#include`. Если отправите `main`, она будет заменена на версию из тренажёра.

### Подсказка

-   В операциях `*` и `->` сначала проверьте сырой указатель на равенство `nullptr` и выбросьте исключение `logic_error` в случае, когда эти операции вызваны у пустого `ScopedPtr`. Если всё хорошо, верните ссылку или указатель на объект в зависимости от реализуемой операции.
-   В операции приведения к `bool` верните `false`, если `ScopedPtr` ссылается на `nullptr`, и `true` в ином случае.

# 5_9

## Задание 1

Разработайте шаблонный класс `PtrVector`, оборачивающий вектор указателей. Объекты, на которые ссылаются эти указатели, должны размещаться в динамической памяти. В деструкторе `PtrVector` должен удалить объекты по хранящимся в нём указателям. Данные он размещает в контейнере `vector`.

Конструктор копирования `PtrVector` должен копировать объекты исходного вектора. При этом нулевые указатели исходного вектора остаются нулевыми в векторе-копии.

![image](https://pictures.s3.yandex.net/resources/Group_1100_4_1643309202.png)_Исходный PtrVector и его копия_

### Ограничения

Сохраните сигнатуры всех публичных методов класса `PtrVector` неизменными, чтобы код скомпилировался без ошибок.

### Пример

Пример использования дан в заготовке решения.

### Что отправлять на проверку

В решении должна быть реализация `PtrVector` со всеми методами и `#include`-директивы. Функция `main` учитываться не будет.

### Подсказка 

-   В деструкторе `PtrVector` примените операцию `delete` к каждому указателю внутри `items_`.
-   Обработку исключений в коде копирующего конструктора можно упростить: используйте метод `reserve` и зарезервируйте в векторе место для хранения нужного количества щупалец. Тогда метод `push_back` не будет выбрасывать исключений.

## Задание 2

Для съёмок блокбастера «Атака октоклонов» нужно изготовить 1000 копий осьминогов на основе имеющегося осьминога-прототипа.

В классе `Octopus` не задан пользовательский конструктор копирования. Копирующий конструктор, сгенерированный компилятором, копирует осьминогов некорректно: несколько осьминогов используют щупальца прототипа. Это приводит к неопределённому поведению.

Реализуйте следующий функционал:

-   Корректное клонирование осьминогов, при котором копия будет иметь свой набор щупалец, а не пользоваться щупальцами оригинала. Щупальца копии осьминога должны прицепляться к тем же щупальцам, что и оригинал.
-   Метод `AddTentacle` для добавления новых щупалец. Добавление должно сохранять адрес размещения существующих щупалец в памяти. `id` щупальца должен быть равен текущему количеству щупалец, увеличенному на 1.

Проверки, которые есть в функции `main`, упростят разработку.

### Ограничения

Гарантируется, что количество щупалец, передаваемое в параметризованный конструктор класса `Octopus`, неотрицательное. Проверять их количество в конструкторе необязательно. Максимальное количество щупалец, которое будет иметь осьминог, не превысит несколько десятков.

### Что отправлять на проверку

Решение должно включать исходный код класса `Octopus` и используемых им классов, а также нужные для компиляции директивы `#include`. Функция `main` не учитывается.

### Подсказка

-   Используйте классы `ScopedPtr` и `PtrVector`. С ними класс `Octopus` станет заметно проще.
-   Когда щупальца хранятся внутри `PtrVector`, создавать собственный конструктор копирования и деструктор для класса `Octopus` не придётся — конструктор копирования `PtrVector` корректно скопирует щупальца, а деструктор удалит их.

# 5_10

## Задание 1

Реализуйте операцию присваивания в классе `PtrVector`. Операция должна обеспечивать строгую гарантию безопасности исключений. Если в процессе присваивания будет выброшено исключение, `PtrVector` должен остаться в состоянии, в котором он был до выполнения этой операции.

В заготовке кода вы видите тесты, которые упрощают проверку задачи. Также там приведена допустимая реализация `PtrVector` из предыдущей задачи. Вы можете заменить её на свою.

### Ограничения

Сохраните сигнатуры всех публичных методов класса `PtrVector` неизменными, чтобы код скомпилировался без ошибок.

Ваши реализации методов должны обеспечивать строгую гарантию исключений.

### Что отправлять на проверку

В решении должна быть реализация `PtrVector` со всеми методами, включая `operator=`, а также `#include`-директивы. Функция `main` учитываться не будет.


### Подсказка

-   Чтобы написать надёжную операцию присваивания, используйте идиому copy-and-swap.
-   Пригодится метод `swap` класса `vector`. Этот метод обменивает содержимое двух контейнеров за время O(1) и не выбрасывает исключений.

# 6_2

## Задание

Создайте шаблонный класс односвязного списка `SingleLinkedList<Type>` со следующим функционалом:

-   конструктор по умолчанию, который создаёт пустой список;
-   метод `GetSize`, который возвращает количество элементов в списке;
-   метод `IsEmpty`, который возвращает `true`, если список пустой, и `false` в противном случае.

### Что отправлять на проверку

Только код с шаблоном класса `SingleLinkedList` и нужными для его работы директивами `#include`. Функция `main`, будет проигнорирована.

### Ограничения

Сохраните сигнатуры всех публичных методов класса `SingleLinkedList` неизменными, чтобы код скомпилировался без ошибок.

Не изменяйте поля класса: не добавляйте новые и не удаляйте старые, а также не меняйте их порядок.

### Подсказка

-   Односвязный список считается пустым, только если в нём ноль элементов.
-   Не мудрите — в этом задании нужно всего лишь реализовать пустой односвязный список.
-   Если явно заданных конструкторов нет, компилятор сам сгенерирует конструктор по умолчанию. Не забудьте задать корректные значения полям класса.

# 6_3 
## Задание

Реализуйте операцию `PushFront`, которая делает вставки элемента в начало односвязного списка, и операцию `Clear`, очищающую список.

Метод `PushFront` должен предоставлять строгую гарантию безопасности исключений: если в процессе работы метода будет выброшено исключение, состояние списка должно быть таким же, как до вызова метода.

Метод `Clear` очищает список и не должен выбрасывать исключений. Считается, что деструктор типа `Type` не выбрасывает исключений.

При разрушении списка должны быть удалены все его элементы.

Сигнатура методов:


```cpp

template <typename Type>
class SingleLinkedList {
public:
    ...
    // Вставляет элемент value в начало списка за время O(1)
    void PushFront(const Type& value) {
        // Реализуйте метод самостоятельно
    }

    // Очищает список за время O(N)
    void Clear() noexcept {
        // Реализуйте метод самостоятельно
    }
    ...
}; 

```

Пример использования и тесты методов `PushFront`, `Clear` и деструктора `SingleLinkedList`:


```cpp

#include <cassert>
#include <cstddef>
#include <string>
#include <utility>

template <typename Type>
class SingleLinkedList {
    ...
};

// Эта функция тестирует работу SingleLinkedList
void Test1() {
    // Шпион, следящий за своим удалением
    struct DeletionSpy {
        DeletionSpy() = default;
        explicit DeletionSpy(int& instance_counter) noexcept
            : instance_counter_ptr_(&instance_counter)  //
        {
            OnAddInstance();
        }
        DeletionSpy(const DeletionSpy& other) noexcept
            : instance_counter_ptr_(other.instance_counter_ptr_)  //
        {
            OnAddInstance();
        }
        DeletionSpy& operator=(const DeletionSpy& rhs) noexcept {
            if (this != &rhs) {
                auto rhs_copy(rhs);
                std::swap(instance_counter_ptr_, rhs_copy.instance_counter_ptr_);
            }
            return *this;
        }
        ~DeletionSpy() {
            OnDeleteInstance();
        }

    private:
        void OnAddInstance() noexcept {
            if (instance_counter_ptr_) {
                ++(*instance_counter_ptr_);
            }
        }
        void OnDeleteInstance() noexcept {
            if (instance_counter_ptr_) {
                assert(*instance_counter_ptr_ != 0);
                --(*instance_counter_ptr_);
            }
        }

        int* instance_counter_ptr_ = nullptr;
    };

    // Проверка вставки в начало
    {
        SingleLinkedList<int> l;
        assert(l.IsEmpty());
        assert(l.GetSize() == 0u);

        l.PushFront(0);
        l.PushFront(1);
        assert(l.GetSize() == 2);
        assert(!l.IsEmpty());

        l.Clear();
        assert(l.GetSize() == 0);
        assert(l.IsEmpty());
    }

    // Проверка фактического удаления элементов
    {
        int item0_counter = 0;
        int item1_counter = 0;
        int item2_counter = 0;
        {
            SingleLinkedList<DeletionSpy> list;
            list.PushFront(DeletionSpy{item0_counter});
            list.PushFront(DeletionSpy{item1_counter});
            list.PushFront(DeletionSpy{item2_counter});

            assert(item0_counter == 1);
            assert(item1_counter == 1);
            assert(item2_counter == 1);
            list.Clear();
            assert(item0_counter == 0);
            assert(item1_counter == 0);
            assert(item2_counter == 0);

            list.PushFront(DeletionSpy{item0_counter});
            list.PushFront(DeletionSpy{item1_counter});
            list.PushFront(DeletionSpy{item2_counter});
            assert(item0_counter == 1);
            assert(item1_counter == 1);
            assert(item2_counter == 1);
        }
        assert(item0_counter == 0);
        assert(item1_counter == 0);
        assert(item2_counter == 0);
    }

    // Вспомогательный класс, бросающий исключение после создания N-копии
    struct ThrowOnCopy {
        ThrowOnCopy() = default;
        explicit ThrowOnCopy(int& copy_counter) noexcept
            : countdown_ptr(&copy_counter) {
        }
        ThrowOnCopy(const ThrowOnCopy& other)
            : countdown_ptr(other.countdown_ptr)  //
        {
            if (countdown_ptr) {
                if (*countdown_ptr == 0) {
                    throw std::bad_alloc();
                } else {
                    --(*countdown_ptr);
                }
            }
        }
        // Присваивание элементов этого типа не требуется
        ThrowOnCopy& operator=(const ThrowOnCopy& rhs) = delete;
        // Адрес счётчика обратного отсчёта. Если не равен nullptr, то уменьшается при каждом копировании.
        // Как только обнулится, конструктор копирования выбросит исключение
        int* countdown_ptr = nullptr;
    };

    {
        bool exception_was_thrown = false;
        // Последовательно уменьшаем счётчик копирований до нуля, пока не будет выброшено исключение
        for (int max_copy_counter = 5; max_copy_counter >= 0; --max_copy_counter) {
            // Создаём непустой список
            SingleLinkedList<ThrowOnCopy> list;
            list.PushFront(ThrowOnCopy{});
            try {
                int copy_counter = max_copy_counter;
                list.PushFront(ThrowOnCopy(copy_counter));
                // Если метод не выбросил исключение, список должен перейти в новое состояние
                assert(list.GetSize() == 2);
            } catch (const std::bad_alloc&) {
                exception_was_thrown = true;
                // После выбрасывания исключения состояние списка должно остаться прежним
                assert(list.GetSize() == 1);
                break;
            }
        }
        assert(exception_was_thrown);
    }
}

int main() {
    Test1();
} 

```

### Что отправлять на проверку

Только код с шаблоном класса `SingleLinkedList` и нужными для его работы директивами `#include`. Если отправите функцию `main`, она будет заменена на версию из тренажёра.


###  Подсказка 

-   Если вам сложно реализовать методы `PushFront` и `Clear`, вернитесь к теории урока. Тесты и пример использования из условия помогут реализовать их корректно.
-   При разрушении списка вызовите в деструкторе метод `Clear`, чтобы освободить память, занимаемую элементами списка.
-   В методе `Clear` удаляйте узлы, начиная с первого элемента, до тех пор, пока список не опустеет. Не забудьте обнулить поле `size_` по окончании зачистки.

## Задание

Разработайте поддержку перебора элементов контейнера `SingleLinkedList`.

-   Реализуйте шаблонный класс `BasicIterator`, на основе которого будут объявлены константный и неконстантный итераторы списка.
-   В классе списка реализуйте константную и неконстантную версии методов `begin` и `end`, которые возвращают итераторы на первый элемент контейнера и позицию, следующую за последним элементом.
-   Чтобы получать константные итераторы было удобно, реализуйте методы `cbegin` и `cend`.

Сигнатура добавляемых методов:
```cpp



template <typename Type>
class SingleLinkedList {
    ...
    // Шаблон класса Базовый Итератор.
    // Определяет поведение итератора на элементы односвязного списка
    // ValueType - совпадает с Type (для Iterator) либо с const Type (для ConstIterator)
    template <typename ValueType>
    class BasicIterator {
        // Класс списка объявляется дружественным, чтобы из методов списка
        // был доступ к приватной области итератора
        friend class SingleLinkedList;

        // Конвертирующий конструктор итератора из указателя на узел списка
        explicit BasicIterator(Node* node) {
            assert(false);
            // Реализуйте конструктор самостоятельно
        }

    public:
        // Объявленные ниже типы сообщают стандартной библиотеке о свойствах этого итератора

        // Категория итератора - forward iterator
        // (итератор, который поддерживает операции инкремента и многократное разыменование)
        using iterator_category = std::forward_iterator_tag;
        // Тип элементов, по которым перемещается итератор
        using value_type = Type;
        // Тип, используемый для хранения смещения между итераторами
        using difference_type = std::ptrdiff_t;
        // Тип указателя на итерируемое значение
        using pointer = ValueType*;
        // Тип ссылки на итерируемое значение
        using reference = ValueType&;

        BasicIterator() = default;

        // Конвертирующий конструктор/конструктор копирования
        // При ValueType, совпадающем с Type, играет роль копирующего конструктора
        // При ValueType, совпадающем с const Type, играет роль конвертирующего конструктора
        BasicIterator(const BasicIterator<Type>& other) noexcept {
            assert(false);
            // Реализуйте конструктор самостоятельно
        }

        // Чтобы компилятор не выдавал предупреждение об отсутствии оператора = при наличии
        // пользовательского конструктора копирования, явно объявим оператор = и
        // попросим компилятор сгенерировать его за нас.
        BasicIterator& operator=(const BasicIterator& rhs) = default;

        // Оператор сравнения итераторов (в роли второго аргумента выступает константный итератор)
        // Два итератора равны, если они ссылаются на один и тот же элемент списка, либо на end()
        [[nodiscard]] bool operator==(const BasicIterator<const Type>& rhs) const noexcept {
            assert(false);
            // Заглушка. Реализуйте оператор самостоятельно
        }

        // Оператор проверки итераторов на неравенство
        // Противоположен !=
        [[nodiscard]] bool operator!=(const BasicIterator<const Type>& rhs) const noexcept {
            assert(false);
            // Заглушка. Реализуйте оператор самостоятельно
        }

        // Оператор сравнения итераторов (в роли второго аргумента итератор)
        // Два итератора равны, если они ссылаются на один и тот же элемент списка, либо на end()
        [[nodiscard]] bool operator==(const BasicIterator<Type>& rhs) const noexcept {
            assert(false);
            // Заглушка. Реализуйте оператор самостоятельно
        }

        // Оператор проверки итераторов на неравенство
        // Противоположен !=
        [[nodiscard]] bool operator!=(const BasicIterator<Type>& rhs) const noexcept {
            assert(false);
            // Заглушка. Реализуйте оператор самостоятельно
        }

        // Оператор прединкремента. После его вызова итератор указывает на следующий элемент списка
        // Возвращает ссылку на самого себя
        // Инкремент итератора, не указывающего на существующий элемент списка, приводит к неопределённому поведению
        BasicIterator& operator++() noexcept {
            assert(false);
            // Заглушка. Реализуйте оператор самостоятельно
        }

        // Оператор постинкремента. После его вызова итератор указывает на следующий элемент списка.
        // Возвращает прежнее значение итератора
        // Инкремент итератора, не указывающего на существующий элемент списка,
        // приводит к неопределённому поведению
        BasicIterator operator++(int) noexcept {
            assert(false);
            // Заглушка. Реализуйте оператор самостоятельно
        }

        // Операция разыменования. Возвращает ссылку на текущий элемент
        // Вызов этого оператора у итератора, не указывающего на существующий элемент списка,
        // приводит к неопределённому поведению
        [[nodiscard]] reference operator*() const noexcept {
            assert(false);
            // Не реализовано
            // Заглушка. Реализуйте оператор самостоятельно
        }

        // Операция доступа к члену класса. Возвращает указатель на текущий элемент списка.
        // Вызов этого оператора у итератора, не указывающего на существующий элемент списка,
        // приводит к неопределённому поведению
        [[nodiscard]] pointer operator->() const noexcept {
            assert(false);
            // Заглушка. Реализуйте оператор самостоятельно
        }

    private:
        Node* node_ = nullptr;
    };

public:
    using value_type = Type;
    using reference = value_type&;
    using const_reference = const value_type&;

    // Итератор, допускающий изменение элементов списка
    using Iterator = BasicIterator<Type>;
    // Константный итератор, предоставляющий доступ для чтения к элементам списка
    using ConstIterator = BasicIterator<const Type>;

    // Возвращает итератор, ссылающийся на первый элемент
    // Если список пустой, возвращённый итератор будет равен end()
    [[nodiscard]] Iterator begin() noexcept {
        assert(false);
        // Реализуйте самостоятельно
        return {};
    }

    // Возвращает итератор, указывающий на позицию, следующую за последним элементом односвязного списка
    // Разыменовывать этот итератор нельзя - попытка разыменования приведёт к неопределённому поведению
    [[nodiscard]] Iterator end() noexcept {
        assert(false);
        // Реализуйте самостоятельно
        return {};
    }

    // Возвращает константный итератор, ссылающийся на первый элемент
    // Если список пустой, возвращённый итератор будет равен end()
    // Результат вызова эквивалентен вызову метода cbegin()
    [[nodiscard]] ConstIterator begin() const noexcept {
        assert(false);
        // Реализуйте самостоятельно
        return {};
    }

    // Возвращает константный итератор, указывающий на позицию, следующую за последним элементом односвязного списка
    // Разыменовывать этот итератор нельзя - попытка разыменования приведёт к неопределённому поведению
    // Результат вызова эквивалентен вызову метода cend()
    [[nodiscard]] ConstIterator end() const noexcept {
        assert(false);
        // Реализуйте самостоятельно
        return {};
    }

    // Возвращает константный итератор, ссылающийся на первый элемент
    // Если список пустой, возвращённый итератор будет равен cend()
    [[nodiscard]] ConstIterator cbegin() const noexcept {
        assert(false);
        // Реализуйте самостоятельно
        return {};
    }

    // Возвращает константный итератор, указывающий на позицию, следующую за последним элементом односвязного списка
    // Разыменовывать этот итератор нельзя - попытка разыменования приведёт к неопределённому поведению
    [[nodiscard]] ConstIterator cend() const noexcept {
        assert(false);
        // Реализуйте самостоятельно
        return {};
    }

    ...
}; 

### Пример использования и тесты



#include <cassert>
#include <cstddef>
#include <iterator>
#include <string>
#include <utility>

template <typename Type>
class SingleLinkedList {...};

// Эта функция тестирует работу SingleLinkedList
void Test2() {
    // Итерирование по пустому списку
    {
        SingleLinkedList<int> list;
        // Константная ссылка для доступа к константным версиям begin()/end()
        const auto& const_list = list;

        // Итераторы begine и end у пустого диапазона равны друг другу
        assert(list.begin() == list.end());
        assert(const_list.begin() == const_list.end());
        assert(list.cbegin() == list.cend());
        assert(list.cbegin() == const_list.begin());
        assert(list.cend() == const_list.end());
    }

    // Итерирование по непустому списку
    {
        SingleLinkedList<int> list;
        const auto& const_list = list;

        list.PushFront(1);
        assert(list.GetSize() == 1u);
        assert(!list.IsEmpty());

        assert(const_list.begin() != const_list.end());
        assert(const_list.cbegin() != const_list.cend());
        assert(list.begin() != list.end());

        assert(const_list.begin() == const_list.cbegin());

        assert(*list.cbegin() == 1);
        *list.begin() = -1;
        assert(*list.cbegin() == -1);

        const auto old_begin = list.cbegin();
        list.PushFront(2);
        assert(list.GetSize() == 2);

        const auto new_begin = list.cbegin();
        assert(new_begin != old_begin);
        // Проверка прединкремента
        {
            auto new_begin_copy(new_begin);
            assert((++(new_begin_copy)) == old_begin);
        }
        // Проверка постинкремента
        {
            auto new_begin_copy(new_begin);
            assert(((new_begin_copy)++) == new_begin);
            assert(new_begin_copy == old_begin);
        }
        // Итератор, указывающий на позицию после последнего элемента равен итератору end()
        {
            auto old_begin_copy(old_begin);
            assert((++old_begin_copy) == list.end());
        }
    }
    // Преобразование итераторов
    {
        SingleLinkedList<int> list;
        list.PushFront(1);
        // Конструирование ConstItrator из Iterator
        SingleLinkedList<int>::ConstIterator const_it(list.begin());
        assert(const_it == list.cbegin());
        assert(*const_it == *list.cbegin());

        SingleLinkedList<int>::ConstIterator const_it1;
        // Присваивание ConstIterator-у значения Iterator
        const_it1 = list.begin();
        assert(const_it1 == const_it);
    }
    // Проверка оператора ->
    {
        using namespace std;
        SingleLinkedList<std::string> string_list;

        string_list.PushFront("one"s);
        assert(string_list.cbegin()->length() == 3u);
        string_list.begin()->push_back('!');
        assert(*string_list.begin() == "one!"s);
    }
}

int main() {
    Test2();
} 
```


### Ограничения

Инкремент и разыменование итератора, ссылающегося на позицию за последним элементом списка, — недопустимые операции. Очистка или разрушение списка делают невалидными его итераторы. Любые операции над невалидным итератором, кроме естественного вызова деструктора, тоже недопустимы. Гарантируется, что тренажёр не будет совершать таких операций. Не усложняйте класс списка и итератора, чтобы выявить ситуации некорректного использования итераторов.

### Требование

Сохраните сигнатуры всех публичных методов класса `SingleLinkedList` и его итераторов неизменными, чтобы код скомпилировался без ошибок.

### Что отправлять на проверку

В решении должен быть класс `SingleLinkedList` и нужные для его работы директивы `#include`. Функция `main` учитываться не будет.


### Подсказка 

Не переживайте, что `end`-итератор, который указывает на позицию, следующую за последним элементом, будет ссылаться на `nullptr`. Это корректная операция, ведь разыменование и инкремент итератора не разрешены.

# 6_4

## Задание

Реализуйте в классе односвязного списка следующий функционал:

-   Операции сравнения `==`, `!=`, `<`, `>`, `<=`, `>=`;
-   Обмен содержимого двух списков с использованием метода `swap` и шаблонной функции `swap`;
-   Конструирование односвязного списка на основе `initializer_list`. Последовательность элементов созданного списка и `initializer_list` должна быть одинаковой;
-   Надёжные конструктор копирования и операцию присваивания. Операция присваивания должна обеспечивать строгую гарантию безопасности исключений. Если в процессе присваивания будет выброшено исключение, содержимое левого аргумента операции присваивания должно остаться без изменений.

Сигнатура добавляемых операций:


```cpp
template <typename Type>
class SingleLinkedList {
public:
    SingleLinkedList(std::initializer_list<Type> values) {
        // Реализуйте конструктор самостоятельно
    }

    SingleLinkedList(const SingleLinkedList& other) {
        // Реализуйте конструктор самостоятельно
    }

    SingleLinkedList& operator=(const SingleLinkedList& rhs) {
        // Реализуйте присваивание самостоятельно
        return *this;
    }

    // Обменивает содержимое списков за время O(1)
    void swap(SingleLinkedList& other) noexcept {
        // Реализуйте обмен содержимого списков самостоятельно
    }

private:
    // Фиктивный узел, используется для вставки "перед первым элементом"
    Node head_;
    size_t size_ = 0;
};

template <typename Type>
void swap(SingleLinkedList<Type>& lhs, SingleLinkedList<Type>& rhs) noexcept {
    // Реализуйте обмен самостоятельно
}

template <typename Type>
bool operator==(const SingleLinkedList<Type>& lhs, const SingleLinkedList<Type>& rhs) {
    // Заглушка. Реализуйте сравнение самостоятельно
    return true;
}

template <typename Type>
bool operator!=(const SingleLinkedList<Type>& lhs, const SingleLinkedList<Type>& rhs) {
    // Заглушка. Реализуйте сравнение самостоятельно
    return true;
}

template <typename Type>
bool operator<(const SingleLinkedList<Type>& lhs, const SingleLinkedList<Type>& rhs) {
    // Заглушка. Реализуйте сравнение самостоятельно
    return true;
}

template <typename Type>
bool operator<=(const SingleLinkedList<Type>& lhs, const SingleLinkedList<Type>& rhs) {
    // Заглушка. Реализуйте сравнение самостоятельно
    return true;
}

template <typename Type>
bool operator>(const SingleLinkedList<Type>& lhs, const SingleLinkedList<Type>& rhs) {
    // Заглушка. Реализуйте сравнение самостоятельно
    return true;
}

template <typename Type>
bool operator>=(const SingleLinkedList<Type>& lhs, const SingleLinkedList<Type>& rhs) {
    // Заглушка. Реализуйте сравнение самостоятельно
    return true;
} 

```
### Пример использования и тесты

```cpp

#include <cassert>
#include <cstddef>
#include <iterator>
#include <string>
#include <utility>

template <typename Type>
class SingleLinkedList {...};

// Эта функция проверяет работу класса SingleLinkedList
void Test3() {
    // Проверка списков на равенство и неравенство
    {
        SingleLinkedList<int> list_1;
        list_1.PushFront(1);
        list_1.PushFront(2);

        SingleLinkedList<int> list_2;
        list_2.PushFront(1);
        list_2.PushFront(2);
        list_2.PushFront(3);

        SingleLinkedList<int> list_1_copy;
        list_1_copy.PushFront(1);
        list_1_copy.PushFront(2);

        SingleLinkedList<int> empty_list;
        SingleLinkedList<int> another_empty_list;

        // Список равен самому себе
        assert(list_1 == list_1);
        assert(empty_list == empty_list);

        // Списки с одинаковым содержимым равны, а с разным - не равны
        assert(list_1 == list_1_copy);
        assert(list_1 != list_2);
        assert(list_2 != list_1);
        assert(empty_list == another_empty_list);
    }

    // Обмен содержимого списков
    {
        SingleLinkedList<int> first;
        first.PushFront(1);
        first.PushFront(2);

        SingleLinkedList<int> second;
        second.PushFront(10);
        second.PushFront(11);
        second.PushFront(15);

        const auto old_first_begin = first.begin();
        const auto old_second_begin = second.begin();
        const auto old_first_size = first.GetSize();
        const auto old_second_size = second.GetSize();

        first.swap(second);

        assert(second.begin() == old_first_begin);
        assert(first.begin() == old_second_begin);
        assert(second.GetSize() == old_first_size);
        assert(first.GetSize() == old_second_size);

        // Обмен при помощи функции swap
        {
            using std::swap;

            // В отсутствие пользовательской перегрузки будет вызвана функция std::swap, которая
            // выполнит обмен через создание временной копии
            swap(first, second);

            // Убеждаемся, что используется не std::swap, а пользовательская перегрузка

            // Если бы обмен был выполнен с созданием временной копии,
            // то итератор first.begin() не будет равен ранее сохранённому значению,
            // так как копия будет хранить свои узлы по иным адресам
            assert(first.begin() == old_first_begin);
            assert(second.begin() == old_second_begin);
            assert(first.GetSize() == old_first_size);
            assert(second.GetSize() == old_second_size);
        }
    }

    // Инициализация списка при помощи std::initializer_list
    {
        SingleLinkedList<int> list{1, 2, 3, 4, 5};
        assert(list.GetSize() == 5);
        assert(!list.IsEmpty());
        assert(std::equal(list.begin(), list.end(), std::begin({1, 2, 3, 4, 5})));
    }

    // Лексикографическое сравнение списков
    {
        using IntList = SingleLinkedList<int>;

        assert((IntList{1, 2, 3} < IntList{1, 2, 3, 1}));
        assert((IntList{1, 2, 3} <= IntList{1, 2, 3}));
        assert((IntList{1, 2, 4} > IntList{1, 2, 3}));
        assert((IntList{1, 2, 3} >= IntList{1, 2, 3}));
    }

    // Копирование списков
    {
        const SingleLinkedList<int> empty_list{};
        // Копирование пустого списка
        {
            auto list_copy(empty_list);
            assert(list_copy.IsEmpty());
        }

        SingleLinkedList<int> non_empty_list{1, 2, 3, 4};
        // Копирование непустого списка
        {
            auto list_copy(non_empty_list);

            assert(non_empty_list.begin() != list_copy.begin());
            assert(list_copy == non_empty_list);
        }
    }

    // Присваивание списков
    {
        const SingleLinkedList<int> source_list{1, 2, 3, 4};

        SingleLinkedList<int> receiver{5, 4, 3, 2, 1};
        receiver = source_list;
        assert(receiver.begin() != source_list.begin());
        assert(receiver == source_list);
    }

    // Вспомогательный класс, бросающий исключение после создания N-копии
    struct ThrowOnCopy {
        ThrowOnCopy() = default;
        explicit ThrowOnCopy(int& copy_counter) noexcept
            : countdown_ptr(&copy_counter) {
        }
        ThrowOnCopy(const ThrowOnCopy& other)
            : countdown_ptr(other.countdown_ptr)  //
        {
            if (countdown_ptr) {
                if (*countdown_ptr == 0) {
                    throw std::bad_alloc();
                } else {
                    --(*countdown_ptr);
                }
            }
        }
        // Присваивание элементов этого типа не требуется
        ThrowOnCopy& operator=(const ThrowOnCopy& rhs) = delete;
        // Адрес счётчика обратного отсчёта. Если не равен nullptr, то уменьшается при каждом копировании.
        // Как только обнулится, конструктор копирования выбросит исключение
        int* countdown_ptr = nullptr;
    };

    // Безопасное присваивание списков
    {
        SingleLinkedList<ThrowOnCopy> src_list;
        src_list.PushFront(ThrowOnCopy{});
        src_list.PushFront(ThrowOnCopy{});
        auto thrower = src_list.begin();
        src_list.PushFront(ThrowOnCopy{});

        int copy_counter = 0;  // при первом же копировании будет выброшего исключение
        thrower->countdown_ptr = &copy_counter;

        SingleLinkedList<ThrowOnCopy> dst_list;
        dst_list.PushFront(ThrowOnCopy{});
        int dst_counter = 10;
        dst_list.begin()->countdown_ptr = &dst_counter;
        dst_list.PushFront(ThrowOnCopy{});

        try {
            dst_list = src_list;
            // Ожидается исключение при присваивании
            assert(false);
        } catch (const std::bad_alloc&) {
            // Проверяем, что состояние списка-приёмника не изменилось
            // при выбрасывании исключений
            assert(dst_list.GetSize() == 2);
            auto it = dst_list.begin();
            assert(it != dst_list.end());
            assert(it->countdown_ptr == nullptr);
            ++it;
            assert(it != dst_list.end());
            assert(it->countdown_ptr == &dst_counter);
            assert(dst_counter == 10);
        } catch (...) {
            // Других типов исключений не ожидается
            assert(false);
        }
    }
}

int main() {
    Test3();
} 

```

### Ограничения

Инкремент и разыменование итератора, ссылающегося на позицию за последним элементом списка, — недопустимые операции. Очистка или разрушение списка делают невалидными его итераторы. Любые операции над невалидным итератором, кроме естественного вызова деструктора, тоже недопустимы. Гарантируется, что тренажёр не будет совершать таких операций. Не усложняйте класс списка и итератора, чтобы выявить ситуации некорректного использования итераторов.

### Что отправлять на проверку

В решении должен быть шаблонный класс `SingleLinkedList` с перегруженными операциями, функцией `swap` и нужными для их работы директивами `#include`. Функция `main` игнорируется.

### Подсказка

У конструктора копирования и конструктора из `std::initializer_list` есть нечто общее — и тот, и другой принимают на вход объект, у которого есть итераторы `begin` и `end`. Эти итераторы задают диапазон элементов, которые надо скопировать. Если вынести инициализацию списка элементами из переданного диапазона итераторов в отдельный шаблонный метод, избавитесь от дублирования кода.


## Задание

Это задание — итоговый проект шестого спринта. Вы будете сдавать его на проверку через репозиторий на GitHub. А пока сохраните решение в своей IDE.

Реализуйте в классе односвязного списка следующие операции:

-   Метод `PopFront`. Удаляет первый элемента непустого списка за время O(1). Не выбрасывает исключений.
-   Метод `InsertAfter`. За время O(1) вставляет в список новое значение следом за элементом, на который ссылается переданный в `InsertAfter` итератор. Метод должен обеспечивать строгую гарантию безопасности исключений.
-   Метод `EraseAfter`. За время O(1) удаляет из списка элемент, следующий за элементом, на который ссылается переданный в `InsertAfter` итератор. Не выбрасывает исключений.
-   Методы `before_begin` и `cbefore_begin`. Возвращают итераторы, ссылающиеся на фиктивную позицию перед первым элементом списка. Такой итератор используется как параметр для методов `InsertAfter` и `EraseAfter`, когда нужно вставить или удалить элемент в начале списка. Разыменовывать этот итератор нельзя.

Сигнатуры новых методов:


```cpp

template <typename Type>
class SingleLinkedList {
public:
    // Возвращает итератор, указывающий на позицию перед первым элементом односвязного списка.
    // Разыменовывать этот итератор нельзя - попытка разыменования приведёт к неопределённому поведению
    [[nodiscard]] Iterator before_begin() noexcept {
        // Реализуйте самостоятельно
        return {};
    }

    // Возвращает константный итератор, указывающий на позицию перед первым элементом односвязного списка.
    // Разыменовывать этот итератор нельзя - попытка разыменования приведёт к неопределённому поведению
    [[nodiscard]] ConstIterator cbefore_begin() const noexcept {
        // Реализуйте самостоятельно
        return {};
    }

    // Возвращает константный итератор, указывающий на позицию перед первым элементом односвязного списка.
    // Разыменовывать этот итератор нельзя - попытка разыменования приведёт к неопределённому поведению
    [[nodiscard]] ConstIterator before_begin() const noexcept {
        // Реализуйте самостоятельно
        return {};
    }

    /*
     * Вставляет элемент value после элемента, на который указывает pos.
     * Возвращает итератор на вставленный элемент
     * Если при создании элемента будет выброшено исключение, список останется в прежнем состоянии
     */
    Iterator InsertAfter(ConstIterator pos, const Type& value) {
        // Заглушка. Реализуйте метод самостоятельно
        return {};
    }

    void PopFront() noexcept {
        // Реализуйте метод самостоятельно
    }

    /*
     * Удаляет элемент, следующий за pos.
     * Возвращает итератор на элемент, следующий за удалённым
     */
    Iterator EraseAfter(ConstIterator pos) noexcept {
        // Заглушка. Реализуйте метод самостоятельно
        return {};
    }
    ...
}; 

```

Пример использования и тесты:

```cpp
#include <cassert>
#include <cstddef>
#include <iterator>
#include <string>
#include <utility>

template <typename Type>
class SingleLinkedList {...};

// Эта функция проверяет работу класса SingleLinkedList
void Test4() {
    struct DeletionSpy {
        ~DeletionSpy() {
            if (deletion_counter_ptr) {
                ++(*deletion_counter_ptr);
            }
        }
        int* deletion_counter_ptr = nullptr;
    };

    // Проверка PopFront
    {
        SingleLinkedList<int> numbers{3, 14, 15, 92, 6};
        numbers.PopFront();
        assert((numbers == SingleLinkedList<int>{14, 15, 92, 6}));

        SingleLinkedList<DeletionSpy> list;
        list.PushFront(DeletionSpy{});
        int deletion_counter = 0;
        list.begin()->deletion_counter_ptr = &deletion_counter;
        assert(deletion_counter == 0);
        list.PopFront();
        assert(deletion_counter == 1);
    }

    // Доступ к позиции, предшествующей begin
    {
        SingleLinkedList<int> empty_list;
        const auto& const_empty_list = empty_list;
        assert(empty_list.before_begin() == empty_list.cbefore_begin());
        assert(++empty_list.before_begin() == empty_list.begin());
        assert(++empty_list.cbefore_begin() == const_empty_list.begin());

        SingleLinkedList<int> numbers{1, 2, 3, 4};
        const auto& const_numbers = numbers;
        assert(numbers.before_begin() == numbers.cbefore_begin());
        assert(++numbers.before_begin() == numbers.begin());
        assert(++numbers.cbefore_begin() == const_numbers.begin());
    }

    // Вставка элемента после указанной позиции
    {  // Вставка в пустой список
        {
            SingleLinkedList<int> lst;
            const auto inserted_item_pos = lst.InsertAfter(lst.before_begin(), 123);
            assert((lst == SingleLinkedList<int>{123}));
            assert(inserted_item_pos == lst.begin());
            assert(*inserted_item_pos == 123);
        }

        // Вставка в непустой список
        {
            SingleLinkedList<int> lst{1, 2, 3};
            auto inserted_item_pos = lst.InsertAfter(lst.before_begin(), 123);

            assert(inserted_item_pos == lst.begin());
            assert(inserted_item_pos != lst.end());
            assert(*inserted_item_pos == 123);
            assert((lst == SingleLinkedList<int>{123, 1, 2, 3}));

            inserted_item_pos = lst.InsertAfter(lst.begin(), 555);
            assert(++SingleLinkedList<int>::Iterator(lst.begin()) == inserted_item_pos);
            assert(*inserted_item_pos == 555);
            assert((lst == SingleLinkedList<int>{123, 555, 1, 2, 3}));
        };
    }

    // Вспомогательный класс, бросающий исключение после создания N-копии
    struct ThrowOnCopy {
        ThrowOnCopy() = default;
        explicit ThrowOnCopy(int& copy_counter) noexcept
            : countdown_ptr(&copy_counter) {
        }
        ThrowOnCopy(const ThrowOnCopy& other)
            : countdown_ptr(other.countdown_ptr)  //
        {
            if (countdown_ptr) {
                if (*countdown_ptr == 0) {
                    throw std::bad_alloc();
                } else {
                    --(*countdown_ptr);
                }
            }
        }
        // Присваивание элементов этого типа не требуется
        ThrowOnCopy& operator=(const ThrowOnCopy& rhs) = delete;
        // Адрес счётчика обратного отсчёта. Если не равен nullptr, то уменьшается при каждом копировании.
        // Как только обнулится, конструктор копирования выбросит исключение
        int* countdown_ptr = nullptr;
    };

    // Проверка обеспечения строгой гарантии безопасности исключений
    {
        bool exception_was_thrown = false;
        for (int max_copy_counter = 10; max_copy_counter >= 0; --max_copy_counter) {
            SingleLinkedList<ThrowOnCopy> list{ThrowOnCopy{}, ThrowOnCopy{}, ThrowOnCopy{}};
            try {
                int copy_counter = max_copy_counter;
                list.InsertAfter(list.cbegin(), ThrowOnCopy(copy_counter));
                assert(list.GetSize() == 4u);
            } catch (const std::bad_alloc&) {
                exception_was_thrown = true;
                assert(list.GetSize() == 3u);
                break;
            }
        }
        assert(exception_was_thrown);
    }

    // Удаление элементов после указанной позиции
    {
        {
            SingleLinkedList<int> lst{1, 2, 3, 4};
            const auto& const_lst = lst;
            const auto item_after_erased = lst.EraseAfter(const_lst.cbefore_begin());
            assert((lst == SingleLinkedList<int>{2, 3, 4}));
            assert(item_after_erased == lst.begin());
        }
        {
            SingleLinkedList<int> lst{1, 2, 3, 4};
            const auto item_after_erased = lst.EraseAfter(lst.cbegin());
            assert((lst == SingleLinkedList<int>{1, 3, 4}));
            assert(item_after_erased == (++lst.begin()));
        }
        {
            SingleLinkedList<int> lst{1, 2, 3, 4};
            const auto item_after_erased = lst.EraseAfter(++(++lst.cbegin()));
            assert((lst == SingleLinkedList<int>{1, 2, 3}));
            assert(item_after_erased == lst.end());
        }
        {
            SingleLinkedList<DeletionSpy> list{DeletionSpy{}, DeletionSpy{}, DeletionSpy{}};
            auto after_begin = ++list.begin();
            int deletion_counter = 0;
            after_begin->deletion_counter_ptr = &deletion_counter;
            assert(deletion_counter == 0u);
            list.EraseAfter(list.cbegin());
            assert(deletion_counter == 1u);
        }
    }
}

int main() {
    Test4();
} 

```

### Прекод

В качестве заготовки кода используйте своё решение из предыдущего урока.

### Ограничения

Не меняйте сигнатуры всех публичных методов класса `SingleLinkedList`, его итераторов и операций, чтобы код скомпилировался без ошибок.

Считайте, что тип `Type` удовлетворяет следующим ограничениям:

-   Имеет конструктор без параметров.
-   Имеет копирующий конструктор.
-   Деструктор не выбрасывает исключений.

### Что отправлять на проверку

В решении должна быть реализация класса `SingleLinkedList` с перегруженными операциями, функцией `swap` и нужными для их работы директивами `#include`. Функция `main` учитываться при проверке не будет.

### Как будет тестироваться ваш код

При тестировании не будут происходить следующие операции:

-   Удаление элемента в начале пустого списка.
-   Передача в методы `InsertAfter` и `EraseAfter` end-итератора текущего списка, невалидного итератора либо итератора, ссылающегося на элемент другого списка.

Не усложняйте класс списка и итератора, чтобы выявить ситуации некорректного использования итераторов.

# 6_10
## Задание

Разработайте шаблонный класс `ArrayPtr`, играющий роль умного указателя на массив в динамической памяти. У него должен быть такой функционал:

-   удаление массива при разрушении умного указателя;
-   конструкторы: по умолчанию, из указателя на существующий массив, создающий новый массив заданного размера;
-   доступ к элементу массива по индексу;
-   запрет операций копирования и присваивания;
-   метод `swap` для обмена содержимым с другим объектом `ArrayPtr`;
-   метод `Release`, прекращающий владение массивом и возвращающий значение сырого указателя.

### Ограничения

Сохраните сигнатуры всех публичных методов класса `ArrayPtr` неизменными, чтобы код скомпилировался без ошибок.

### Что отправлять на проверку

В решении должен быть класс `ArrayPtr` с нужными для его компиляции директивами `#include`. Функция `main` учитываться при проверке не будет.

# 9_6

## Задание

Рассмотрим упрощённый текстовый редактор, который поддерживает следующий набор команд:

-   Перемещение курсора влево (**Left**) и вправо (**Right**) на одну позицию;
-   Ввод символа в текущую позицию курсора (**Insert**);
-   Копирование фрагмента текста, начинающегося в текущей позиции курсора, в буфер обмена (**Copy**);
-   Вырезание фрагмента текста — аналогично копированию с последующим удалением скопированных символов из текста (**Cut**);
-   Вставка содержимого буфера обмена в текущую позицию курсора (**Paste**).

Эти команды поддерживаются почти любым текстовым редактором. Для команд действуют стандартные правила, определяющие их эффект:

-   Если редактор содержит текст длиной `n` символов, курсор может находиться в одной из `(n + 1)` возможных позиций. Обозначим курсор вертикальной чертой `|` и будем использовать это обозначение дальше. В тексте `abc` курсор может быть в позициях: `|abc`, `a|bc`, `ab|c`, `abc|`. Поэтому команда **Left** не имеет эффекта, когда курсор расположен в начале текста, а **Right** не имеет эффекта, когда курсор находится в конце. Ни **Left**, ни **Right** не имеют эффекта, когда редактор не содержит текста.
-   Введённый символ располагается в позиции курсора, сдвигая курсор и весь текст справа от него на одну позицию вправо. Аналогично при вставке фрагмента длиной `n` курсор и текст справа от него смещаются на `n` позиций вправо. В таблице приведены примеры, демонстрирующие это правило.

![[Pasted image 20220209132736.png]]

-   Буфер обмена изначально пуст. Вставка пустого фрагмента не имеет эффекта. Содержимое буфера не сбрасывается после вставки, а остаётся неизменным до следующей команды **Copy** или **Cut**. Копирование или вырезание фрагмента нулевой длины не оказывает влияния на текст, но опустошает буфер обмена. Курсор не смещается ни при копировании, ни при вырезании текста. Например, после вырезания из текста `ab|cdef` фрагмента из трёх символов получим текст `ab|f`.

Вам предстоит реализовать «ядро» текстового редактора, который поддерживает все описанные операции, в виде класса `Editor` с таким интерфейсом:


```cpp

class Editor {
public:
    Editor();
    // сдвинуть курсор влево
    void Left();
    // сдвинуть курсор вправо 
    void Right();
    // вставить символ token
    void Insert(char token);
    // вырезать не более tokens символов, начиная с текущей позиции курсора
    void Cut(size_t tokens = 1);
    // cкопировать не более tokens символов, начиная с текущей позиции курсора
    void Copy(size_t tokens = 1);
    // вставить содержимое буфера в текущую позицию курсора
    void Paste();
    // получить текущее содержимое текстового редактора
    string GetText() const;
}; 

```

Каждой описанной команде сопоставлен метод класса `Editor`. Также введён метод `GetText()`, позволяющий получить текущее содержимое редактора в виде строки. В комментариях к методам `Cut(size_t tokens)` и `Copy(size_t tokens)` указано, что в буфер обмена попадает фрагмент длиной не более `tokens` символов. Это значит, что если справа от курсора располагается менее чем `tokens` символов, методы `Cut()` и `Copy()` должны вырезать или скопировать все символы справа.

### Ограничения

Реализация класса `Editor` должна обрабатывать 10^6 запросов не более чем за одну секунду. При этом гарантируется, что:

-   Длина текста никогда не превышает 10^6 символов;
-   Методы `Copy()` и `Cut()` суммарно копируют/вырезают не более 10^6 символов;
-   Метод `GetText()` вызывается один раз в каждом из тестов.

### Пример использования


```cpp

int main() {
    Editor editor;
    const string text = "hello, world"s;
    for (char c : text) {
        editor.Insert(c);
    }
    // Текущее состояние редактора: hello, world|
    for (size_t i = 0; i < text.size(); ++i) {
        editor.Left();
    }
    // Текущее состояние редактора: |hello, world
    editor.Cut(7);
    // Текущее состояние редактора: |world
    // в буфере обмена находится текст hello, 
    for (size_t i = 0; i < 5; ++i) {
        editor.Right();
    }
    // Текущее состояние редактора: world|
    editor.Insert(',');
    editor.Insert(' ');
    // Текущее состояние редактора: world, |
    editor.Paste();
    // Текущее состояние редактора: world, hello, |
    editor.Left();
    editor.Left();
    //Текущее состояние редактора: world, hello|, 
    editor.Cut(3);  // Будут вырезаны 2 символа
    // Текущее состояние редактора: world, hello|
    cout << editor.GetText();
    return 0;
} 
```


### Пример вывода

Скопировать код

`world, hello`

### Подсказка

Вам понадобятся два списка: один для хранения текста, а другой — для буфера вставки. Итератор — удобное решение для хранения текущей позиции курсора.

# 9_7

## Задание

Создайте вектор, который не использует память из кучи, а хранит все свои объекты в стеке.

Вы знакомы с контейнером `array`, который поможет решить эту задачу. Реализуйте интерфейс вектора поверх него: разработайте шаблон класса `template <typename T, size_t N> StackVector<T, N>`, где `T` — тип элемента вектора, а `N` — его максимальная вместимость. Класс `StackVector` должен иметь следующий интерфейс:


```cpp

template <typename T, size_t N>
class StackVector {
public:
    explicit StackVector(size_t a_size = 0);

    T& operator[](size_t index);
    const T& operator[](size_t index) const;

    ??? begin();
    ??? end();
    ??? begin() const;
    ??? end() const;

    size_t Size() const;
    size_t Capacity() const;

    void PushBack(const T& value);
    T PopBack();
}; 

```

-   Метод `Capacity` должен возвращать вместимость вектора — то есть количество объектов, которое в него может поместиться.
-   Метод `Size` должен возвращать текущее количество объектов в векторе.
-   Конструктор принимает размер вектора — по аналогии со стандартным вектором. Если аргумент конструктора больше вместимости вектора, конструктор должен выбрасывать исключение [`invalid_argument`](https://en.cppreference.com/w/cpp/error/invalid_argument).
-   Методы `begin/end` должны возвращать итераторы на начало и текущий конец вектора. Их тип не указан, выберите его самостоятельно.
-   Метод `PushBack` добавляет новый элемент в конец вектора. Если текущий размер вектора равен его вместимости, метод `PushBack` должен выбрасывать стандартное исключение [`overflow_error`](https://en.cppreference.com/w/cpp/error/overflow_error).
-   Метод `PopBack` уменьшает размер вектора на один и возвращает элемент вектора, который был последним. Если вектор пуст, метод `PopBack` должен выбрасывать стандартное исключение [`underflow_error`](https://en.cppreference.com/w/cpp/error/underflow_error).

Интерфейс класса `StackVector` описан в файле stack_vector.h. Часть требований к нему сформулирована в виде юнит-тестов в файле main.cpp.

Файл main.cpp содержит бенчмарк, который демонстрирует преимущество `StackVector` перед обычным вектором. Этот бенчмарк моделирует ситуацию, когда мы считываем из потока количество объектов `N`, а затем добавляем в вектор `N` объектов. Для этого используем метод `push_back`. Тестовые данные разложены в `vector<vector<int>>`, чтобы исключить из бенчмарка время, нужное на парсинг. Когда реализуете шаблон `StackVector`, сравните его производительность с вектором.

# 9_9

## Задание 1

В прошлом уроке для парсинга строки вы использовали переменную `pos`, которая указывала на позицию начала слова. Избавьтесь от этой переменной и начните перемещать начало самого `string_view`.

Алгоритм будет выглядеть следующим образом:

-   Установите начало переменной `str` типа `string_view` на начало строки.
-   Используйте метод `find`, чтобы найти номер позиции ближайшего пробела.
-   Добавьте в результирующий вектор элемент `string_view`, полученный вызовом метода `substr`, где начальная позиция будет 0, а конечная — найденная позиция пробела.
-   Сдвиньте начало `str` так, чтобы оно указывало на позицию за пробелом. Для этого есть метод `remove_prefix`, который передвинет начало `str` на указанное в аргументе количество позиций.
-   Теперь все эти действия можно повторить в цикле, пока найденная позиция пробела не станет равна уже известной константе `npos`.

Реализуйте функцию `SplitIntoWordsView` по описанному алгоритму.

Вернитесь к описанию алгоритма или откройте документацию для метода [find](https://en.cppreference.com/w/cpp/string/basic_string_view/find) и [substr](https://en.cppreference.com/w/cpp/string/basic_string_view/substr). Пока эти страницы есть только на английском.

## Задание 2

Разработайте класс `Translator`, позволяющий сохранять двуязычные пары слов, а затем переводить слова с одного языка на другой с использованием уже добавленных пар.

Более конкретно объект `t` типа `Translator` должен допускать следующие действия:

1.  Создание с использованием конструктора по умолчанию. В этом случае база переводов пуста.
2.  Добавление двуязычной пары: `t.Add(source, target)`. После такого вызова считается, что слово `source` на языке 1 соответствует слову `target` на языке 2. Переданные в метод `Add` строки могут быть уничтожены раньше объекта `t`.
3.  Перевод с языка 1 на язык 2: `t.TranslateForward(source)`. Если ранее уже был вызов `t.Add(source_copy, target)` для некоторой строки `target` и строки `source_copy`, равной `source` или являющейся ей, нужно вернуть `target`. Если такого вызова не было — вернуть пустую строку. Если таких вызовов было несколько — вернуть `target` для последнего из них.
4.  Перевод с языка 2 на язык 1: `t.TranslateBackward(target)`. Если ранее уже был вызов `t.Add(source, target_copy)` для некоторой строки `source` и строки `target_copy`, равной `target` или являющейся ей, нужно вернуть `source`. Если такого вызова не было — вернуть пустую строку. Если таких вызовов было несколько — вернуть `source` для последнего из них.

### Ограничения

Каждая строка должна храниться в экземпляре класса `Translator` не более одного раза. При нарушении этого ограничения вы получите ошибку “Memory limit exceeded”.

### Пример использования


```cpp

void TestSimple() {
      Translator translator;
    translator.Add(string("okno"s), string("window"s));
    translator.Add(string("stol"s), string("table"s));

    assert(translator.TranslateForward("okno"s) == "window"s);
    assert(translator.TranslateBackward("table"s) == "stol"s);
    assert(translator.TranslateForward("table"s) == ""s);
}

int main() {
    TestSimple();
    return 0;
} 

```

# 9_10 
## Задание

Разработайте шаблонный класс `SimpleVector<Type>`, который будет упрощённым аналогом контейнера `vector`, со следующим функционалом:

-   Конструкторы.
    -   По умолчанию. Создаёт пустой вектор с нулевой вместимостью. Не выделяет динамическую память и не выбрасывает исключений.
    -   Параметризованный конструктор, создающий вектор заданного размера. Элементы вектора инициализированы значением по умолчанию для типа `Type`. Вектор должен иметь одинаковые размер и вместимость. Если размер нулевой, динамическая память для его элементов выделяться не должна.
    -   Конструктор из `std::initializer_list`. Элементы вектора должны содержать копию элементов `initializer_list`. Имеет размер и вместимость, совпадающую с размерами и вместимостью переданного `initializer_list`.
-   Метод `GetSize` для получения количества элементов в векторе. Не выбрасывает исключений.
-   Метод `GetCapacity` для получения вместимости вектора. Не выбрасывает исключений.
-   Метод `IsEmpty`, позволяющий сообщающий, пуст ли вектор. Не выбрасывает исключений.
-   Оператор `[]` для доступа к элементу вектора по его индексу. Имеет две версии — константную и неконстантную. Не выбрасывает исключений. Для корректной работы оператора индекс элемента массива не должен выходить за пределы массива.
-   Метод `At` для доступа к элементу вектора по его индексу, аналог метода `at` класса vector. В случае выхода индекса за пределы массива должен выбросить исключение `std::out_of_range`.
-   Метод `Clear` для очистки массива без изменения его вместимости. Не выбрасывает исключений.
-   Метод `Resize` для изменения количества элементов в массиве. Метод должен предоставлять строгую гарантию безопасности исключений.
-   Методы `begin`, `end`, `cbegin` и `cend`, возвращающие итераторы на начало и конец массива. В качестве итераторов используйте указатели.
-   При разрушении вектора должна освобождаться память, занимаемая его элементами.

### Ограничения

Гарантируется, что тренажёр при проверке решения не будет передавать в оператор `[]` индексы, выходящие за границы массива. При написании SimpleVector реализуйте самостоятельно работу с массивом в динамической памяти. Чтобы упростить управление массивом, пригодится разработанный в предыдущем спринте шаблонный класс `ArrayPtr`. Не используйте класс `std::vector`.

### Что отправлять на проверку

Файл `simple_vector.h` с исходным кодом класса SimpleVector. Если нужно включить дополнительные заголовочные файлы, например, с кодом `ArrayPtr`, отправьте их тоже. Если загрузите функцию `main`, она будет заменена на версию из тренажёра.

### Подсказка

-   В методе `Resize` отдельно обработайте три ситуации: новый размер меньше или равен текущему, новый размер не превышает его вместимости, новый размер превышает текущую вместимость вектора.
    -   Если при изменении размера массива новый размер вектора превышает его текущую вместимость, создайте новый массив с нужной вместимостью, скопируйте в него прежнее содержимое и заполните остальные элементы значением по умолчанию. Затем старый массив можно удалить и использовать копию. После этого не забудьте обновить размер и вместимость вектора.
    -   Если при увеличении размера массива новый размер вектора не превышает его вместимость, заполните добавленные элементы значением по умолчанию для типа `Type`.
    -   При уменьшении размера вектора просто уменьшите его размер.
-   Примените алгоритмы [std::copy](https://en.cppreference.com/w/cpp/algorithm/copy) и [std::fill](https://en.cppreference.com/w/cpp/algorithm/fill) для копирования элементов массива и заполнения их некоторым значением.
-   В методе `Clear` достаточно обнулить размер массива.

## Задание

Реализуйте в классе SimpleVector следующие операции:

-   Конструктор копирования. Копия вектора должна иметь вместимость, достаточную для хранения копии элементов исходного вектора.
-   Оператор присваивания. Должен обеспечивать строгую гарантию безопасности исключений.
-   Метод `PushBack`, добавляющий элемент в конец вектора. Должен обеспечивать строгую гарантию безопасности исключений.
-   Метод `PopBack`, удаляющий последний элемент вектора. Не выбрасывает исключений.
-   Метод `Insert`, вставляющий элемент в произвольное место контейнера. Обеспечивает базовую гарантию безопасности исключений.
-   Метод `Erase`, удаляющий элемент в произвольной позиции вектора. Обеспечивает базовую гарантию безопасности исключений.
-   Метод `swap`, обменивающий содержимое вектора с другим вектором. Не выбрасывает исключений, имеет время выполнения O(1).
-   Операторы `==` и `!=`. Два вектора равны, если их размеры равны и содержат равные элементы. Равенство вместимости не требуется.
-   Операторы `<`, `>`, `<=`, `>=`, выполняющие лексикографическое сравнение содержимого двух векторов.

Сигнатура новых методов:


```cpp

template <typename Type>
class SimpleVector {
public:
    ...
    SimpleVector(const SimpleVector& other) {
        // Напишите тело конструктора самостоятельно
    }

    SimpleVector& operator=(const SimpleVector& rhs) {
        // Напишите тело конструктора самостоятельно
        return *this;
    }

    // Добавляет элемент в конец вектора
    // При нехватке места увеличивает вдвое вместимость вектора
    void PushBack(const Type& item) {
        // Напишите тело самостоятельно
    }

    // Вставляет значение value в позицию pos.
    // Возвращает итератор на вставленное значение
    // Если перед вставкой значения вектор был заполнен полностью,
    // вместимость вектора должна увеличиться вдвое, а для вектора вместимостью 0 стать равной 1
    Iterator Insert(ConstIterator pos, const Type& value) {
        // Напишите тело самостоятельно
    }

    // "Удаляет" последний элемент вектора. Вектор не должен быть пустым
    void PopBack() noexcept {
        // Напишите тело самостоятельно
    }

    // Удаляет элемент вектора в указанной позиции
    Iterator Erase(ConstIterator pos) {
        // Напишите тело самостоятельно
    }

    // Обменивает значение с другим вектором
    void swap(SimpleVector& other) noexcept {
        // Напишите тело самостоятельно
    }
    ...
};

template <typename Type>
inline bool operator==(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator!=(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator<(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator<=(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator>(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator>=(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
} 
```

Тесты, которые помогут проверить решение:

`tests.h`

```cpp
#pragma once
#include <cassert>
#include <stdexcept>

inline void Test1() {
    // Инициализация конструктором по умолчанию
    {
        SimpleVector<int> v;
        assert(v.GetSize() == 0u);
        assert(v.IsEmpty());
        assert(v.GetCapacity() == 0u);
    }

    // Инициализация вектора указанного размера
    {
        SimpleVector<int> v(5);
        assert(v.GetSize() == 5u);
        assert(v.GetCapacity() == 5u);
        assert(!v.IsEmpty());
        for (size_t i = 0; i < v.GetSize(); ++i) {
            assert(v[i] == 0);
        }
    }

    // Инициализация вектора, заполненного заданным значением
    {
        SimpleVector<int> v(3, 42);
        assert(v.GetSize() == 3);
        assert(v.GetCapacity() == 3);
        for (size_t i = 0; i < v.GetSize(); ++i) {
            assert(v[i] == 42);
        }
    }

    // Инициализация вектора при помощи initializer_list
    {
        SimpleVector<int> v{1, 2, 3};
        assert(v.GetSize() == 3);
        assert(v.GetCapacity() == 3);
        assert(v[2] == 3);
    }

    // Доступ к элементам при помощи At
    {
        SimpleVector<int> v(3);
        assert(&v.At(2) == &v[2]);
        try {
            v.At(3);
            assert(false);  // Ожидается выбрасывание исключения
        } catch (const std::out_of_range&) {
        } catch (...) {
            assert(false);  // Не ожидается исключение, отличное от out_of_range
        }
    }

    // Очистка вектора
    {
        SimpleVector<int> v(10);
        const size_t old_capacity = v.GetCapacity();
        v.Clear();
        assert(v.GetSize() == 0);
        assert(v.GetCapacity() == old_capacity);
    }

    // Изменение размера
    {
        SimpleVector<int> v(3);
        v[2] = 17;
        v.Resize(7);
        assert(v.GetSize() == 7);
        assert(v.GetCapacity() >= v.GetSize());
        assert(v[2] == 17);
        assert(v[3] == 0);
    }
    {
        SimpleVector<int> v(3);
        v[0] = 42;
        v[1] = 55;
        const size_t old_capacity = v.GetCapacity();
        v.Resize(2);
        assert(v.GetSize() == 2);
        assert(v.GetCapacity() == old_capacity);
        assert(v[0] == 42);
        assert(v[1] == 55);
    }
    {
        const size_t old_size = 3;
        SimpleVector<int> v(3);
        v.Resize(old_size + 5);
        v[3] = 42;
        v.Resize(old_size);
        v.Resize(old_size + 2);
        assert(v[3] == 0);
    }

    // Итерирование по SimpleVector
    {
        // Пустой вектор
        {
            SimpleVector<int> v;
            assert(v.begin() == nullptr);
            assert(v.end() == nullptr);
        }

        // Непустой вектор
        {
            SimpleVector<int> v(10, 42);
            assert(v.begin());
            assert(*v.begin() == 42);
            assert(v.end() == v.begin() + v.GetSize());
        }
    }
}

inline void Test2() {
    // PushBack
    {
        SimpleVector<int> v(1);
        v.PushBack(42);
        assert(v.GetSize() == 2);
        assert(v.GetCapacity() >= v.GetSize());
        assert(v[0] == 0);
        assert(v[1] == 42);
    }

    // Если хватает места, PushBack не увеличивает Capacity
    {
        SimpleVector<int> v(2);
        v.Resize(1);
        const size_t old_capacity = v.GetCapacity();
        v.PushBack(123);
        assert(v.GetSize() == 2);
        assert(v.GetCapacity() == old_capacity);
    }

    // PopBack
    {
        SimpleVector<int> v{0, 1, 2, 3};
        const size_t old_capacity = v.GetCapacity();
        const auto old_begin = v.begin();
        v.PopBack();
        assert(v.GetCapacity() == old_capacity);
        assert(v.begin() == old_begin);
        assert((v == SimpleVector<int>{0, 1, 2}));
    }

    // Конструктор копирования
    {
        SimpleVector<int> numbers{1, 2};
        auto numbers_copy(numbers);
        assert(&numbers_copy[0] != &numbers[0]);
        assert(numbers_copy.GetSize() == numbers.GetSize());
        for (size_t i = 0; i < numbers.GetSize(); ++i) {
            assert(numbers_copy[i] == numbers[i]);
            assert(&numbers_copy[i] != &numbers[i]);
        }
    }

    // Сравнение
    {
        assert((SimpleVector{1, 2, 3} == SimpleVector{1, 2, 3}));
        assert((SimpleVector{1, 2, 3} != SimpleVector{1, 2, 2}));

        assert((SimpleVector{1, 2, 3} < SimpleVector{1, 2, 3, 1}));
        assert((SimpleVector{1, 2, 3} > SimpleVector{1, 2, 2, 1}));

        assert((SimpleVector{1, 2, 3} >= SimpleVector{1, 2, 3}));
        assert((SimpleVector{1, 2, 4} >= SimpleVector{1, 2, 3}));
        assert((SimpleVector{1, 2, 3} <= SimpleVector{1, 2, 3}));
        assert((SimpleVector{1, 2, 3} <= SimpleVector{1, 2, 4}));
    }

    // Обмен значений векторов
    {
        SimpleVector<int> v1{42, 666};
        SimpleVector<int> v2;
        v2.PushBack(0);
        v2.PushBack(1);
        v2.PushBack(2);
        const int* const begin1 = &v1[0];
        const int* const begin2 = &v2[0];

        const size_t capacity1 = v1.GetCapacity();
        const size_t capacity2 = v2.GetCapacity();

        const size_t size1 = v1.GetSize();
        const size_t size2 = v2.GetSize();

        static_assert(noexcept(v1.swap(v2)));
        v1.swap(v2);
        assert(&v2[0] == begin1);
        assert(&v1[0] == begin2);
        assert(v1.GetSize() == size2);
        assert(v2.GetSize() == size1);
        assert(v1.GetCapacity() == capacity2);
        assert(v2.GetCapacity() == capacity1);
    }

    // Присваивание
    {
        SimpleVector<int> src_vector{1, 2, 3, 4};
        SimpleVector<int> dst_vector{1, 2, 3, 4, 5, 6};
        dst_vector = src_vector;
        assert(dst_vector == src_vector);
    }

    // Вставка элементов
    {
        SimpleVector<int> v{1, 2, 3, 4};
        v.Insert(v.begin() + 2, 42);
        assert((v == SimpleVector<int>{1, 2, 42, 3, 4}));
    }

    // Удаление элементов
    {
        SimpleVector<int> v{1, 2, 3, 4};
        v.Erase(v.cbegin() + 2);
        assert((v == SimpleVector<int>{1, 2, 4}));
    }
} 

```

### Ограничения

Недопустимо передавать в методы `Insert` и `Erase` невалидные итераторы и итераторы, полученные у другого вектора. Нельзя передавать в метод `Erase` и end-итератор текущего вектора. Вызывать `PopBack` у пустого вектора тоже нельзя.

Гарантируется, что тренажёр не будет передавать недопустимые значения итераторов в методы `Insert` и `Erase` и вызывать `PopBack` у пустого вектора. Поэтому не усложняйте реализацию этих методов.

