# Инициализация объектов и конструктор по умолчанию

Предположим, мы пишем программу, которая должна использовать для вычисления обыкновенные дроби. Создадим класс `Rational` с полями `numerator_` и `denominator_`:


```cpp

using namespace std;

class Rational {
public:
    int Numerator() const {
        return numerator_;
    }

    int Denominator() const {
        return denominator_;
    }

    void SetNumerator(int numerator) {
        numerator_ = numerator;
    }

    void SetDenominator(int denominator) {
        if (denominator != 0) {
            denominator_ = denominator;
        }
    }

private:
    int numerator_;
    int denominator_;
}; 

```

Здесь мы применяем класс вместо структуры, чтобы пользователь не мог задавать произвольные значения числителя и знаменателя:

-   знаменатель не должен быть равен нулю;
-   дробь должна храниться в виде несократимой дроби — `1/3`, а не `2/6` . Это упрощает операции над дробями и снижает риск переполнения числителя и знаменателя при многократных арифметических операциях.

Начнём использовать класс `Rational` **и** обнаружим проблему. Если после объявления переменной забыть вызвать `SetNumerator` или `SetDenominator`, поля `numerator_` или `denominator_` не будут проинициализированы, и в них будет лежать случайный мусор:

Скопировать кодCPP
```cpp

// Попробуйте угадать, что выведет эта программа
Rational r;
cout << r.Numerator() << "/" << r.Denominator() << endl; 

```

Как вы узнали на вводном курсе, классы отличаются от структур поддержкой инкапсуляции **—** поля класса формируют состояние объекта и спрятаны от неконтролируемого доступа извне. С объектом можно взаимодействовать через его публичные методы, каждый из которых переводит объект из одного согласованного состояния в другое либо не изменяет его состояние.

Чтобы задать начальное состояние объекта, где все его поля согласованы, применяют конструктор. Это особый метод класса, который вызывается один раз — в момент создания объекта. В C++ конструктор определяется так:



```cpp
class Cat {
public:
    // Это конструктор
    Cat() {
        cout << "Meow"s << endl;
        name_ = "Tom"s;
    }

    string GetName() const {
        return name_;
    }

private:
    string name_;
};

int main() {
    cout << "Start"s << endl;
    Cat cat;
    cout << "The cat's name is "s << cat.GetName() << endl;
} 

```

Имя конструктора всегда совпадает с именем класса, а тип возвращаемого значения не указывается.

Запустив программу, увидим:

Скопировать кодCPP

```cpp
`Start
Meow
The cat's name is Tom` 

```

Сначала выполнится код, расположенный до объявления переменной `cat`. Затем будет создана переменная `cat` и вызван её конструктор, который проинициализирует поле `name_` и выведет “Meow”. Следом будет выведена кличка кота.

Мы только что написали конструктор без параметров — конструктор по умолчанию. Он вызывается, когда объявляют переменную класса, и инициализирует поля некоторыми значениями по умолчанию. В нашем случае конструктор дал коту кличку Tom.

Есть и другой, более простой способ задать значения по умолчанию для полей структур и классов — присвойте полям класса желаемое значение. Сам конструктор по умолчанию в этом случае можно не писать:



```cpp

// Компилятор неявно сгенерирует для структуры конструктор по умолчанию,
// задающий координатам нулевые значения
struct Point {
    int x = 0;
    int y = 0;
};

// Компилятор неявно сгенерирует для класса Cat конструктор по умолчанию,
// инициализирующий поле name_ значением "Tom"s
class Cat {
public:
    const string& GetName() const {
        return name_;
    }

private:
    string name_ = "Tom"s;
}; 


```


Итак, в C++ для инициализации экземпляра класса используют конструктор — специальный метод, который вызывается при создании объекта. Имя конструктора совпадает с именем класса, а тип возвращаемого значения не указывается. Конструктор задаёт согласованное значение для полей класса. Конструктор без параметров называется конструктором по умолчанию. Он инициализирует объект некоторым значением по умолчанию.

# Параметризованный конструктор

Вы научились задавать для полей объекта значение по умолчанию. Так все данные объекта после его создания будут согласованными.

Но используя класс `Rational`, сталкиваемся с проблемами.

-   Код, который выполняет инициализацию, слишком громоздкий. В нём целых три строки:


```cpp

`Rational x;
// Задаём для дроби значение 1/3
x.SetNumerator(1);
x.SetDenominator(3);` 

```

-   Другую проблему рассмотрим на примере. Объявим константную переменную типа `Rational`, равную `1/3`:


```cpp

`const Rational scale;
// Ошибка компиляции: 'this' argument to member function 'SetNumerator' 
// has type 'const Rational', but function is not marked const
scale.SetNumerator(1);
// Здесь будет аналогичная ошибка
scale.SetDenominator(3);` 

```

Компилятор напоминает, что у константного объекта можно вызывать только константные методы. Методы `SetNumerator` и `SetDenominator` предназначены для изменения дроби, поэтому мы и не можем их вызвать — константные объекты изменять нельзя.

Эти проблемы решит параметризованный конструктор. Он принимает один или более параметров:


```cpp

class Rational {
public:
    // Явно сообщаем компилятору, что в этом классе нужно создать конструктор по умолчанию
    Rational() = default;

    // Параметризованный конструктор
    Rational(int numerator, int denominator) {
        numerator_ = numerator;
        denominator_ = denominator;
    }

    int Numerator() const {
        return numerator_;
    }

    int Denominator() const {
        return denominator_;
    }

private:
    // Задаём значения по умолчанию для числителя и знаменателя
    int numerator_ = 0;
    int denominator_ = 1;
}; 

```

Если в классе объявлен параметризованный конструктор, конструктор по умолчанию для этого класса сгенерирован не будет. Наличие конструктора с параметрами как бы сообщает компилятору: «‎Этот класс требует особой инициализации». Если конструктор по умолчанию всё-таки нужен, вы можете написать его сами либо попросить компилятор. Для этого вместо тела конструктора укажите `= default` и задайте полям значения по умолчанию.

Чтобы использовать параметризованный конструктор, передадим ему параметры в скобках после имени переменной:


```cpp

`int main() {
    const Rational scale(1, 3);

    cout << scale.Numerator() << "/"s << scale.Denominator() << endl;
}` 

```

Применив параметризованный конструктор, мы не только избавились от многословности при объявлении объекта, но и смогли задать начальное состояние константных объектов. Часто в классах делают несколько конструкторов, задающих различные способы инициализации объектов.

# Список инициализации конструктора

В предыдущих уроках вы узнали, как создавать для класса конструктор по умолчанию и параметризованный конструктор. В этом уроке научитесь их правильно использовать для инициализации отдельных переменных, а также полей классов и структур.

### Вызов параметризованного конструктора

Когда вызываем функцию и возвращаем значение из неё, компилятор знает и типы аргументов, и тип возвращаемого значения. Поэтому имя класса перед фигурными скобками можно опустить при условии, что код останется понятным:


```cpp

Rational AddRationals(Rational r1, Rational r2) {
    int numerator = r1.Numerator() * r2.Denominator() + r2.Numerator() * r1.Denominator();
    int denominator = r1.Denominator() * r2.Denominator();

    // Компилятор знает, что функция возвращает Rational, и неявно
    // вызывает соответствующий конструктор
    return {numerator, denominator};
    // Эта запись в данном контексте аналогична:
    // return Rational{numerator, denominator};
}

int main() {
    // Компилятор знает, что функция AddRationals принимает аргументы типа Rational
    // и конструирует дроби 1/6 и 1/3
    Rational sum = AddRationals({1, 6}, {1, 3});
} 

```



Здесь инструкция `return {numerator, denominator}` расположена близко к заголовку функции, и читатель видит тип возвращаемого значения. Поэтому компактную запись можно использовать вместо `return Rational{numerator, denominator};`. Имя функции `AddRationals` чётко показывает, что именно она делает, и вызов `AddRationals({1, 6}, {1, 3})` будет понятен.

Краткую форму вызова конструктора используйте только когда у неё нет неоднозначного толкования. В остальных случаях вызывайте конструктор явно.

### Вызов параметризованного конструктора при композиции

Каждый раз, когда создаёте классы и структуры с другими классами и структурами внутри, имеете дело с композицией. Композиция — способ писать новые классы и структуры путём включения уже имеющихся. Рассмотрим структуру `RationalPoint`, которая задаёт координаты точки на плоскости, используя композицию рациональных чисел:

Скопировать кодCPP
```cpp

`struct RationalPoint {
    Rational x;
    Rational y;
};` 

```

Чтобы задать точку, можно передать в качестве координат уже имеющиеся переменные типа `Rational` или указать координаты напрямую:

Скопировать кодCPP
```cpp

 `int main() {
    // Допустимые способы объявления переменной типа Rational
    const Rational x1{7, 8};
    const Rational y1(3, 4);

    // Инициализируем поля структуры при помощи имеющихся переменных
    RationalPoint p1 = {x1, y1};

    // Инициализируем поля структуры явным образом
    RationalPoint p0 = {
        {2, 3},
        {5, 6},
    };

    // Совмещаем разные способы инициализации полей структуры
    const RationalPoint p2{x2, {7, 8}};
}` 

```

### Списки инициализации

С инициализацией полей структур всё довольно просто: поля у структуры публичные, поэтому можем свободно задавать их значения. А у классов поля приватные и защищены от доступа извне. Поэтому инициализировать их сложнее. Рассмотрим на примере классов `Cat` и `Witch`:

Скопировать кодCPP
```cpp

`class Cat {
public:
    Cat(const string& name) {
        name_ = name;
    }
    string GetName() const {
        return name_;
    }
private:
    string name_;
};

class Witch {
public:
    Witch(const string& catName) {
        cat_ = Cat{catName}; // Пытаемся задать значение полю cat_
    }
private:
    Cat cat_;
};

int main() {
    Witch hermione{"Живоглот"s};
}` 

```

Попытаемся скомпилировать код и столкнёмся с ошибкой:

Скопировать код
```cpp

`error: constructor for 'Witch' must explicitly initialize the member 'cat_' which does not have a default constructor
    Witch(const string& catName) {
    ^` 

```

Компилятор сообщает: конструктор класса `Witch` должен явно инициализировать поле `cat_`, у которого нет конструктора по умолчанию. Причём инициализация должна завершиться ещё до выполнения тела конструктора. Только так в теле конструктора можно будет безопасно обращаться к полям класса. Исправим ошибку:

Скопировать кодCPP
```cpp

`class Witch {
public:
    Witch(const string& catName) {
        // Чтобы безопасно использовать поле cat_ внутри конструктора, 
        // инициализируем его ещё до выполнения тела конструктора Witch
        cout << "Моего кота зовут "s << cat_.GetName() << endl;
    }
private:
    Cat cat_;
};` 

```

В C++ для неявной инициализации полей класса применяют конструктор по умолчанию. Поля, у которых его нет, инициализируйте явно внутри списка инициализации конструктора.

Чтобы написать список инициализации, поставьте двоеточие после скобки, закрывающей список параметров конструктора, и перечислите через запятую имена полей с их значениями внутри скобок в формате `имя_поля_1(значение_поля_1), имя_поля_2(значение_поля), ...`. Значениями полей могут быть параметры конструктора, выражения и константы. Перепишем конструкторы классов `Cat` и `Witch`:

Скопировать кодCPP
```cpp

`class Cat {
public:
    Cat(const string& name)
        // задаём значение поля name_, копируя в него аргумент конструктора
        : name_(name) 
    {
    }
    string GetName() const {
        return name_;
    }
private:
    string name_;
};

class Witch {
public:
    Witch(const string& catName)
        // Передаём параметр конструктору поля cat_
        : cat_(catName) 
    {
        cout << "Моего кота зовут "s << cat_.GetName() << endl;
    }
private:
    Cat cat_;
};` 

```

Список инициализации конструктора служит для инициализации полей класса до выполнения тела конструктора. Старайтесь всегда задавать значения полей класса в списке инициализации конструктора, а не в его теле. Тогда программа не будет выполнять двойную работу: вызывать у поля конструктор по умолчанию, а потом перезаписывать его значение через присваивание. В списке инициализации сразу вызовется нужный параметризованный конструктор.

# Явный и неявный вызов конструктора

В прошлом уроке вы познакомились с параметризованным конструктором, который принимает один или более параметров. В этом уроке разберём конструктор, принимающий один аргумент, — конвертирующий конструктор. Его можно вызвать неявным образом. Например, при передаче и возврате из функции:

Скопировать кодCPP

```cpp
`class Rational {
public:
    // Конвертирующий конструктор, создающий дробь из целого числа
    Rational(int numerator) { /* содержимое пропущено */ }
    // прочие конструкторы, методы и поля класса пропущены
};

Rational AddRationals(Rational r1, Rational r2) {
    int numerator = r1.Numerator() * r2.Denominator() + r2.Numerator() * r1.Denominator();
    int denominator = r1.Denominator() * r2.Denominator();

    return {numerator, denominator};
}

int main() {
    Rational sum = AddRationals(Rational{1, 6}, 5);
    // выведет 31/5
    cout << sum.Numerator() << "/"s << sum.GetDenominator() << endl;
}` 

```

Функция `AddRationals` оказалась способна принимать в качестве аргументов и корректно складывать не только обыкновенные дроби, но и целые числа. Вместо ожидаемого типа `Rational` мы передали значение типа `int`. Компилятор видит, что в классе `Rational` есть конструктор, способный сделать из целого числа дробь. Этот конструктор компилятор использует, чтобы создать объект типа `Rational`, а затем передаёт объект в качестве второго параметра функции. Благодаря конвертирующему конструктору функцию `AddRationals` можно применять для сложения целых и дробных чисел в любых комбинациях.

Такое приведение типов не всегда хорошо. Рассмотрим класс `Cat` и функцию `Feed`:

Скопировать кодCPP

```cpp
`class Cat {
public:
    Cat(const string& name)
        : name_(name)
    {
    }
    const string& GetName() const {
        return name_;
    }
private:
    string name_;
};

void Feed(const Cat& cat) {
    cout << cat.GetName() << ", eat some milk"s << endl;
}

int main() {
    Cat cat1{"Матроскин"s};
    Feed(cat1); // Выглядит нормально
    Feed(Cat{"Леопольд"s}); // И это тоже

    // Следующие 2 строки выглядят странно: мы кормим какой-то объект и строку
    Feed({"Том"s});
    Feed("Котёнок по имени Гав"s);
}` 

```

Когда используете конвертирующий конструктор, функцию `Feed` можно вызвать при передаче ей объектов типа `Cat` и значений типа `string`. Вызов `Feed` при передаче значений типа `string` — спорная возможность, ведь создание кота на основе некоторой строки должно выполняться явно. Все-таки строки и коты — очень разные сущности.

Чтобы запретить неявный вызов конструктора, пометьте его ключевым словом `explicit`. Обычно так помечают конструктор с одним параметром, но иногда стóит помечать конструкторы с несколькими аргументами. Взгляните на класс `Cat` с явным конструктором:

```cpp
class Cat {
public:
    explicit Cat(const string& name)
        : name_(name)
    {
    }
    const string& GetName() const {
        return name_;
    }
private:
    string name_;
}; 
```

Здесь при попытке вызвать `Feed` без явного конструирования объекта `Cat` компиляция завершится ошибкой:

Скопировать кодCPP
```cpp

int main() {
    Feed(Cat{"Матроскин"s}); // Так можно
    Feed({"Леопольд"s});     // Ошибка компиляции: no matching function for call to 'Feed'
    Feed("Живоглот"s);       // Ошибка компиляции: no matching function for call to 'Feed'
} 

```

Иногда неявный вызов конструктора с одним параметром ожидаем и не порождает вопросов при чтении кода. Но как правило, неявное преобразование типов нежелательно. Поэтому запрещайте неявный вызов: делайте явным конструктор с одним параметром, используя ключевое слов `explicit`.

# Инициализация поисковой системы

Вы уже достаточно знаете о конструкторах, чтобы использовать их для улучшения поисковой системы.

Эффективность поиска во многом зависит от фильтрации стоп-слов. Эти слова не участвуют в индексации документов, добавляемых `AddDocument`. Задать список стоп-слов можно методом `SetStopWords`. Вызов `SetStopWords` никак не влияет на уже имеющиеся документы — стоп-слова учитываются только при добавлении следующих. Такие скрытые зависимости от порядка вызова методов — результат неудачного архитектурного решения. Избегайте их. Пользователям класса неожиданности не нужны.

Правильный сценарий использования класса `SearchServer` подразумевает установку списка стоп-слов до добавления документов. Это можно указать в комментариях к методам класса, но есть способ лучше. Установка списка стоп-слов — по сути, часть инициализации поисковой системы. Поэтому правильнее задать стоп-слова в конструкторе.

Когда явно заданных конструкторов нет, структуру `Document`, несущую информацию о найденном документе, можем инициализировать, не перечисляя все поля. Но то, что это допускается, не значит, что делать так стóит:

Скопировать код
```cpp

struct Document {
    int id;
    double relevance;
    int rating;
};

int main() {
    Document doc{10, 3.5}; // Поле rating будет проинициализировано 0
} 

```

Если у структуры есть параметризованный конструктор, при её конструировании нужно указать значения всех параметров явно. Это пригодится, когда будете добавлять в структуру дополнительные поля, а в её параметризованный конструктор — дополнительные параметры. Код, передающий неполный набор параметров конструктору `Document`, не скомпилируется, и вы легко его найдёте и исправите.

# Деструкторы и время жизни объекта

В прошлых уроках вы научились работать с конструктором — особым методом класса. Его основная задача — инициализация объекта, после которой все поля объекта находятся в согласованном состоянии. Конструктор объекта вызывается один раз — в тот момент, когда объявляется переменная класса:

Скопировать кодCPP

`// В момент объявления переменной вызывается конструктор класса string
string name = "Hello"s;` 

На протяжении всей жизни объекта мы можем с ним взаимодействовать через публичные методы класса. Каждый вызов публичного метода может переводить объект в новое состояние, изменяя значения его полей, либо оставлять объект в прежнем состоянии. Методы, которые не влияют на состояние объекта, мы объявляем константными. Константные методы гарантируют, что состояние объекта при их вызове не изменится. Это позволяет вызывать их у константных объектов.

Но объекты программы не живут вечно. Рано или поздно их жизнь подходит к концу. Поэтому у класса есть ещё один специальный метод — деструктор.

### Знакомство с деструктором

Деструктор автоматически вызывается в конце жизни объекта. Имя деструктора совпадает с именем класса. Разница в том, что перед именем деструктора ставится символ `~` (тильда), а параметры не указываются:


```cpp

class SomeClass {
public:
    // Это деструктор
    ~SomeClass() {
    }
}; 

```

У класса бывает несколько конструкторов, задающих различные способы инициализации объекта. Но деструктор у класса может быть только один. Основная задача деструктора — освободить ресурсы, которые объект использовал на протяжении цикла жизни. Например:

-   освободить память, динамически выделяемую с использованием низкоуровневых функций языка или операционной системы;
-   закрыть открытые файлы и сетевые соединения.

Знакомые вам классы стандартных контейнеров `string`, `vector`, `map` и `set` динамически запрашивают память у системы, когда вы добавляете в них элементы, и освобождают ее, когда вы элементы удаляете. Деструкторы этих коллекций освобождают память от оставшихся элементов, которые вы не удалили явно:


```cpp

int main() {
    vector<int> strings;
    for (int i = 0; i < 100; ++i) {
        strings.push_back(i);
    }
} 

```

Здесь в `vector` добавили сотню элементов. Но беспокоиться о том, чтобы освободить занимаемую ими память, не стó‎ит. Деструктор класса `vector` будет вызван автоматически и сделает это за нас.

Писать собственный деструктор при повседневном программировании на C++ нужно довольно редко, особенно если пользуетесь классами стандартной библиотеки C++ и других популярных библиотек вроде [boost](http://boost.org/). Эти библиотеки созданы опытными программистами и предоставляют удобные классы, которые автоматизируют управление памятью и другими ресурсами.

Свой деструктор понадобится при разработке классов, использующих низкоуровневые функции операционной системы и компоненты, написанные на других языках. В следующих спринтах вы встретитесь с подобными задачами.

### Время жизни объекта

Чтобы узнать, в какой момент вызывается деструктор, рассмотрим класс `Greeter`, выводящий сообщения в своём конструкторе и деструкторе:


```cpp

class Greeter {
public:
    Greeter(const string& name)
        : name_(name) 
    {
        cout << "Hello, "s << name_ << "!"s << endl;
    }

    ~Greeter() {
        // Поля класса внутри деструктора еще не уничтожены, и к ним можно обращаться
        cout << "Goodbye, "s << name_ << "!"s << endl;
    }
private:
    string name_;
}; 

```

Создадим этот объект внутри цикла по массиву имён:


```cpp

int main() {
    vector<string> names = {
        "Ivan"s,
        "Vladimir"s,
    };
    for (const string& name : names) {
        cout << "Begin"s << endl;
        Greeter greeter(name);
        cout << "End"s << endl;
    }
} 

```

Запустим программу и увидим следующее:

Скопировать код

`Begin
Hello, Ivan!
End
Goodbye, Ivan!
Begin
Hello, Vladimir!
End
Goodbye, Vladimir!` 

В начале каждой итерации цикла `for` выведется текст `Begin`. Затем будет вызван конструктор по умолчанию, выводящий приветствие. Потом выведется текст `End`, и только после последней инструкции будет вызван деструктор, выводящий прощание. На следующей итерации цикла процесс повторится снова.

Итак, в C++ для деинициализации используется деструктор — метод класса, вызываемый в конце жизненного цикла объекта. Время жизни переменной в C++ ограничено блоком, внутри которого она объявлена. При выходе из блока происходит вызов деструкторов объявленных в нём переменных. Деструкторы объектов вызываются в порядке, обратном конструированию объектов.

В других ситуациях — например, для полей класса или глобальных переменных — порядок и время вызова конструкторов и деструкторов можно выяснить самостоятельно. Просто напишите класс с выводом в конструкторе и деструкторе.

Что выведет в output следующая программа? Введите ответ без пробелов.


```cpp

#include <iostream>
#include <string>

using namespace std;

class Cat {
public:
    Cat(const string& name)
        : name_(name) {
        cout << "c-"s << name_;
    }
    void Meow() const {
        cout << "-meow-"s;
    }
    ~Cat() {
        cout << "d-"s << name_;
    }
private:
    string name_;
};

int main() {
    Cat cat("tom"s);
    cat.Meow();
} 

```

Ваш ответ правильный

c-tom-meow-d-tom

с-tom-meow-d-tom

Теперь изменим код функции `main`, добавив в него ветвление:


```cpp

#include <cmath>
#include <iostream>

using namespace std;

/* код класса Greeter */

int main() {
    double n;
    cin >> n;
    
    Greeter greeter1("1"s);
    if (n < 0) {
        cout << n << " is negative"s << endl;
        return 0;
    } else {
        Greeter greeter2("2"s);
        cout << "sqrt("s << n << ") = "s << sqrt(n) << endl;
    }
    Greeter greeter3("3"s);
} 

```

Запустим программу и попробуем ввести число -10:

Скопировать код

`**-10**
Hello, 1!
-10 is negative
Goodbye, 1!` 

После ввода отрицательного числа был вызван конструктор класса `Greeter`, выводящий строчку `"Hello, 1!".` Затем поток выполнения попадёт внутрь положительного условия `if`, где будет выведено сообщение о невозможности извлечения корня. Следом оператор `return 0` выполнит выход из функции. На этом время жизни переменной `greeter1` закончится, будет вызван её деструктор. Он выведет строку `Goodbye, 1!`.

Если же запустить программу и ввести неотрицательное число, вывод программы изменится:

Скопировать код

`9
Hello, 1!
Hello, 2!
sqrt(9) = 3
Goodbye, 2!
Hello, 3!
Goodbye, 3!
Goodbye, 1!` 

Поток выполнения программы выглядит так:

![image](https://pictures.s3.yandex.net/resources/S2_02_1602840140.png)

Деструктор переменной `greeter2` вызван сразу после вывода квадратного корня, то есть при выходе из блока `else`, ограничивающего область видимости этой переменной. Деструктор переменной `greeter3` вызван раньше деструктора `greeter1`.

В C++ время жизни переменной ограничивается блоком, где она объявлена. При этом переменные, которые в этом блоке объявлены раньше, будут разрушены в последнюю очередь. То есть порядок разрушения объектов обратен порядку их конструирования.

Что выведет следующая программа? Введите ответ в одну строку без пробелов:


```cpp

#include <iostream>
#include <string>

using namespace std;

class Fruit {
public:
    Fruit(const string& name)
        : name_(name) {
        cout << "+"s << name_;
    }
    ~Fruit() {
        cout << "-"s << name_;
    }
private:
    string name_;
};

int main() {
    Fruit mango{"mango"s};

    for (string s : {"apple"s, "banana"s}) {
        Fruit fruit{s};
        if (s.length() % 2 == 0) {
            Fruit another_fruit{s};
            cout << "?"s;
        }
        cout << "!"s;
    }
} 

```

Ваш ответ правильный

+mango+apple!-apple+banana+banana?-banana!-banana-mango

+mango+apple!-apple+banana+banana?-banana!-banana-mango

Теперь попробуем передать `Greeter` в качестве параметра функции:


```cpp

void Fn(Greeter g) {
    Greeter g1("function body"s);
}

int main() {
    Fn({"function parameter"s});
} 

```

Вывод программы:

Скопировать код

`Hello, function parameter!
Hello, function body!
Goodbye, function body!
Goodbye, function parameter!` 

При вызове функции `Fn` будет сконструирован объект `Greeter` и передан в качестве аргумента функции. Его время жизни будет дольше времени жизни объекта, объявленного внутри тела функции. Опять-таки, объект, созданный раньше, будет разрушен позже.

Похожая картина будет наблюдаться и при возврате из функции. Рассмотрим вызов функции, возвращающей объект `Greeter`.


```cpp

Greeter ReturnGreeter() {
    return {"result"s};
}

int main() {
    Greeter result = ReturnGreeter();
    Greeter body("body"s);
} 

```

Вывод программы:

Скопировать код

`Hello, result!
Hello, body!
Goodbye, body!
Goodbye, result!` 

Сначала будет создан объект `Greeter` и возвращён из функции, затем он будет сохранен переменной `result`, до того как будет создана переменная `body`. И снова разрушение этих объектов произойдёт в противоположном порядке.

Что выведет следующая программа? Введите ответ в одну строчку без пробелов.


```cpp

#include <iostream>
#include <string>

using namespace std;

class Tree {
public:
    Tree() {
        cout << "+tree"s;
    }
    ~Tree() {
        cout << "-tree"s;
    }
};

class House {
public:
    House() {
        cout << "+house"s;
    }
    ~House() {
        cout << "-house"s;
    }
};

House BuildHouse(Tree tree) {
    return House{};
}

int main() {
    House house = BuildHouse({});
    cout << "~life"s;
} 

```

Ваш ответ правильный

+tree+house-tree~life-house

+tree+house-tree~life-house

Теперь попробуем просто вызвать `ReturnGreeter`, но не будем сохранять результат ни в какой переменной:


```cpp

Greeter ReturnGreeter() {
    return {"result"s};
}

int main() {
    ReturnGreeter();
    Greeter body("body"s);
} 

```

В этот раз вывод программы изменится:

Скопировать код

`Hello, result!
Goodbye, result!
Hello, body!
Goodbye, body!` 

В отличие от предыдущего примера мы не сохранили результат вызова функции в переменной. Теперь у возвращённого временного объекта нет имени, по которому к нему можно обратиться, поэтому поэтому он будет разрушен сразу после окончания инструкции вызова `ReturnGreeter();`.

---

### Задание для храбрых сердцем

Определите время жизни глобальных переменных и сравните его со временем выполнения функции `main`. В каком порядке происходит инициализация и деинициализация глобальных переменных?

---


Подсказка: объявите несколько переменных типа `Greeter` вне тела функции main и внутри нее и проанализируйте выходные данные программы. Сделайте выводы.

---

### Задание для ещё более храбрых сердцем

Определите время жизни и порядок инициализации и деинициализации полей классов и структур. Сравните время жизни полей класса со временем выполнения тела конструктора и деструктора.

Как влияет порядок перечисления полей в списке инициализации конструктора на последовательность вызова их конструкторов и деструкторов?

Как влияет порядок объявления полей внутри класса на последовательность вызова их конструкторов и деструкторов?

---

Подсказка: объявите класс с несколькими полями типа `Greeter`, инициализированными различными строками. Проанализируйте, как меняется или не меняется вывод программы при изменении порядка объявления полей внутри класса и их перечислении в списке инициализации конструктора.
