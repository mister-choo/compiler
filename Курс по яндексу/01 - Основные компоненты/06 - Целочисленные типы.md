# Целочисленные типы

Во вводном курсе мы рассмотрели стандартный целочисленный тип `int`. Все числа, записанные в коде в виде цифр, по умолчанию имеют тип `int`, если они достаточно маленькие (см. таблицу ниже). Так, если написать `auto x = 1`, переменная `x` автоматически получит тип `int`. Но это не единственный целочисленный тип данных в С++.

Целочисленные типы содержат положительные и отрицательные целые числа без дробной части. Они отличаются размером, занимаемой памятью и диапазоном значений. Есть знаковые (signed) и беззнаковые (unsigned) целочисленные типы. Знаковые хранят положительные и отрицательные числа и ноль, а беззнаковые — только натуральные числа, включая ноль.

## Целочисленные типы С++

**ТИП**

**КОЛИЧЕСТВО БАЙТОВ**

**КОЛИЧЕСТВО БИТ**

**ДИАПАЗОН ЗНАЧЕНИЙ**

int

4

32

от -2 147 483 648 до 2 147 483 647

unsigned int

4

32

от 0 до 4 294 967 295

int8_t

1

8

от -128 до 127

uint8_t

1

8

от 0 до 255

int16_t

2

16

от -32 768 до 32 767

uint16_t

2

16

от 0 до 65 535

int32_t

4

32

от -2 147 483 648 до 2 147 483 647

uint32_t

4

32

от 0 до 4 294 967 295

int64_t

8

64

от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807

uint64_t

8

64

от 0 до 18 446 744 073 709 551 615

Все типы с суффиксом `_t` из таблицы доступны при подключении библиотеки `cstdint`. Гарантируется, что они имеют указанный размер и диапазон значений.

Тип `int` (и его беззнаковый товарищ `unsigned int`) стандартный и действительно, как правило, занимает четыре байта, но это может быть не так на процессорах старой или нестандартной архитектуры.

В старом коде вы можете встретить и другие типы, размер которых чётко не определён. Но для основных архитектур всё-таки можем привести сравнение:

-   `char` — `int8_t` или `uint8_t`. Да-да, символ в C++ — это просто число с кодом этого символа.
-   `signed char` — `int8_t`
-   `unsigned char` — `uint8_t`
-   `short int` или `short` — `int16_t`
-   `unsigned short int` или `unsigned short` — `uint16_t`
-   `long int` или `long` — `int32_t`
-   `unsigned long int` или `unsigned long` — `uint32_t`
-   `long long int` или `long long` — `int64_t`
-   `unsigned long long int` или `unsigned long long` — `uint64_t`

В новом коде принято использовать `int` или типы с суффиксом `_t` из `cstdint`.

Разберёмся, как выбрать наиболее подходящий для решения задачи целочисленный тип данных.

-   Если вам достаточно размера и диапазона значений стандартного типа `int` — используйте его.
-   Если хотите хранить числа порядка триллиона, размер типа `int` не подойдёт — нужен `int64_t`.
-   Если возникла необходимость экономить память на числах, применяйте типы меньшей размерности, такие как `int8_t`, `int16_t`.
-   Если вы пишете программу, которая будет запускаться на неизвестной архитектуре, и нуждаетесь в 32-битном типе — выберите `int32_t`.

Размеры всех типов данных заучивать необязательно: в С++ есть оператор `sizeof`, который возвращает размер в байтах. Например, мы забыли размер целочисленного типа `int16_t`. Применим `sizeof`:

Скопировать кодCPP

`cout << sizeof(int16_t) << endl;` 

Программа напомнит, что размер `int16_t` составляет два байта.

Можно применить `sizeof` и к выражению. Так мы узнаем, что размер вектора занимает восемь байт:

Скопировать кодCPP

`cout << sizeof(vector<string>{}.size()) << endl;` 

Размер пустого вектора строк нулевой. Но зато каков этот ноль! Целых восемь байт.

`sizeof` удобен, когда вы уже мыслите в битах и на ходу строите логические цепочки: тип занимает восемь байт → это 64 бита → 2^64 больше 10^18 → число из 18 цифр поместится легко. Но можно и явно попросить компилятор вывести минимальное и максимальное значение любого целочисленного типа. Для этого подключим библиотеку `limits`:

Скопировать кодCPP

`#include <iostream>
#include <limits>

using namespace std;

int main() {
    cout << "sizeof = "s << sizeof(int) << endl;
    cout << "min = "s << numeric_limits<int>::min() << endl;
    cout << "max = "s << numeric_limits<int>::max() << endl;
}` 

Запустим код и увидим всё про тип `int` на нашем процессоре:

Скопировать кодCPP

`sizeof = 4
min = -2147483648
max = 2147483647` 

Вы узнали, какие целочисленные типы есть и какой объём памяти они занимают. Научились выяснять по целочисленному типу его размер, минимальное и максимальное значение. В C++ память для целочисленных типов ограничена. Далее разберёмся, что такое переполнение целочисленного типа.

Проверьте себя. Выберите наиболее подходящий и экономный тип данных для целого числа в каждой ситуации. Исходите из того, что мы живём здесь и сейчас и не планируем рост указанных величин.

# Ограниченность памяти и переполнение

Вы уже знаете, что целочисленные типы данных отличаются диапазоном значений. Если значение переменной находится вне диапазона значений указанного типа, происходит переполнение.

Рассмотрим примеры. Возьмём максимальное значение типа `int` и прибавим к нему единицу:

Скопировать кодCPP

`#include <iostream>
#include <limits>

using namespace std;

int main() {
    cout << numeric_limits<int>::max() + 1 << endl;
}` 

Современные компиляторы даже выдадут предупреждение, что мы встали на скользкую дорожку:

Скопировать код

 `warning: integer overflow in expression of type ‘int’ results in ‘-2147483648’ [-Woverflow]` 

И действительно, при запуске вместо ожидаемого 2 147 483 648 получаем отрицательное число — минимальное значение типа `int`:

Скопировать кодCPP

`-2147483648` 

Это произошло, потому что значение выражения в `int` не поместилось.

Теперь возьмём значение меньше минимального:

Скопировать кодCPP

`cout << numeric_limits<int>::min() - 1 << endl;` 

Снова предупреждение и снова не то, чего ожидали:

Скопировать кодCPP

`2147483647` 

Берём число на единицу больше, чем максимум, — получаем минимум. Берём число на единицу меньше, чем минимум, — получаем максимум. Такое в С++ переполнение.

Более практичный пример. Допустим, у нас есть два числа типа `int`: два миллиарда и один миллиард. Вычислим среднее арифметическое. Оба числа не превышают максимального значения `int`. Предполагаем, что их среднее арифметическое не превысит два миллиарда и тоже поместится в `int`. Спокойно пишем программу:

Скопировать кодCPP

`// разряды в больших числах удобно разделять символом '
int x = 2'000'000'000;
int y = 1'000'000'000;
cout << (x + y) / 2 << endl;` 

Вместо ожидаемых полутора миллиардов получаем:

Скопировать кодCPP

`-647483648` 

С++ сначала выполнил действие в скобках: сложил `x` и `y`. Получилось три миллиарда — число, которое превышает максимальное значение типа `int`. После этого всё и пошло наперекосяк.

Выбирая тип данных, нужно продумать каждый сегмент программы. Если промежуточные вычисления не поместятся в ваш тип, рискуете получить большое отрицательное число — верный признак переполнения. А когда выполняете серию арифметических операций, переполнение можете и вовсе не заметить.

Посмотрим, как это работает с беззнаковыми типами. Сохраним переменную `x` со значением два миллиарда в беззнаковую переменную `y` и выведем обе:

Скопировать кодCPP

`int x = 2'000'000'000;
unsigned int y = x;
cout << x << " "s << y << endl;` 

Запустим код и увидим, что всё в порядке, ведь это значение помещается и в `int`, и в `unsigned int`:

Скопировать кодCPP

`2000000000 2000000000` 

Теперь сохраним в переменную `x` отрицательное значение:

Скопировать кодCPP

`int x = -2'000'000'000;
unsigned int y = x;
cout << x << " "s << y << endl;` 

Запустим код. В беззнаковый тип наше значение не поместилось:

Скопировать кодCPP

`-2000000000 2294967296` 

Так происходит переполнение беззнакового целочисленного типа.

С одним беззнаковым типом мы уже сталкивались — это тип `size_t`. Во-первых, именно его возвращает метод `size` контейнеров. Во-вторых, результат вызова оператора `sizeof` тоже имеет тип `size_t`. Это вполне логично: размер чего-либо не может быть отрицательным.

Размер самого типа `size_t` зависит от разрядности вашей операционной системы. Если система 32-битная — размер `size_t` составит 32 бита (четыре байта), если 64-битная — 64 бита (восемь байт).

Вернёмся к задаче о среднем рейтинге. Имея рейтинги −5, 1 и −2, найдём их среднее арифметическое:

Скопировать кодCPP

`#include <iostream>
#include <vector>

using namespace std;

int ComputeAverageRating(const vector<int>& ratings) {
    if (ratings.empty()) {
        return 0;
    }
    int rating_sum = 0;
    for (const int rating : ratings) {
        rating_sum += rating;
    }
    return rating_sum / ratings.size();
}

int main() {
    cout << ComputeAverageRating({1, -7, 3}) << endl;
}` 

Средний рейтинг должен составить (−5+1−2) / 3 = −2. Но результат намекает на переполнение:

Скопировать код

`1431655763` 

Дело в финальном выражении функции: `rating_sum / ratings.size()`. Чтобы разделить `int` на `size_t`, компилятор привёл оба операнда к беззнаковому типу. В нём −2 не сохранить.

Поэтому и помогало предварительно привести размер вектора к знаковому типу `int`:

Скопировать кодCPP

`return rating_sum / static_cast<int>(ratings.size());` 

Избегайте переполнения типов: даже если код работает при ваших текущих настройках, он может дать сбой на другом компиляторе или ОС. Ситуаций, когда переполнение приносит пользу, — мало. Едва ли вы с ними столкнётесь.

Выбирайте подходящие типы и преобразовывайте их оператором `static_cast`. В следующем уроке вы научитесь этому на конкретных примерах и узнаете о нюансах приведения операндов к общему типу.

# Операции с целочисленными типами

Чтобы сложить дроби, человек сначала приводит их к общему знаменателю. Чтобы сравнить разные целочисленные типы или произвести над ними арифметические операции, компилятор приводит их к единому типу.

-   Все типы, размер которых меньше `int`, компилятор приводит к `int`.
-   Когда размер разных целочисленных типов равен `int` или превышает его, меньший тип преобразуется к большему.
-   Если размер типов одинаковый, но один из них беззнаковый, — компилятор приводит знаковый к беззнаковому.

Это мы увидели на примере рейтингов, когда делили `int` на `size_t`. Если `int` и `size_t` имеют размер четыре байта, компилятор приводит оба типа данных к `size_t`, так как это беззнаковый тип. Если размер `size_t` — восемь байт, а `int` — четыре байта, `size_t` снова побеждает, потому что он больше.

Допустим, мы забыли правила преобразования типов. Компилятор напомнит — достаточно специально вызвать ошибку компиляции, связанную с этим типом. Например, прибавить к целому числу то, что прибавить невозможно. Из сообщения об ошибке компиляции поймём, как преобразование типов будет происходить в данном случае.

Сравним знаковое и беззнаковое число:

Скопировать кодCPP

`int x = -1;
unsigned y = 1;
cout << (x < y) << endl;`

Сделаем код компактнее:

Скопировать кодCPP

`cout << (-1 < 1) << endl;  //сравниваем два числа напрямую` 

Теперь всё сравнивается ожидаемо: как вы помните, по умолчанию числа имеют тип `int`. Чтобы воспроизвести предыдущий пример и сделать единицу беззнаковой, добавим суффикс `u`:

Скопировать кодCPP

`cout << (-1 < 1u) << endl;` 

Суффикс `u` (или `U`) показывает, что литерал в коде относится к типу `unsinged int`. То есть:

-   тип литерала `1` — `int`;
-   тип литерала `1u` — `unsigned int`.

# Техника безопасности

Логические и арифметические операции с целочисленными типами могут вызвать внезапное переполнение. Та же проблема подстерегает при итерации по вектору циклом `for`.

Проитерируемся по вектору циклом `for` с индексом `i`. Выведем сам индекс и содержимое по этому индексу:

Скопировать кодCPP

`#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> v = {4, 5};
    for (int i = 0; i < v.size(); ++i) {
        cout << i << " "s << v[i] << endl;
    }
}` 

Убедимся, что компилятор считает предупреждения ошибками. Скомпилируем код в этом придирчивом режиме и увидим:

Скопировать код

`comparison of integer expressions of different signedness: ‘int’ and ‘std::vector<int>::size_type’ {aka ‘long unsigned int’}` 

Действительно, тип переменной `i` знаковый, а тип выражения `v.size()` — беззнаковый. Сравнивать их опасно, потому что переменная `i` может быть отрицательной.

Есть два способа решить проблему:

-   объявить переменную `i` с типом `size_t` — тогда предупреждений от компилятора не будет;
-   перед сравнением привести `v.size()` к знаковому типу.

Выбор из этих двух вариантов — дело вкуса. Часто команды разработчиков договариваются не только о том, как называть функции и расставлять пробелы, но и о подходе к использованию беззнаковых типов.

Мы остановимся на втором способе. Применим оператор `static_cast`, чтобы привести `v.size()` к `int`:

Скопировать кодCPP

`vector<int> v = {4, 5};
for (int i = 0; i < static_cast<int>(v.size()); ++i) {
    cout << i << " "s << v[i] << endl;
}` 

Когда явно приводим `v.size()` к типу `int`, нужно быть уверенными, что размер вектора не превысит 2^31 − 1. Иначе случится переполнение. Правда, векторы такого размера встречаются довольно редко: несколько гигабайт оперативной памяти под одну переменную — это не шутки.

В нашем случае переполнения нет. Код компилируется и запускается:

Скопировать код

`0 4
1 5` 

Рассмотрим другой пример. У нас есть вектор целых чисел. Мы хотим перебрать в нём все элементы, кроме последнего. Напишем цикл по индексам от 0 до `v.size() − 1` и выведем все такие элементы:

Скопировать кодCPP

`vector<int> v = {1, 4, 6};
for (size_t i = 0; i < v.size() - 1; ++i) {
    cout << v[i] << endl;
}` 

Здесь мы решились объявить индекс беззнаковым, ведь он не бывает отрицательным. При запуске видим все элементы, кроме последнего:

Скопировать кодCPP

`1
4` 

При написании кода важно проверять, что он будет работать в крайних случаях. Например, если вектор пустой и в нём нет последнего элемента. Проверим:

Скопировать кодCPP

`vector<int> v;
for (size_t i = 0; i < v.size() - 1; ++i) {
    cout << v[i] << endl;
}` 

Запустим код и увидим, что он упал. Дело в том, что `v.size()` — это ноль беззнакового типа `size_t`. Мы вычли единицу и получили максимальное значение типа `size_t`. Итерируясь от нуля до максимума, попали в чужую память. Программа сломалась.

Чтобы избежать таких сюрпризов, не вычитайте из беззнаковых типов или будьте внимательны при вычитании. Заменим вычитание сложением:

Скопировать кодCPP

`for (size_t i = 0; i + 1 < v.size(); ++i) {
    cout << v[i] << endl;
}` 

Такой цикл будет работать корректно и для пустого, и для непустого вектора.

Теперь проитерируемся по вектору в обратную сторону. Что может пойти не так?

Скопировать кодCPP

`vector<int> v = {1, 4, 5}; 
for (size_t i = v.size() - 1; i >= 0; --i) {
    cout << v[i] << endl;
}` 

При запуске код выведет много интересного, а потом упадёт. Проблема снова в переполнении: после итерации с нулевым `i` индекс уменьшится на единицу, переполнится — и станет максимальным значением типа `size_t`. Наивно было писать в цикле условие `i >= 0`: для беззнакового `i` оно верно всегда. А для пустого вектора вдобавок произойдёт переполнение в выражении `v.size() − 1`. Чтобы решить проблему, перепишем заголовок цикла `for`. Сделаем замену переменной (привет матанализу), оставив прежний смысл `i`. Проитерируемся не `i`, а индексом, который на единицу больше:

Скопировать кодCPP

`vector<int> v = {1, 4, 5};
for (size_t k = v.size(); k > 0; --k) {
    const size_t i = k - 1;
    cout << v[i] << endl;
}` 

Успех!

Скопировать кодCPP

`5
4
1` 

Встаёт вопрос, какие типы использовать — знаковые или беззнаковые. Это каждый разработчик на С++ решает самостоятельно. У вас два пути:

1.  Следовать семантике значений. Если у переменной по смыслу не бывает отрицательных значений — объявлять её беззнаковой. Минус: придётся помнить все опасности преобразования знаковых и беззнаковых типов.
2.  Избегать беззнаковых типов. То есть использовать `static_cast` и приводить все беззнаковые типы к знаковым. Минус: `static_cast` будет встречаться в вашем коде довольно часто.

Вы узнали, чем опасны операции с беззнаковыми типами, и увидели, как предотвратить проблемы. Далее разберём перечисления.

# Перечислимые типы

На целочисленных типах основаны перечислимые, или перечисляемые, — тип данных с конечным числом упорядоченных именованных значений.

Перечислимый тип объявляют ключевым словом `enum`. После ключевого слова пишут идентификатор перечисления, затем перечислители. В зависимости от позиции в наборе перечислителям присваиваются целочисленные значения:

Скопировать кодCPP

`enum CatBreed {
  RUSSIAN_BLUE,        //присваивается значение 0
  MAINE_COON,         //присваивается значение 1
  BRITISH_SHORTHAIR, //присваивается значение 2
  SIBERIAN          //присваивается значение 3
};

enum DogBreed {
  SIBERIAN_HUSKY,
  GOLDEN_RETRIEVER
  POMERANIAN,
  SAMOYED
};` 

Переменные этого типа принимают значения из заранее известного ограниченного набора. Перечислители и перечисление расположены в едином пространстве имён. Поэтому перечислители в разных наборах не должны повторяться. Например, сибирскую кошку и сибирскую хаски нельзя назвать `SIBERIAN` одновременно. Но `SIBERIAN` и `SIBERIAN_HUSKY` — разные перечислители, и проблем не возникает.

В перечислениях бывают иные проблемы и связаны они с преобразованием типов. При логических и арифметических операциях перечислимые типы неявно преобразуются к целочисленным с автоматически присвоенным значением. То есть значение русской голубой кошки и сибирской хаски будет 0, а значение мейн-куна и золотистого ретривера — 1.

Чтобы избежать неприятностей с `enum`, в C++11 появился более удобный способ перечисления: `enum class`. Каждый `enum class` считается уникальным типом. Поэтому компилятор не будет проводить операции с перечислителями из разных наборов и выдаст ошибку.

![image](https://pictures.s3.yandex.net/resources/S1_01_1597053597.png)

Посмотрим, как это работает на примере. Напишем функцию, которая обрабатывает запросы ко множеству:

Скопировать кодCPP

`void ProcessRequest(
    set<int>& numbers,
    /* ??? */ request_type,
    int request_data) {
  if (/* запрос на добавление */) {
    numbers.insert(request_data);
  } else if (/* запрос на удаление */) {
    numbers.erase(request_data);
  } else if (/* запрос на умножение на -1 */) {
    if (numbers.count(request_data) == 1) {
      numbers.erase(request_data);
      numbers.insert(-request_data);
    }
  }
}

ProcessRequest(numbers, /* добавить */, 8);
ProcessRequest(numbers, /* умножить на -1 */, 8);
ProcessRequest(numbers, /* удалить */, -8);` 

Выберем оптимальный тип параметра `request_type`. Рассмотрим несколько вариантов.

### request_type — строка

Скопировать кодCPP

`void ProcessRequest(
            set<int>& numbers,
            const string& request_type,
            int request_data) {
      if (request_type == "ADD"s) {
            numbers.insert(request_data);
      } else if (request_type == "REMOVE"s) {
            numbers.erase(request_data);
      } else if (request_type == "NEGATE"s) {
            if (numbers.count(request_data) == 1) {
                  numbers.erase(request_data);
                  numbers.insert(-request_data);
            }
      }
}

ProcessRequest(numbers, "ADD"s, 8);
ProcessRequest(numbers, "NEGATE"s, 8);
ProcessRequest(numbers, "REMOVE"s, -8);` 

Плюсы:

-   Код легко читать.

Минусы:

-   Тип `string` предназначен для произвольных строк, а мы храним в нём заранее известные. То есть тратим лишнюю память на хранение наборов символов и лишнее время на сравнение строк в функции `ProcessRequest`.
-   При вызове функции легко сделать опечатку в типе запроса. Тогда вместо ошибки компиляции запрос проигнорируется.

### request_type — число

Скопировать кодCPP

`void ProcessRequest(
            set<int>& numbers,
            int request_type,
            int request_data) {
      if (request_type == 0) {
            numbers.insert(request_data);
      } else if (request_type == 1) {
            numbers.erase(request_data);
      } else if (request_type == 2) {
            if (numbers.count(request_data) == 1) {
                  numbers.erase(request_data);
                  numbers.insert(-request_data);
            }
      }
}

ProcessRequest(numbers, 0, 8);
ProcessRequest(numbers, 2, 8);
ProcessRequest(numbers, 1, -8);` 

Плюсы:

-   Эффективнее, чем вариант со строкой.

Минусы:

-   Без комментариев непонятно, что такое `0`, `1` и `2` во втором аргументе функции `ProcessRequest`.

Код будет понятнее, если объявить именованные константы для различных типов запросов:

Скопировать кодCPP

`const int REQUEST_ADD = 0;
const int REQUEST_REMOVE = 1;
const int REQUEST_NEGATE = 2;

void ProcessRequest(
            set<int>& numbers,
            int request_type,
            int request_data) {
      if (request_type == REQUEST_ADD) {
            numbers.insert(request_data);
      } else if (request_type == REQUEST_REMOVE) {
            numbers.erase(request_data);
      } else if (request_type == REQUEST_NEGATE) {
            if (numbers.count(request_data) == 1) {
                  numbers.erase(request_data);
                  numbers.insert(-request_data);
            }
      }
}

ProcessRequest(numbers, REQUEST_ADD, 8);
ProcessRequest(numbers, REQUEST_NEGATE, 8);
ProcessRequest(numbers, REQUEST_REMOVE, -8);` 

В константы мы добавили префикс REQUEST_, чтобы не занимать популярные названия ADD, REMOVE и NEGATE. Так, ADD и NEGATE могут быть названиями арифметических операций.

Плюсы:

-   Код с константами понятнее.

Минусы:

-   При вызове функции `ProcessRequest` легко сделать опечатку и перепутать второй и третий аргументы: передать тип запроса в качестве значения и наоборот. В этом случае вместо ошибки компиляции получим обработку другого запроса, возможно, формально корректного. Ошибки такого рода тяжело искать.
-   Компилятор не станет препятствовать использованию чисел в явном виде вместо констант. Вызов `ProcessRequest(numbers, 0, 8)` он будет считать корректным.
-   Константу — REQUEST_REMOVE например, — можно умножить на два как обычное число.

Чтобы избежать этих проблем, попробуем сделать параметр `request_type` отдельным перечислимым типом данных.

### request_type — enum class

Объявим перечислимый тип `RequestType` с тремя возможными значениями: ADD, REMOVE, NEGATE:

Скопировать кодCPP

`enum class RequestType {
      ADD,
      REMOVE,
      NEGATE
};

void ProcessRequest(
            set<int>& numbers,
            RequestType request_type,
            int request_data) {
      if (request_type == RequestType::ADD) {
            numbers.insert(request_data);
      } else if (request_type == RequestType::REMOVE) {
            numbers.erase(request_data);
      } else if (request_type == RequestType::NEGATE) {
            if (numbers.count(request_data) == 1) {
                  numbers.erase(request_data);
                  numbers.insert(-request_data);
            }
      }
}

ProcessRequest(numbers, RequestType::ADD, 8);
ProcessRequest(numbers, RequestType::NEGATE, 8);
ProcessRequest(numbers, RequestType::REMOVE, -8);` 

-   Тип `RequestType` объявлен ключевыми словами `enum class`. В фигурных скобках — идентификаторы возможных значений типа.
-   `RequestType` может быть типом переменной или типом параметра функции.
-   Перед значением типа стоит префикс `RequestType::`. Вызов функции `ProcessRequest(numbers, ADD, 8)` не скомпилируется, имя ADD останется свободным.

`RequestType` и целочисленные типы неявно преобразовываться друг к другу не будут. Следовательно, вызов функции `ProcessRequest(numbers, 8, RequestType::ADD)` с перепутанными аргументами не скомпилируется.

Значения одного перечислимого типа — например `RequestType`, — сравнивают друг с другом операторами `==`, `!=`, `<` и `>`. Значения перечислимых типов могут быть элементами множеств или ключами словарей. Порядок между значениями соответствует порядку их определения при объявлении типа. В нашем примере `RequestType::ADD < RequestType::REMOVE` и `RequestType::REMOVE < RequestType::NEGATE`.