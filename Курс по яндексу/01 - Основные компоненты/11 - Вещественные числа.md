# Вещественные числа и задача о задачах

Документы в выдаче вашей поисковой системы ранжируются по релевантности. Теперь вы умеете сортировать по нескольким параметрам и можете добавить второй уровень сортировки — например, по рейтингу.

Релевантность измеряется вещественными числами, и это всё осложняет. Память, отводимая под переменную типа `double`, ограничена, а числа хранятся в двоичной записи. Поэтому их точность достаточно высока, но неидеальна. И успешно сравнивать вещественные числа на равенство можно далеко не всегда. Вот простой пример:

Скопировать кодCPP

`#include <iostream>

using namespace std;

int main() {
    double x1 = 0;
    for (int i = 0; i < 3; ++i) {
        x1 += 1.0 / 5;
    }

    double x2 = 0;
    for (int i = 0; i < 9; ++i) {
        x2 += 1.0 / 15;
    }

    cout << "x1 = "s << x1 << endl;
        // выводит x1 = 0.6

    cout << "x2 = "s << x2 << endl;
        // выводит x2 = 0.6

    cout << "(x1 == x2) = "s << (x1 == x2) << endl;
        // выводит (x1 == x2) = 0
}` 

Оказывается, 0.6 ≠ 0.6! Разберёмся почему. Если перед выводом увеличить количество отображаемых значащих цифр до 20 командой `cout.precision(20);`, увидим, что x1 = 0.60000000000000008882, а x2 = 0.5999999999999999778. То есть результат верный.

Чтобы избежать подобных сюрпризов, н**е сравнивайте вещественные числа на равенство:** не используйте ни `==`, ни `!=`, ни `<=` и `>=`. Если сделать это всё-таки нужно, вместо применения `==` вычислите разность чисел и проверьте, укладывается ли она в погрешность:

Скопировать кодCPP

`#include <cmath>
#include <iostream>

using namespace std;

int main() {
    double x1 = 0;
    for (int i = 0; i < 3; ++i) {
        x1 += 1.0 / 5;
    }

    double x2 = 0;
    for (int i = 0; i < 9; ++i) {
        x2 += 1.0 / 15;
    }

    cout.precision(20);

    const double EPSILON = 1e-6;  // 10 в степени -6
    cout << "x1 = "s << x1 << endl;
        // выводит x1 = 0.6

    cout << "x2 = "s << x2 << endl;
        // выводит x2 = 0.6

    cout << "(x1 == x2) = "s << (x1 == x2) << endl;
        // выводит (x1 == x2) = 0

    cout << "(x1 ≈ x2) = "s << (abs(x1 - x2) < EPSILON) << endl;
        // выводит (x1 ≈ x2) = 1
}` 

Функция `abs` из библиотеки `<cmath>` вычисляет модуль — абсолютную величину — числа. В данном случае мы считаем x1 ≈ x2, если x1 - 10^(-6) < x2 < x1 + 10^(-6).

В конкретной задаче числа могут становиться достаточно большими или достаточно маленькими по абсолютной величине — допустим, близкими к нулю, как 10^(-6). В таких случаях вместо абсолютной погрешности используйте относительную: например, перед сравнением с `EPSILON` делите разность на одно из чисел.