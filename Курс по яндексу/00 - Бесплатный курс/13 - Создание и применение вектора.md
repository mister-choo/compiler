# Создание и применение вектора

Представьте, что хотите сохранить в программе информацию о количестве дней в каждом месяце невисокосного года. Для этого будет удобен контейнер вектор.

Чтобы работать с ним, подключите библиотеку `<vector>`. В угловых скобках укажите тип элементов вектора. Количество дней — это число, то есть вы имеете дело с целочисленным типом `int`. Объявите переменную `month_lengths`. Тип переменной `month_lengths` — `vector<int>`. Содержимое вектора пишется в фигурных скобках:

Скопировать кодCPP

`#include <vector>

using namespace std;

int main() {
        vector<int> month_lengths = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
}` 

Как видите, в C++ фиксируют не только тип отдельной переменной, но и тип вектора. Чем строже упорядочены данные, тем эффективнее будет код, созданный компилятором.

Это одна из причин, почему программы на C++ быстрее, чем на Python. Разные типы данных — как собаки разного размера и породы. С++ — приют, где собаки отсортированы и рассажены по размеру и породе. Вольеры тоже расставлены по размеру. Удобно ориентироваться, легко найти нужную собаку. А в Python все вольеры и животные вперемешку, поэтому поиск займёт уйму времени и сил.

![image](https://pictures.s3.yandex.net/resources/_PYTHON_1609348914.png)

Чтобы выяснить размер вектора, используют метод `size`. Это работает так же, как со строкой:

Скопировать кодCPP

`#include <iostream>
#include <vector>

using namespace std;

int main() {
        vector<int> month_lengths = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
      cout << month_lengths.size() << endl;
}` 

Программа выведет:

Скопировать код

`12` 

Чтобы обратиться к конкретному элементу вектора по индексу, пишут квадратные скобки:

Скопировать кодCPP

`int month_index;
cin >> month_index;
cout << "Month " << month_index
         << " has " << month_lengths[month_index] << " days" << endl;` 

Элементы вектора можно менять. Тут будет полезна логическая операция. В високосном году февраль длиннее на один день. Отразите это в коде, применив `bool`:

Скопировать кодCPP

`bool year_is_leap = /* как-нибудь определили, високосный ли год */ 
if (year_is_leap) {
        ++month_lengths[1];
}` 

Нумерация элементов начинается с ![[Аффинные преобразования.pps]]нуля, поэтому индекс февраля — один. Индекс декабря — последнего элемента — вычисляется как `month_lengths.size() - 1`. Довольно громоздкая конструкция. Чтобы вышло короче, можно использовать метод `back`:

Скопировать кодCPP

`cout << month_lengths[month_lengths.size() - 1] << endl;  // количество дней в декабре
cout << month_lengths.back() << endl;                     // то же, но короче` 

Методы `size` и `back` нельзя назвать равнозначными и взаимозаменяемыми. С++ требует, чтобы разработчик обдумывал свои действия. Поэтому выбор зависит от конкретной ситуации. Метод `size` вы без последствий вызовете для любого вектора, потому что размер — неотъемлемое свойство вектора.

Иначе с `back`. В пустом векторе, например, нет последнего элемента. При вызове `back` для пустого вектора программа поведёт себя непредсказуемо. Причём заранее С++ об ошибке не сообщит. Проверить содержимое вектора перед вызовом `back` — забота программиста.

Чтобы проверить вектор на пустоту, используйте метод `empty`. Например, у вас есть вектор, где хранятся возрасты потерянных животных. Чтобы вывести возраст последнего, примените `back`. Но сначала проверьте, не пуст ли вектор:

Скопировать кодCPP

`vector<int> lost_pet_ages = /* зафиксировали возрасты потерявшихся животных */;
if (lost_pet_ages.empty()) {
        cout << "No pets are lost!"s << endl;
} else {
        cout << "Last pet's age is "s << lost_pet_ages.back() << endl;
}` 

Есть и другой способ проверить вектор на пустоту: вызвать `size` и сравнить результат с нулём. Но метод `empty` удобнее — меньше клавиш нажимать.

С обращением по индексу в векторе тоже непросто. Введёте некорректный индекс — программа обратится к чужой памяти. А после упадёт или продолжит работу и испортит содержимое соседнего вектора. Так что у программиста C++ много забот.

Но иногда забота нужна и самим программистам. С++ это всё же учитывает. Поэтому проверить корректность обращения к элементу вектора можно в отладочном режиме.


# Лекция, 27.09.21

## Растровый способ формирования изображения
#фотография 
Отклоняющие пластины работают, обеспечивая проход лучем всех точек экрана [[Горизонтальная и вертикальная развертка]]
Пластины работают постоянно с определенной частотой.
## Векторный ...
Луч пробегает строго по пути выведенных линий.

# Новый for и добавление элементов в конец

Вы познакомились с контейнером `vector`. Теперь пора узнать, как работать с его элементами.

Чтобы перебрать элементы вектора, используют цикл `for` и обращение по индексу. Так же, как со строками:

Скопировать кодCPP

`for (int month_index = 0; month_index < month_lengths.size(); ++month_index) {
        cout << "Month "s << month_index
                 << " has "s << month_lengths[month_index] << " days"s << endl;
}` 

Вывод:

Скопировать код

`Month 0 has 31 days
...
Month 11 has 31 days` 

Если индекс текущего элемента знать необязательно, подойдёт `range-based for` — цикл `for` по коллекции:

Скопировать кодCPP

`cout << "Month lengths are: "s;
for (int length : month_lengths) {
        cout << length << " "s;
}
cout << endl;` 

Вывод:

Скопировать код

`Month lengths are: 31 28 31 30 31 30 31 31 30 31 30 31` 

Символы в строке перебираются аналогично:

Скопировать кодCPP

`string str = "..."s;
for (char c : str) {
    // ...
}` 

Новый элемент в конец вектора добавляют методом `push_back`. Например, так можно считать содержимое вектора `lost_pet_ages` из потока ввода:

Скопировать кодCPP

`int pet_count;
cin >> pet_count;
vector<int> lost_pet_ages;
for (int i = 0; i < pet_count; ++i) {
        int age;
        cin >> age;
        lost_pet_ages.push_back(age);
}` 

Для добавления элемента в начало готового метода нет. Дело в том, что добавить элемент в конец строки и вектора — быстрая операция. А чтобы вставить что-нибудь в начало, нужно сдвинуть остальные элементы: нулевой — на первую позицию, первый — на вторую, второй — на третью.

![image](https://pictures.s3.yandex.net/resources/S3_2_1591900511.png)

_Добавление элемента в начало вектора похоже на добавление вещи на дно уже собранного чемодана_

Можно использовать метод `insert`, передав в него специальный объект `month_lengths.begin()`. Метод `begin` возвращает объект, указывающий в начало вектора:

Скопировать кодCPP

`vector<int> month_lengths = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
month_lengths.insert(month_lengths.begin(), 0);
cout << month_lengths[2] << endl;  // выведет 28 — количество дней в феврале
// Так удобно сделать, если месяцы нумеруются с 1 и не хочется это менять` 

Метод `insert` вставляет символы в начало, если вместо `begin()` указать позицию, перед которой нужен символ. Так это выглядит на примере поискового запроса о потерянном коте:

Скопировать кодCPP

`string search_query = "ухоженный пушистый кот"s;
search_query.insert(0, "-"s);  // вставляем перед позицией 0, то есть в начало
cout << search_query << endl;
// выведет -ухоженный пушистый кот` 

Слово с символом `-` перед ним в поисковом запросе — минус-слово. Это понятие вам ещё пригодится.


# Как менять размер вектора

Чтобы изменить размер вектора, используют метод `resize`. В самом простом варианте `resize` принимает один аргумент — новый размер вектора. Если аргумент меньше текущего размера, лишние элементы отбрасываются:

Скопировать кодCPP

`vector<int> car_velocities = {60, 53, 67, 19, 77, 59};
car_velocities.resize(4);
// Теперь размер вектора — 4, содержимое: 60, 53, 67, 19` 

Если новый размер больше текущего, в конец вектора добавятся недостающие элементы. Это будут стандартные «пустые» объекты соответствующего типа. Когда вектор состоит из чисел, добавляются нули, когда из строк — пустые строки, а когда из векторов — пустые векторы.

![image](https://pictures.s3.yandex.net/resources/S3_3_1609349301.png)

Так можно изменить размер вектора, который хранит возраст пропавших животных:

Скопировать кодCPP

`vector<int> lost_pet_ages = {1, 8, 2, 1, 3, 10};
lost_pet_ages.resize(10);
// Теперь размер вектора — 10, содержимое: 1, 8, 2, 1, 3, 10, 0, 0, 0, 0` 

Когда важно, чтобы новые элементы имели конкретное значение, его передают в качестве второго аргумента. Например, в случае с возрастами животных 0 — вполне валидное значение, а вот −1 сигнализирует, что конец вектора не заполнен, как следует:

Скопировать кодCPP

`vector<int> lost_pet_ages = {1, 8, 2, 1, 3, 10};
lost_pet_ages.resize(10, -1);  // читается так: вектор должен иметь размер 10,
                               // и добавить новые элементы, если нужно
                               // это должны быть числа -1
// теперь размер вектора — 10, содержимое: 1, 8, 2, 1, 3, 10, -1, -1, -1, -1` 

Нужный размер вектора можно указать при создании:

Скопировать кодCPP

`vector<int> lost_pet_ages(10, -1); // вектор из 10 элементов -1, заполним позже` 

Здесь используется так называемый конструктор класса `vector`. С этим понятием вы познакомитесь позже.