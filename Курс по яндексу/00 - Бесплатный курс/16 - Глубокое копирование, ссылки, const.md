Посмотрите на фрагмент кода:

Скопировать кодCPP

`string search_query;
cin >> search_query;
string another_search_query = search_query;` 

Как думаете, что произойдёт со строками `search_query` и `another_search_query` после этих операций?

Строки станут одним объектом с двумя названиями.

Строки станут двумя объектами с одинаковым содержимым.

Они станут двумя самостоятельными объектами с одинаковым содержанием. Иными словами, случится **глубокое копирование** строки.

![image](https://pictures.s3.yandex.net/resources/s6_cat_1_1609358918.png)

Так называют копирование, при котором изменения, внесённые в копию, не будут отражаться в оригинале. Подобное создание независимых друг от друга объектов в С++ называется «передача по значению».

В С++ есть ещё **поверхностное копирование** объектов. В этом случае наиболее тяжёлая часть содержимого объекта не копируется, а копируется только указатель на это содержимое. Таким образом, любые изменения содержимого оригинала отразятся на копии.

Глубокое копирование значит, что при изменении `another_search_query` строка `search_query` останется прежней:

Скопировать кодCPP

`string search_query = "young white kitten";
string another_search_query = search_query;
another_search_query.insert(6, "-");  // вставляем ‘-’ перед буквой ‘w’

cout << search_query << endl;
// выведет young white kitten

cout << another_search_query << endl;
// выведет young -white kitten` 

Операция `string another_search_query = search_query;` копирует данные исходной строки в новую. Если строка большая, процесс затянется. Поэтому не копируйте без необходимости.

Вспомните одну из пройденных задач:

Скопировать кодCPP

`#include <iostream>
#include <string>
#include <vector>

using namespace std;

vector<string> SplitIntoWords(string text) {
        vector<string> words;
        string word;
        for (int i = 0; i < text.size(); ++i) {
                if (text[i] == ' ') {
                        words.push_back(word);
                        word = "";
                } else {
                        word += text[i];
                }
        }
        words.push_back(word);
        
        return words;
}

int main() {
    string query;
    getline(cin, query);
    
  vector<string> words = SplitIntoWords(query);
    for (string word : words) {
            cout << '[' << word << ']' << endl;
    }
}` 

В него закралось нежелательное копирование:

Скопировать кодCPP

`vector<string> SplitIntoWords(string text) {
      // ...
}` 

В заголовке функции `SplitIntoWords` параметр `text` — новая переменная. Поэтому при вызове `SplitIntoWords(query)` происходит копирование: `string text = query;`. Это позволяет менять `text` внутри функции без ущерба для `query`.

Второе копирование происходит в последнем цикле:

Скопировать кодCPP

`for (string word : words) {
        cout << '[' << word << ']' << endl;
}` 

Здесь тоже есть новая переменная — `word`. Поэтому на шаге `i` копируется `string word = words[i];`. И таких копирований тут серия.

А в этом фрагменте всё в порядке:

Скопировать кодCPP

`vector<string> words = SplitIntoWords(query);` 

Результат функции `SplitIntoWords` не копируется в переменную `words`. Этот результат не нужен нигде кроме новой переменной. Почему так, разберём далее в курсе.

# Ссылки

Глубокое копирование приносит пользу не всегда. Поэтому его можно отменить, поставив после названия типа данных амперсанд. В этом вы могли убедиться, когда выполняли задание в предыдущем уроке.

Тип `string` — это строка. Если объявить переменную `string word;`, получится самостоятельная строка. Когда её привязывают некоторым значением `string word = value;`, происходит глубокое копирование. Такая привязка называется инициализацией.

Тип `string&` — ссылка на строку. Сама по себе она ничего не хранит, это просто ещё одно имя для *_существующего объекта_.*

![image](https://pictures.s3.yandex.net/resources/S6_02_name_1609359040.png)

_Как кота не зовите, он останется тем же котом_

Инициализация `string& word = value;` — не копирование данных, а создание новой связки ссылки и объекта. Вот как это выглядит:

Скопировать кодCPP

`string search_query = "python how to learn";
string& search_query_ref = search_query;  // ref — сокращение от reference (ссылка)
search_query_ref.insert(0, "-");

cout << search_query << endl;
// выведет -python how to learn

cout << search_query_ref << endl;
// выведет -python how to learn` 

Меняя `search_query_ref`, меняете и исходную переменную `search_query`. Но есть нюансы:

1.  Ссылку нельзя создать без инициализации — код `string& word_ref;` не скомпилируется. Это гарантирует, что любая ссылка в программе привязана к какому-либо объекту.
2.  Ссылку нельзя «перевесить» на другой объект. Код `search_query_ref = another_query;` не привяжет ссылку к объекту `another_query`, а **присвоит переменной** `search_query`, к которой привязана ссылка, **новое значение** из переменной `another_query`.

Самостоятельные ссылки внутри функций встречаются редко. Обычно ссылку задают в параметре функции или переменной цикла. Например:

Скопировать кодCPP

`for (string& word : query_words) {
        cout << '[' << word << ']' << endl;
}` 

Ссылка `string& word = query_words[i];` привязывается на очередной итерации цикла к очередному элементу вектора. Никакого копирования не происходит. Приятный бонус: такой цикл может изменить каждый элемент контейнера. Например, дописать точку в конец каждого слова запроса:

Скопировать кодCPP

`for (string& word : query_words) {
        word.push_back('.');
}` 

То же самое с параметрами функций:

Скопировать кодCPP

`vector<string> SplitIntoWords(string& text) {
      // ...
}` 

Вызов `SplitIntoWords(query)` привязывает ссылку `string& text = query;`. При любом обращении к переменной `text` внутри функции происходит обращение к исходной строке `query`. Аргумент `query` передаётся в функцию по ссылке. Если амперсанда нет — передаётся по значению. Так случится с `vector<string> SplitIntoWords(string text)`.

Передачу по ссылке часто осуществляют, когда функция должна изменить передаваемый объект. С параметром-ссылкой можно написать простую функцию, которая удалит последнее слово из переданного в неё набора:

Скопировать кодCPP

`// «Remove last word» переводится как «удалить последнее слово»
void RemoveLastWord(vector<string>& words) {
      words.pop_back();  // Метод pop_back удаляет последний элемент вектора
                         // и тем самым противоположен методу push_back.
                         // Если вектор пуст, программа может «упасть». Не искушайте судьбу.
}` 

Пример вызова функции:

Скопировать кодCPP

`string query = "bright cockatoo witnesses";
vector<string> query_words = SplitIntoWords(query);
RemoveLastWord(query_words);
for (string& word : query_words) {
        cout << '[' << word << ']' << endl;
}
// выведет [bright] [cockatoo]` 

Если убрать амперсанд из типа параметра и превратить ссылку на строку в обычную строку, вызывать функцию бессмысленно. Переданный вектор строк скопируется в параметр `words`. Что бы вы ни делали с функцией дальше, на внешние объекты это не повлияет.

# Константные ссылки

Ссылки позволяют не только избавляться от лишних копирований, но и менять внутри функции исходные объекты. Это не всегда полезно.

![image](https://pictures.s3.yandex.net/resources/S6_03_dr_1603294412.png)

Одна из концепций С++ — отловить большую часть ошибок на этапе компиляции, чтобы выполнение программы было максимально эффективным. Найти ошибки, которые связаны с непреднамеренным изменением объекта, позволяет константность. Она делает объект или ссылку неизменяемыми и защищает код от вторжения_._Такая возможность есть не во всех языках программирования. Константные ссылки применяют, чтобы:

-   передать тяжёлый объект в функцию, не копируя и не позволяя менять его внутри функции;
-   перебрать такие объекты в цикле `for` с теми же условиями.

Ссылки `const string&` или `const vector<int>&` — константные.

Неконстантные ссылки вводят разработчиков в заблуждение. Взять хотя бы последнюю версию функции, которая разбивает строки на слова:

Скопировать кодCPP

`vector<string> SplitIntoWords(string& text) {
    vector<string> words;
    string word;
    for (char c : text) {
        if (c == ' ') {
            words.push_back(word);
            word = "";
        } else {
            word += c;  // можно использовать push_back,
                        // чтобы акцентировать внимание на том,
                        // что c — символ, а не целая строка
        }
    }
    words.push_back(word);
    
    return words;
}` 

Разработчик не будет спешить использовать её в своей программе. Он читает заголовок и узнаёт, что функция:

1.  называется «разбить на слова»;
2.  возвращает вектор строк — похоже, те самые слова;
3.  принимает ссылку на строку.

Несчастный разработчик делает вывод, что функция не только возвращает набор слов, но и зачем-то меняет исходную строку.

![image](https://pictures.s3.yandex.net/resources/S1_4_vebor_1592338162.png)

Замена `string& text` на `const string& text` исправляет это недоразумение и защищает от ошибки самого автора функции. Представьте, что вместо `word += c` он случайно написал бы `text += c`. Если при этом `text` передаётся в функцию по константной ссылке, компилятор вернёт ошибку:

Скопировать код

`code.cpp: In function 'std::vector<std::__cxx11::basic_string<char> > SplitIntoWords(const string&)':
code.cpp:19:12: error: passing 'const string' {aka 'const std::__cxx11::basic_string<char>'} as 'this' argument discards qualifiers [-fpermissive]
    text += c;
            ^
In file included from <...>,
                 from code.cpp:3:
<...>/include/c++/bits/basic_string.h:1167:7: note:   in call to 'std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator+=(_CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]'
       operator+=(_CharT __c)` 

1.  Проблема возникла в команде `text += c;` в 19-й строке `code.cpp:19`.
2.  Операция применена к константной строке `passing 'const string'`.
3.  В операции (+=) ожидалась неконстантная строка `discards qualifiers`.

Выражение “discards qualifiers” сигнализирует о проблеме с константностью объекта. Но такая ошибка не повод снять `const` с типа. Если доверяете себе или разработчику, чей код используете, не меняйте константный объект.

То же самое с перебором в цикле по ссылке. Менять здесь элементы вектора автор кода не хотел:

Скопировать кодCPP

`for (string& word : query_words) {
    cout << '[' << word << ']' << endl;
}` 

Чтобы не вводить никого в заблуждение, ссылку нужно сделать константной:

Скопировать кодCPP

`for (const string& word : query_words) {
      cout << '[' << word << ']' << endl;
}` 

Константность этой ссылки поможет застраховаться от случайного изменения элементов вектора.

# Хитрости константных ссылок

В работе с константными ссылками есть особенности. Вспомните решение задачи «Очевидцы»:

Скопировать кодCPP

`void UpdateIfGreater(int limit, int& value) {
        if (limit > value) {
                value = limit;
        }
}` 

Целочисленный параметр `limit` здесь передаётся по значению. На это есть причины:

1.  Параметр `limit` — «лёгкий» объект, его не жалко скопировать.
2.  Если бы `limit` был ссылкой `int&`, не получилось бы передать туда литерал: `UpdateIfGreater(50, value)`.

С лёгкостью всё прозаично: `bool`, `char`, `int` и другие простые типы передаются по значению. Строки и всевозможные контейнеры — по константной ссылке.

Проблема с литералом есть у всех неконстантных ссылок. Нельзя написать `int& ref = 50;`, так как литерал 50 нельзя изменить. Ошибка компиляции будет такой:

Скопировать код

`error: cannot bind non-const lvalue reference of type 'int&' to an rvalue of type 'int'` 

Так происходит, потому что `non-const lvalue reference of type 'int&'` — неконстантная ссылка, а `rvalue of type 'int'` — временный объект, к которому ссылку не привяжешь.

Точно так же нельзя привязать ссылку на строку к строковому литералу `"..."s`:

Скопировать кодCPP

`#include <string>

using namespace std;

void AddLocation(string& query) {
        query += " near central station"s;
}

int main() {
        AddLocation("white cat"s);
}` 

Ошибка будет похожей, но с поправкой на громоздкость настоящего названия типа `string`:

Скопировать код

`cannot bind non-const lvalue reference of type 'std::string&' {aka 'std::__cxx11::basic_string<char>&'} to an rvalue of type 'std::__cxx11::basic_string<char>'` 

Та же неприятность возникнет, если пытаться передать в `UpdateSearchQuery` строчку, только что полученную из другой функции:

Скопировать кодCPP

`#include <iostream>
#include <string>

using namespace std;

void UpdateSearchQuery(string& query) {
        query += " free download";
}

string ReadSearchQuery() {
        string query;
        getline(cin, query);
        return query;
}

int main() {
        UpdateSearchQuery(ReadSearchQuery());
}` 

Невозможно поменять объект, у которого нет названия, ведь его не положили в переменную. С константными ссылками таких проблем не бывает. Они связаны не с изменением объекта, а с передачей без копирования.

# Константное всё

Если использовать модификатор `const`, получите от ссылок неизменяемость исходного объекта. Но `const` способен на большее.

Тип `const string&` читается как «ссылка на `const string`», где `const string` — самостоятельный тип, неизменяемая строка.

Создание переменной типа `const string`:

Скопировать кодCPP

`const string query = ReadString();

// Так ОК: для константной строки можно и узнать размер, и обратиться к символу
cout << query[query.size() - 2] << endl;

// Так нельзя: += изменяет строку
query += " free download"s;` 

Если не проинициализировать константную строку при создании, исправить это не получится никогда.

Строка `const string empty_string;` будет пустой. Но понятнее, если написать явно: `const string empty_string = ""s;`. Константность этой переменной нужна, чтобы застраховаться от случайного изменения объекта и повысить читаемость кода.

Перед вами код парсинга запроса с учётом стоп-слов:

Скопировать кодCPP

`// ...

int main() {
      // ...
    
        set<string> stop_words = ParseStopWords(stop_words_joined);
        
      // представьте, что здесь много-много кода
    
        string query;
        getline(cin, query);
        vector<string> query_words = ParseQuery(query, stop_words);
    
      // ...
}` 

Допустим, этот код написали не вы. Или вы, но много лет назад. Теперь вы пытаетесь разобраться в инициализации `vector<string> query_words`. Что такое `query` понятно: эта строка создаётся и заполняется рядом. А вот `stop_words` инициализируется намного выше в коде. Вы нашли фрагмент, где вызывается функция `ParseStopWords`. Но нет гарантии, что с момента инициализации `stop_words` эту переменную не менял никакой новый код.

Проверить, менялась ли переменная, бывает сложно. Даже если видны вызовы вроде `ParseText(text, stop_words)`, в каком-нибудь из них `stop_words` может передаваться по неконстантной ссылке и меняться внутри функции. Есть несколько способов предотвратить подобные сложности.

1.  Сделать переменную `stop_words` константной, если она не должна меняться после создания.
2.  Сделать функции, в том числе `main`, компактными, чтобы не продираться через «простыню» кода, распутывая сложную судьбу переменной. Для уменьшения размера функций вынесите их самостоятельные части в другие функции.
3.  Помечать аргументы функций, передаваемые по неконстантным ссылкам. Так принято в некоторых командах. Это приём скорее стилистический и требует дополнительных знаний.

Так можно объявить переменную `stop_words` константной:

Скопировать кодCPP

`const set<string> stop_words = ParseStopWords(stop_words_joined);` 

Понять замысел автора при чтении кода станет гораздо проще. Подобным образом действует _выразительное выделение слов_ в романе.

Компилятор не может сам определить, какие операции разрешено проводить с константным объектом, а какие нет. Поэтому авторы конкретных типов размечают методы, которые можно вызывать для константных объектов. Вы тоже сможете этому научиться.

Применение типов вы видели ещё в трёх ситуациях:

1.  Цикл `for` — `for (char c : text) { /* ... */ }`. Тут полезно заменить `char` на `const char`. Так вы отметите, что переменную `c` — символ везде в теле цикла — нельзя поменять.
2.  Параметры функций, передаваемые по значению: `void UpdateIfGreater(int limit, int& value) { /* ... */ }`. Можно объявить `const int limit`, но часто в таких случаях `const` опускают, чтобы не делать заголовок функции ещё длиннее.
3.  Возвращаемое значение функции: `vector<string> SplitIntoWords(const string& text) { /* ... */ }`. Нет смысла добавлять `const` к вектору. Ваше намерение не менять полученный из этой функции вектор лучше выразить в типе переменной, куда вы его положите.

Красота C++ в его стройности и логичности.