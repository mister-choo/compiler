# Как устроен односвязный список

В предыдущих уроках вы использовали контейнеры стандартной библиотеки. Даже в основе вспомогательного класса `PtrVector` лежал контейнер `vector`. Теперь у вас достаточно знаний, чтобы с нуля создать первый собственный контейнер — односвязный список. Это позволит разобраться в том, как устроены связные структуры данных.

Односвязный список ещё называют линейным однонаправленным списком. Эта структура данных состоит из элементов одного типа. Их логически связывают между собой указатели. Каждый элемент списка указывает на следующий, а последний — на `nullptr`. Хранятся элементы списка, как правило, в динамической памяти.

![image](https://pictures.s3.yandex.net/resources/list-abstract_4_1637705094.png)_Каждый элемент односвязного списка ссылается на следующий элемент_

Структура односвязного списка такова, что передвигаться по его элементам можно только в прямом направлении. Узнать адрес предыдущего элемента, опираясь лишь на содержимое текущего элемента, невозможно.

Односвязный список допускает следующие операции:

-   вставка элемента в начало или конец списка,
-   вставка элемента после некоторого элемента списка,
-   удаление элемента следующего за данным элементом списка,
-   проверка списка на пустоту,
-   определение количества элементов в списке.

Достоинства односвязного списка:

-   вставка и удаление элемента выполняются за константное время, то есть не зависят от количества элементов и позиции вставляемого или удаляемого элемента;
-   размер списка ограничен лишь объёмом доступной памяти.

Недостатки односвязного списка следуют из особенностей его структуры:

-   Узнать адрес элемента по его порядковому номеру — операция линейной сложности. Чтобы определить адрес N-го элемента списка, нужно последовательно перебрать все N-1 элементов, начиная с первого элемента.
-   Неэффективное расходование памяти: помимо данных, каждый элемент списка хранит указатель на следующий элемент. Кроме того, при каждом создании объекта в динамической памяти пара десятков байт расходуется на поддержание структуры кучи.
-   Не такая высокая эффективность вставки и удаления. Каждая вставка и каждое удаление обращаются к операциям работы с кучей: `new` или `delete`. Считается, что эти операции работают за константное время, однако константа может быть достаточно большой. При этом выполняется сложный код синхронизации между потоками, и могут быть задействованы низкоуровневые механизмы работы с памятью.
-   Соседние элементы списка могут располагаться в памяти непоследовательно, что снижает эффективность работы кэш-памяти.

Тем не менее односвязный список — одна из базовых связанных структур данных. Понять, как он работает, — значит сделать первый шаг к разработке более сложных структур. В стандартной библиотеке односвязный список представлен шаблоном класса [`forward_list`](https://en.cppreference.com/w/cpp/container/forward_list). Вам предстоит разработать его аналог — `SingleLinkedList`, то есть односвязный список.

Контейнер способен хранить данные произвольного типа, поэтому соответствующий класс следует объявить шаблонным:


```cpp

template <typename Type>
class SingleLinkedList {
    ...
}; 

```

Элемент списка называется «узел». Элемент списка можно представить в виде структуры `Node`, которая содержит значение элемента и указатель на следующий узел. Можно сделать структуру `Node` шаблонной, а можно просто поместить её внутрь шаблонного класса `SingleLinkedList`. В этом случае полное имя `SingleLinkedList<Type>::Node` будет содержать информацию о типе значения, которое хранится в узле:


```cpp

template <typename Type>
class SingleLinkedList {
    // Узел списка
    struct Node {
        Node() = default;
        Node(const Type& val, Node* next)
            : value(val)
            , next_node(next) {
        }
        Type value;
        Node* next_node = nullptr;
    };
    ...
}; 

```

Каждый узел списка знает, где находится следующий за ним элемент, а информацией о местоположении первого узла владеет сам класс списка. Так класс списка может управлять своим содержимым — достаточно знать адрес первого элемента, чтобы добраться до всех остальных.

В простейшем случае списку, чтобы управлять своими элементами, достаточно хранить указатель на первый элемент.

![image](https://pictures.s3.yandex.net/resources/list_structure_1_1_1643291363.png)_Список содержит указатель на первый элемент_

Если представить список так, для его хранения потребуется минимум памяти в области стека — всего четыре или восемь байт в зависимости от размера указателя. Все остальные данные хранятся в области кучи. Но у такого способа есть недостаток — узнать количество элементов в списке можно, только пройдясь по всем его элементам.

Чтобы время вычисления длины списка не зависело от количества его элементов, можно пожертвовать четырьмя или восемью байтами и добавить в список дополнительное поле, которое хранило бы размер списка.

![image](https://pictures.s3.yandex.net/resources/list_structure_2_1_1643291386.png)_Чтобы не тратить время на подсчёт элементов списка, в него добавили поле `size_`_

Пользовательский код не должен иметь возможности обратиться к узлам односвязного списка, так как:

-   Пользовательский код может случайно модифицировать структуру данных односвязного списка и нарушить её целостность. Это чревато сбоями в работе программы или утечками памяти.
-   Прямой доступ к элементам списка усложняет обход его элементов и вынуждает пользователей применять указатели.
-   Изменения в реализации списка или его узлов могут повлиять на работоспособность пользовательского кода.

Поэтому для доступа к элементам стандартных контейнеров применяют вспомогательные объекты — итераторы, которые:

-   «‎Знают»‎ о внутреннем устройстве контейнера и умеют перемещаться с одного элемента на другой.
-   Скрывают служебные данные от пользовательского кода и предоставляют простой интерфейс. Используя его, можно обращаться к значениям элементов списка и к следующему элементу.
-   Играют роль указателей на элементы контейнера в операциях вставки и удаления элементов.
-   Служат посредниками между контейнерами и алгоритмами, благодаря чему один и тот же алгоритм можно использовать с разными контейнерами.

Итератор односвязного списка хранит указатель на текущий узел. Этих данных достаточно, чтобы иметь доступ к значению узла и перемещаться к следующему узлу.

![image](https://pictures.s3.yandex.net/resources/list_structure_3_1_1643291421.png)_Итератор хранит указатель на узел списка_

Операции вставки и удаления элемента из односвязного списка требуют указателя на элемент, предшествующий позиции вставки/удаления. В этих операциях такой объект используется как опорный. Поэтому помимо знакомых вам итераторов `begin` и `end`, присущих другим контейнерам, односвязному списка нужен итератор `before_begin`. Данный итератор ссылается на позицию перед первым элементом:

![image](https://pictures.s3.yandex.net/resources/list-abstract_6_1_1643291444.png)_Итераторы `before_begin`, `begin` и `end`_

Итератор, хранящий позицию `before_begin`, обычно ссылается на фиктивный узел списка. Этот узел можно создать при инициализации списка и использовать лишь для хранения указателя на первый «‎настоящий»‎ элемент и никогда — для хранения данных. Поэтому его можно хранить не только в куче, но и в самом списке, вместо указателя на первый элемент.

![image](https://pictures.s3.yandex.net/resources/list_structure_4_1_1643291482.png)_Узлы, на которые ссылаются итераторы `begin`, `before_begin` и `end`_


```cpp

template <typename Type>
class SingleLinkedList {
    struct Node { ... };
private:
    Node head_;
    size_t size_;
}; 

```

Далее вы примените теорию на практике и шаг за шагом реализуете односвязный список. Начнём с пустого списка.

Для чего нужен фиктивный узел будет ясно ближе к концу темы. А пока что ответьте на вопрос: какие проблемы он может создать?

- Если список хранит большие объекты, то будет расходоваться лишняя память.
	- Фиктивный узел будет хранить один объект типа `Type`, который не соответствует никакому значению. Это лишние данные.
- Не получится использовать список с типами, не имеющими конструктора по умолчанию.
	- При создании фиктивного узла нужно создать объект типа `Type`. Параметры конструктора при этом не передаются.

Эти две проблемы можно обойти, но код усложнится. Поэтому будем считать, что элемент `Type` легко создаётся конструктором без параметров и не занимает много места.

# Вставка элементов и очистка списка

В предыдущем уроке вы познакомились с новой структурой данных — односвязным списком и создали каркас шаблонного класса `SingleLinkedList`, который реализует функциональность пустого списка. В этом уроке вы научитесь динамически добавлять элементы в начало и очищать список.

### Вставка элемента в начало списка

Пусть дан список, где уже есть несколько элементов `{5, 42, 8}`.

![image](https://pictures.s3.yandex.net/resources/S3_01_shema_elementov_1641996253.png)_Односвязный список с элементами `{5, 42, 8}`_

Поле `next_node` фиктивного узла `head_` хранит указатель на первый элемент списка. В случае пустого списка `head_.next_node` равен `nullptr`:

![image](https://pictures.s3.yandex.net/resources/S3_06_shema_elementov_1641996284.png)_В пустом списке указатель `head_.next_node` равен `nullptr`_

Чтобы вставить новый элемент в начало списка, нужно создать новый узел. Следующим элементом этого узла будет текущий первый элемент списка, то есть значение `head_.next_node`:

![image](https://pictures.s3.yandex.net/resources/S3_08_shema_elementov_1641996312.png)_Чтобы вставить значение 17 в начало списка `{5, 42, 8}`, создадим новый узел, который ссылается на первый узел списка_

Этот узел должен стать новым первым узлом списка. Обновим указатель `head_.next_node` и увеличим размер списка на единицу:

![image](https://pictures.s3.yandex.net/resources/S3_09_shema_elementov_1641996324.png)_Вставленный узел становится первым узлом списка. Размер списка увеличивается_

Выберите наиболее удачный вариант реализации `PushFront` для шаблона `SingleLinkedList`. Учтите, что элемент типа `Type` может выбрасывать исключение в самых неожиданных случаях. Например, при присваивании.

```cpp

template <typename Type>
class SingleLinkedList {
    ...
    void PushFront(const Type& value) {
        head_.next_node = new Node(value, head_.next_node);
        ++size_;
    }
private:
    Node head_;
    size_t size_ = 0;
}; 

```

Это самое простое решение. К тому же оно безопасно при возникновении исключений. Если во время работы оператора `new` будет выброшено исключение при выделении памяти либо при конструировании объекта, объект не создастся, а память вернётся обратно в кучу. Последующее присваивание указателя `head_.next_node` и инкремент `size_` исключений не выбрасывают.


### Очистка односвязного списка

Рассмотрим алгоритм очистки на примере односвязного списка `{5, 42, 8`.

![image](https://pictures.s3.yandex.net/resources/S3_01_shema_elementov_1_1641996358.png)_Односвязный список с элементами `{5, 42, 8}`_

Процесс очистки продолжается, пока список непустой — то есть указатель `head_.next_node` на первый элемент списка ненулевой. После первой итерации `head_.next_node` будет ссылаться на второй элемент со значением 42 по адресу `head_.next_node->next_node`, а первый элемент со значением 5 удаляется:

![image](https://pictures.s3.yandex.net/resources/S3_02_shema_elementov_1641996388.png)_Голова списка ссылается на его второй элемент, а первый элемент удаляется_

На следующих итерациях происходит то же самое. Указатель `head_.next_node` смещается на второй элемент списка `{42, 8}`, а первый элемент удаляется:

![image](https://pictures.s3.yandex.net/resources/S3_03__shema_elementov_1641996400.png)_Голова списка ссылается на значение 8, а значение 42 удаляется_

Когда в списке останется один элемент, его удаление приведёт к тому, что `head_.next_node` будет ссылаться на `nullptr`:

![image](https://pictures.s3.yandex.net/resources/S3_04_shema_elementov_1641996416.png)_Удаляется последний элемент списка. Голова указывает на значение_

На этом процесс очистки списка заканчивается. Остаётся обнулить размер списка. Получится пустой список:

![image](https://pictures.s3.yandex.net/resources/S3_05_shema_elementov_1641996421.png)

# Покоряем итераторы

Ваш односвязный список содержит методы `IsEmpty` и `GetSize`, которые позволяют узнать о наличии и количестве элементов, а также методы `PushFront` и `Clear` для вставки элемента и очистки списка. Но полноценная работа со списками предполагает не только возможность помещать внутрь него элементы, но и проходить по элементам списка.

Стандартные контейнеры вводят концепцию итератора — специального объекта, который играет роль указателя на элемент контейнера. Используем пару итераторов, чтобы задать подлежащий обходу диапазон `[начало, конец)` элементов контейнера.

![image](https://pictures.s3.yandex.net/resources/S3_1_list_struktur_1623765841.png)_Итераторы `begin`, `before_begin` и `end` и узлы, на которые они указывают_

Итераторы и полуинтервалы — абстракции, которые прячут особенности внутреннего устройства конкретного контейнера за унифицированным интерфейсом. Итераторы разных контейнеров похожи: они предоставляют операции `*` и `->` для доступа к элементам, операции `++` и `--` для обхода элементов в прямом и обратном направлении. Благодаря этой унификации и шаблонам один алгоритм способен обрабатывать содержимое различных контейнеров. Создавать под каждый отдельную версию алгоритма не нужно.

В этом уроке вы реализуете поддержку обхода элементов для класса `SingleLinkedList`, совместимую со стандартной библиотекой и циклом range-based for.

### Как устроен итератор односвязного списка

Чтобы класс или структура с точки зрения стандартных алгоритмов считались итератором, внутри должны быть объявлены вложенные типы:

-   `iterator_category`. Задаёт категорию итератора. Категория итератора сообщает стандартной библиотеке о наборе операций, поддерживаемых итератором. Так как односвязный список поддерживает перебор элементов только в прямом направлении, его категория итератора должна быть равна `std::forward_iterator_tag`;
-   `value_type`. Задаёт тип элементов, доступ к которым предоставляет итератор. В случае односвязного списка этот тип совпадает с параметром `Type` шаблона `SingleLinkedList`;
-   `difference_type`. Задаёт тип для хранения смещения между двумя итераторами. Используется в таких функциях как `std::advance` и `std::distance`. Для `SingleLinkedList` можно использовать тип `std::ptrdiff_t`. Это целое число со знаком, разрядность которого совпадает с разрядностью указателя на целевой платформе;
-   `pointer`. Задаёт тип указателя, возвращаемого операцией `->`. Для неконстантного итератора `SingleLinkedList` это `Type*`, а для константного — `const Type*`;
-   `reference`. Задаёт тип ссылки, которую возвращает операция разыменования `*`. В зависимости от константности итератора `SingleLinkedList` это либо `Type&`, либо `const Type&`.


```cpp

#include <cstddef>
#include <iterator> // Содержит объявления категорий итераторов

template <typename Type>
class SingleLinkedList {
    // Шаблон класса «Базовый Итератор»
    // определяет поведение итератора на элементы односвязного списка
    // ValueType - совпадает с Type (для Iterator) либо с const Type (для ConstIterator)
    template <typename ValueType>
    class BasicIterator {
    public:
        using iterator_category = std::forward_iterator_tag;
        using value_type = Type;
        using difference_type = std::ptrdiff_t;
        using pointer = ValueType*;
        using reference = ValueType&;
        ...
    };
    ...
}; 

```

Константный итератор подобен указателю на константу. Он предоставляет доступ к элементам контейнера только для чтения, при этом значение самого итератора можно менять. Стандартные контейнеры имеют константную и неконстантную версии методов `begin` и `end`, которые возвращают константный и неконстантный итераторы соответственно.

Итератор категории `std::forward_iterator_tag` соответствует категории однонаправленного итератора. В нём должны быть объявлены следующие операции:

-   Операции `==` и `!=`. Итераторы одного и того же списка равны, если указывают на одну и ту же позицию. Константные и неконстантные итераторы одного и того же списка можно сравнивать друг с другом;
-   Операция инкремента `++`. Перемещает итератор на следующую позицию в списке;
-   Операции `*` и `->` для доступа к элементу списка. Возвращают ссылку и указатель на значение, хранящееся в списке, а не на весь узел списка, задаваемый вложенной структурой `Node`. Помните, итераторы должны скрывать внутреннее устройство контейнера от внешнего мира.


```cpp

template <typename Type>
class SingleLinkedList {
    template <typename ValueType>
    class BasicIterator {
    public:
        ...
        [[nodiscard]] bool operator==(const BasicIterator<const Type>& rhs) const noexcept {...}
        [[nodiscard]] bool operator!=(const BasicIterator<const Type>& rhs) const noexcept {...}
        [[nodiscard]] bool operator==(const BasicIterator<Type>& rhs) const noexcept {...}
        [[nodiscard]] bool operator!=(const BasicIterator<Type>& rhs) const noexcept {...}

        BasicIterator& operator++() noexcept {...}
        BasicIterator operator++(int) noexcept {...}

        [[nodiscard]] reference operator*() const noexcept {...}
        [[nodiscard]] pointer operator->() const noexcept {...}
    ...
    };
    ...
}; 

```

Чтобы использовать `==` и `!=` для сравнения константных и неконстантных итераторов, нужно объявить две версии этих операций.

Обратите внимание на перегрузку операции инкремента. Вспомним, что в C++ есть префиксная и постфиксная формы операции инкремента и декремента.

-   Префиксная версия модифицирует объект и возвращает ссылку на текущий экземпляр класса.
-   Постфиксная версия модифицирует объект и возвращает копию прежнего значения объекта.

Постфиксная форма операций инкремента и декремента принимает фиктивный параметр типа `int`, который не используется и только подсказывает компилятору, какая версия переопределена. Как правило, постфиксная форма основывается на функционале префиксной:


```cpp

class MyType {
public:
    // Перегрузка префиксной формы
    MyType& operator++() {
        /* изменяем текущий объект */
        return *this;
    }
    // Перегрузка постфиксной формы
    MyType operator++(int) {
        auto old_value(*this); // Сохраняем прежнее значение объекта для последующего возврата
        ++(*this); // используем логику префиксной формы инкремента
        return old_value;
    }
    ...
}; 

```

Во внутреннем представлении итератор односвязного списка хранит указатель на узел списка. В операциях `*` и `->` этот указатель разыменовывается, а после инкремента итератора ссылается на следующий узел списка.

Чтобы защитить внутреннюю структуру списка от доступа извне, создавать итератор, ссылающийся на позицию внутри списка, можно только внутри `SingleLinkedList`. Для этого в конструктор итератора передаётся указатель на приватную структуру `Node`.

Приватные члены класса доступны изнутри него. Так, например, `BasicIterator` находится внутри класса `SingleLinkedList`, поэтому итератору доступны все приватные члены `SingleLinkedList`, в том числе `Node`. Но наоборот это не работает: `SingleLinkedList` находится не внутри, а снаружи `BasicIterator`. Списку доступ к приватным членам итератора закрыт.

Но некоторым операциям списка может понадобиться доступ к указателю на узел внутри итератора. В C++ класс или структура могут объявить о своём безграничном доверии другому классу, структуре или функции, назвав их дружественными. Для этого применяют ключевое слово `friend`. Класс открывает друзьям доступ к своей приватной области.

Пользуйтесь этой возможностью осторожно: неаккуратная работа с приватными полями класса способна нарушить целостность состояния объекта. Например, после изменения приватной части класса программист может забыть внести нужные правки в логику работы его друзей. Вероятность этой ситуации повышается, если класс и его друзья находятся в разных файлах. В лучшем случае код не скомпилируется, а в худшем — скомпилируется, но ошибка долго останется незамеченной.

По умолчанию класс `SingleLinkedList` не имеет доступа к приватной области своего итератора. Объявив список своим другом, итератор разрешит ему и только ему обращаться к своей внутренней части. В данном случае такое доверие обосновано, так как и список, и итератор работают с одной и той же структурой данных, скрытой от внешнего мира:


```cpp

template <typename Type>
class SingleLinkedList {
    template <typename ValueType>
    class BasicIterator {
       ...
    private:
        // Разрешаем SingleLinkedList обращаться к приватной области
        friend class SingleLinkedList;
        explicit BasicIterator(Node* node) {...}
        Node* node_ = nullptr;
    };

public:
    using Iterator = BasicIterator<Type>;
    using ConstIterator = BasicIterator<const Type>;

    [[nodiscard]] Iterator begin() noexcept {
        // Благодаря дружбе SingleLinkedList имеет доступ к приватному конструктору своего итератора
        return Iterator{head_.next_node};
    }
    ...
}; 

```

Дружба — это чудо!＊

＊Отношение дружбы — самая сильная связь в C++. Гибкие и надёжные архитектуры строятся из компонентов, минимально осведомлённых об устройстве друг друга. Классу редко следует открывать внешнему коду доступ к своей приватной области. Контейнер и его итератор — один из случаев, когда это может быть оправдано.

В примере выше будет ли `SingleLinkedList` иметь доступ к приватной части итератора, объявленного в списке другого типа? Например, будет ли `SingleLinkedList<string>` иметь доступ к `SingleLinkedList<int>::BasicIterator<int>`?

```cpp

#include <utility>

class Alibaba;

// Разбойник это объект шаблонного класса.
// Разбойники разных специализаций имеют разные шаблонные параметры.
template <typename LootType>
class Thief {
public:
    void GreetAlibaba(Alibaba& alibaba);

    LootType ConvertMoneyToLoot(int money);

private:
    LootType loot_;
};

class Alibaba {
    // Али-Баба дружит с разбойниками всех специализаций.
    // Конструкцию friend делаем шаблонной.
    template <typename T>
    friend class Thief;

private:
    int money_ = 100;
};

template <typename T>
void Thief<T>::GreetAlibaba(Alibaba& alibaba) {
    int stolen = 0;
    // Благодаря дружбе с Али-Бабой, разбойник получил доступ к 
    // его приватному полю и обнулил это поле.
    std::swap(stolen, alibaba.money_);
    loot_ += ConvertMoneyToLoot(stolen);
} 

```

### Поддержка обхода элементов

Как и многое в C++, проход по элементам циклом range-based for — не привилегия, доступная лишь стандартным контейнерам. Поддержку этого цикла можно добавить любому классу, включив в него публичные методы `begin` и `end`. Они возвращают STL-совместимые итераторы, задающие диапазон элементов контейнера:



```cpp
template <typename Type>
class SingleLinkedList {
public:
    [[nodiscard]] Iterator begin() noexcept {...}
    [[nodiscard]] Iterator end() noexcept {...}
    // Константные версии begin/end для обхода списка без возможности модификации его элементов
    [[nodiscard]] ConstIterator begin() const noexcept {...}
    [[nodiscard]] ConstIterator end() const noexcept {...}
    // Методы для удобного получения константных итераторов у неконстантного контейнера
    [[nodiscard]] ConstIterator cbegin() const noexcept {...}
    [[nodiscard]] ConstIterator cend() const noexcept {...}
    ...
};

int main() {
    SingleLinkedList<int> list;
    ...
    // Благодаря методам begin и end SingleLinkedList поддерживает range-based for
    for (int& item : list) {
        *item *= 2;
    }
}
```
# Сравнение, копирование и присваивание

В прошлом уроке вы реализовали поддержку STL-совместимых итераторов. Теперь можно обходить элементы списка и проводить над ними различные манипуляции. В частности, вам стал доступен широкий спектр стандартных алгоритмов, принимающих прямые и входные итераторы. Например, `std::find`:


```cpp

int main() {
    using namespace std;
    SingleLinkedList<int> numbers;
    ...
    if (const auto it = std::find(numbers.cbegin(), numbers.cend(), 42); it != numbers.cend()) {
        cout << "The list contains 42"s << endl;
    } else {
        cout << "The list doesn't contain 42"s << endl;
    }
} 

```

В этом уроке сделаем использование списка более удобным. Вы реализуете:

-   поддержку сравнения списков,
-   конструирование списка с указанием содержимого,
-   обмен содержимого списков,
-   копирование и присваивание.

### Сравнение списков

Содержимое стандартных контейнеров, таких как `vector`, можно сравнивать, используя операции `==`, `!=`, `>=`, `<=`, `>`, `<`, когда эти операции определены для их элементов.

Два контейнера одного типа считаются равными, когда их размеры равны и в них содержатся равные элементы. Теперь, когда список поддерживает итераторы, реализовать операцию `==` можно, применив алгоритм `std::equal`.

Операция `<` возвращает `true`, когда левый список лексикографически предшествует правому списку. Её можно реализовать, используя алгоритм [`std::lexicographical_compare`](https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare). Например, список `{1, 2, 3}` лексикографически предшествует спискам `{1, 2, 4}`, `{1, 3}` и `{1, 2, 3, 1}`.

Остальные операции можем реализовать на основе `==` и `<`. Например, выражение `list1 > list2` эквивалентно `list2 < list1`, а `list1 <= list2` — противоположно `list2 < list1`.

### Обмен содержимого списков

У многих классов стандартной библиотеки есть метод `swap`, обменивающий состояние объекта с другим объектом того же типа без выбрасывания исключений. Функция `swap` лежит в основе идиомы copy-and-swap и помогает писать код, устойчивый к исключениям. Когда разработаете метод `swap` в классе `SingleLinkedList`, вам станет проще реализовать надёжное конструирование, копирование и присваивание односвязных списков.

Реализовать метод `swap` довольно просто. Элементы списка хранятся в динамической памяти, а сам список хранит лишь адрес своего первого элемента и размер. Чтобы обменять содержимое двух списков, надо обменять размеры списков и указатели на первые элементы.

![image](https://pictures.s3.yandex.net/resources/Group_1104_1643316533.png)_Процесс обмена содержимого списков_

Такой обмен выполняется за время O(1), не требует выделения динамической памяти и не выбрасывает исключений.

Для удобства реализуем шаблонную функцию `swap`, использующую метод `swap`. Она позволит без лишнего копирования и выбрасывания исключений обменивать содержимое двух списков, как это делает `std::swap`. Для каждого из стандартных контейнеров есть специализированная версия функции `swap`, основанная на вызове метода `swap` соответствующего контейнера:


```cpp

template <typename Type>
class SingleLinkedList {
public:
    // Обменивает содержимое списков за время O(1)
    void swap(SingleLinkedList& other) noexcept {...}
    ...
};

template <typename Type>
void swap(SingleLinkedList<Type>& lhs, SingleLinkedList<Type>& rhs) noexcept {
    lhs.swap(rhs);
}

int main() {
    SingleLinkedList<int> list_1;
    SingleLinkedList<int> list_2;
    ...
    swap(list_1, list_2);
} 

```

Если функцию `swap` декларировать в h-файле, нужно ли её реализацию выносить в cpp-файл?

Нет, так как функция шаблонная.

Декларация шаблонной функции должна быть доступна при её настройке, поэтому шаблонные функции нужно размещать в h-файле. Если вам заранее известен перечень всех возможных специализаций, тело функции можно разместить в cpp-файле, явно указывая, какие специализации потребуются.

### Создание списка из std::initializer_list

Стандартные контейнеры поддерживают свою инициализацию путём передачи набора элементов напрямую в конструктор:


```cpp

#include <cassert>
#include <vector>

using namespace std;

int main() {
    vector<int> numbers{10, 20, 30, 40, 50};
    assert(numbers.size() == 5u);
    assert(numbers[2] == 30);
} 

```

Это не какая-нибудь магия, доступная только классам стандартной библиотеки. Компилятор, встречая список элементов внутри фигурных скобок, конструирует экземпляр класса [`std::initializer_list`](https://en.cppreference.com/w/cpp/utility/initializer_list). Применив этот легковесный шаблонный класс, можно получить доступ к созданному списку элементов. Один из конструкторов класса `vector` принимает параметр типа `initializer_list` и конструирует вектор, содержащий копию элементов переданного списка. Подобный конструктор есть и у других классов стандартной библиотеки.

`initializer_list` имеет методы `size`, `begin` и `end`. Они позволяют узнать его размер и перебрать элементы списка инициализации:


```cpp

#include <initializer_list>
#include <cassert>

int main() {
    std::initializer_list<int> items = {2, 3, 4};
    
    assert(items.size() == 3);
    
    int sum = 0;
    for (auto item : items) {
        sum += item;
    }
    assert(sum == 9);
    
    auto it = items.begin();
    int product = 1;
    while (it != items.end()) {
        product *= *it;
        ++it;
    }
    assert(product == 24);
} 

```

Добавим классу `SingleLinkedList` конструктор, принимающий `initializer_list`, и сможем совместить инициализацию списка с наполнением его элементами.

![image](https://pictures.s3.yandex.net/resources/Group_1106_1643376906.png)_`initializer_list` и список, который из него сконструирован_


```cpp

template <typename Type>
class SingleLinkedList {
public:
    SingleLinkedList(std::initializer_list<Type> values) {...}
    ...
};

int main() {
    SingleLinkedList<int> list{1, 2, 3, 4};
    assert(list.GetSize() == 4);
    assert(*list.begin() == 1);
} 

```

`initializer_list` принимают по значению, так как это легковесный объект. При его копировании не происходит глубокое копирование элементов.

### Копирование списка

Как вы наверняка догадались, сгенерированный компилятором конструктор копирования для класса `SingleLinkedList` не подойдёт. Копия будет использовать те же узлы, что и оригинальный список, и при разрушении одного из списков указатель на первый узел второго списка станет невалидным, что приведёт к неопределённому поведению. Точь-в-точь как у осьминогов со сросшимися щупальцами. А это значит, что для односвязного списка нужен пользовательский конструктор копирования, который создаст копию элементов исходного списка.

Конструктор копирования важно сделать безопасным к возникновению исключений — их выбрасывание во время работы не должно приводить к утечкам памяти и неопределённому поведению. Ещё следует помнить, что при выбрасывании исключения во время конструирования объекта деструктор создаваемого объекта вызван не будет.

Один из самых простых способов сделать надёжный конструктор копирования — применить идиому copy-and-swap:

-   Создать внутри конструктора копирования временный односвязный список и последовательно скопировать внутрь него элементы исходного списка. Если на этом этапе будет выброшено исключение, деструктор временного списка освободит память от его элементов.
-   Когда временный список будет содержать копию исходного списка, останется использовать метод `swap` и обменять состояние текущего экземпляра класса и временного списка.


```cpp

template <typename Type>
class SingleLinkedList {
public:
    SingleLinkedList(const SingleLinkedList& other) {
        // Сначала надо удостовериться, что текущий список пуст
        assert(size_ == 0 && head_.next_node == nullptr);

        SingleLinkedList tmp;
        
        /* скопировать внутрь tmp элементы other */

        // После того как элементы скопированы, обмениваем данные текущего списка и tmp
        swap(tmp);
        // Теперь tmp пуст, а текущий список содержит копию элементов other
    }
    ...
}; 

```

Чтобы написать надёжный код на C++, используйте идиому RAII. С ней код будет ещё и более простым, так как своевременный вызов деструктора обеспечивается компилятором.

Вы встречались с этой идиомой ранее, когда писали профилировщик. Идиома RAII заключается в том, что время жизни ресурса неразрывно связывается со временем жизни объекта — в конструкторе происходит получение ресурса, а в деструкторе — освобождение.

Здесь владение элементами списка временно поручается локальной переменной `tmp`. Так копируемые элементы списка будут находиться под управлением этой переменной, пока не совершится операция обмена.

Вы ещё вернётесь к подробному изучению идиомы RAII в будущих спринтах, а пока рекомендуем ознакомиться с ней здесь: [https://en.cppreference.com/w/cpp/language/raii](https://en.cppreference.com/w/cpp/language/raii)

При конструировании односвязного списка на основе `initializer_list` также пригодится идиома copy-and-swap.

### Присваивание списка

Операцию присваивания, последнюю из «Правила трёх»‎, можно легко и надёжно реализовать, применив идиому copy-and-swap:

-   Проверьте, не выполняется присваивание списка самому себе, сравнив адреса левого и правого аргументов операции присваивания.
-   Сконструируйте временную копию правого аргумента. Выбрасывание исключения на этом этапе никак не повлияет на состояние текущего объекта (левый аргумент операции присваивания).
-   Используйте метод `swap`, чтобы обменять содержимое временной копии и текущего объекта. Операция `swap` исключений не выбрасывает и выполняется быстро. Временная копия будет содержать предыдущее значение левого аргумента, а текущий экземпляр — копию правого аргумента операции присваивания.
-   При выходе из операции `=` временный объект будет разрушен, освободив память от предыдущего содержимого списка.

# Вставка и удаление в произвольной позиции

В прошлом уроке вы реализовали операции над списком в целом: сравнение, присваивание, обмен содержимым. На практике часто возникает потребность в ‎точечной‎ модификации списка: вставка и удаление элементов из произвольной позиции списка. В этом уроке вы разработаете эти операции.

### Вставка элемента в произвольную позицию списка

Вспомним структуру односвязного списка. Его элементы хранятся в узлах, последовательно связанных друг с другом. Эти узлы представлены структурой `Node`, которая хранит значение элемента и указатель на следующий узел.

Адрес какого узла нужно знать, чтобы вставить новый элемент в произвольное место односвязного списка?

Узла, который предшествует вставляемому элементу

В односвязном списке каждый узел ссылается на следующий за ним элемент. Предыдущий узел должен сослаться на вставляемый, а вставляемый — на следующий.

Итак, чтобы вставить новый узел, нужно иметь доступ к узлу, который предшествует позиции вставки. Проблема возникнет при вставке в начало: полноценного предшествующего узла в этом случае не будет. Тут пригодится фиктивный узел `head_`, который расположен «‎перед первым элементом»‎. Чтобы получить итератор на него, используем методы `before_begin` и `cbefore_begin`:


```cpp

template <typename Type>
class SingleLinkedList {
public:
    [[nodiscard]] Iterator before_begin() noexcept;
    [[nodiscard]] ConstIterator cbefore_begin() const noexcept;
    [[nodiscard]] ConstIterator before_begin() const noexcept;
    ...
}; 

```

![image](https://pictures.s3.yandex.net/resources/list_structure_4_1_1639143603.png)_Список из трёх элементов и итераторы `begin`, `before_begin`, `end`_

Вот алгоритм вставки значения `X` после узла `N`:

1.  Создаём новый узел со значением `X`.
2.  С нового узла ссылаемся на `N.next_node`.
3.  С `N` ссылаемся на новый узел.

![image](https://pictures.s3.yandex.net/resources/insert_after_1639143683.png)_Вставка числа 50 после элемента 20 в список с элементами 10, 20, 30, 40. pos показывает позицию вставки, а p — возвращаемый итератор_

После вставки нужно увеличить размер списка и вернуть итератор, который ссылается на вновь созданный узел. Возвращённый итератор можем использовать, например, для вставки следующего элемента:


```cpp

int main() {
    SingleLinkedList<int> list;
    auto pos = list.InsertAfter(list.cbefore_begin(), 1);
    pos = list.InsertAfter(pos, 2);
    list.InsertAfter(pos, 3);
    // Список содержит {1, 2, 3}
} 

```

При вставке нужно выделить динамическую память и скопировать вставляемое значение. Это может привести к выбрасыванию исключения. Чтобы метод `InsertAfter` обеспечивал строгую гарантию безопасности исключений, примените подход, использованный в методе `PushFront`, — сначала создайте узел в динамической памяти, а потом обновите связи между узлами и размер списка.

### Удаление элемента из начала списка

Обозначим первый узел как `N` и опишем процесс его удаления:

-   указатель фиктивного элемента начинает указывать на `N.next_node`,
-   узел `N` удаляется.

Эта операция выполняется за время O(1). Она не требует динамического выделения памяти, поэтому не выбрасывает исключений. Если, конечно, их не выбрасывает деструктор типа `Type`.

![image](https://pictures.s3.yandex.net/resources/pop_front_1639143754.png)_Процесс удаления первого узла из списка с элементами 10, 20, 30, 40_

К пустому списку операцию удаления первого элемента применить нельзя.

### Удаление элемента в произвольной позиции

Адрес какого узла нужно знать, чтобы удалить произвольный элемент односвязного списка? 

Узла, который предшествует удаляемому элементу

Поле `next_node` предыдущего узла позволяет получить указатель на удаляемый узел. После удаления узла в поле `next_node` нужно записать адрес узла, который следует за удалённым.


Чтобы удалить элемент в произвольной позиции односвязного списка, нужен доступ к узлу, который предшествует удаляемому элементу. После удаления указатель с предшествующего узла будет ссылаться на узел, следующий за удаляемым. Эта операция выполняется за время O(1), так как не требует доступа к другим узлам односвязного списка.

Такая операция не выбрасывает исключений, потому что не требует динамического выделения памяти. Операция `delete`, вызываемая, чтобы удалить узел списка, тоже не выбрасывает исключений. Исключения могут возникнуть, если их выбросит деструктор типа `Type`, но это нетипичная ситуация — лучше никогда не выбрасывать исключений в деструкторах.

![image](https://pictures.s3.yandex.net/resources/erase_after_1639143805.png)_Удаление элемента 30 из списка с элементами 10, 20, 30, 40. Итератор `pos` обозначает удаляемый узел, а `p` — узел, следующий за удалённым_

Метод `EraseAfter` возвращает итератор, который ссылается на элемент, следующий за удалённым, либо на `end`, если произошло удаление последнего элемента списка. Возвращённый итератор можно использовать для обработки следующих элементов.